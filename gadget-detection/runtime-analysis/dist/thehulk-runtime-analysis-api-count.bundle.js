// JALANGI DO NOT INSTRUMENT
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/entry.js":
/*!**********************!*\
  !*** ./src/entry.js ***!
  \**********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _others_dom_clobbering_verifier_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./others/dom-clobbering-verifier.js */ \"./src/others/dom-clobbering-verifier.js\");\n// JALANGI DO NOT INSTRUMENT\n/**\n * @description\n * --------------------------------\n * This script is the entrypoint of the analysis script which will \n * 1/ read the config file and apply it\n * 2/ install the analysis class to the J$.analysis  \n * \n * @usage \n * --------------------------------\n */\n\n// import { TaintTracking } from './taint-tracking.js'\n// import { CountMostFrequentlyUsedBuiltinsAnalysis } from './others/most-frequently-used-api.js'\n\n\nif (J$$) {\n  // J$$.analysis = new TaintTracking(J$$);\n  // J$$.analysis = new CountMostFrequentlyUsedBuiltinsAnalysis(J$$);\n  J$$.analysis = new _others_dom_clobbering_verifier_js__WEBPACK_IMPORTED_MODULE_0__.DOMClobberingVerifier(J$$);\n} else{\n  throw \"[TheHulk] Analysis module cannot be installed. J$$ not found.\"\n}\n\n\n// import './taint-expose.js'\n\n//# sourceURL=webpack://thehulk-taint-analysis/./src/entry.js?");

/***/ }),

/***/ "./src/others/dom-clobbering-verifier.js":
/*!***********************************************!*\
  !*** ./src/others/dom-clobbering-verifier.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DOMClobberingVerifier: () => (/* binding */ DOMClobberingVerifier)\n/* harmony export */ });\n/* harmony import */ var _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/logger.js */ \"./src/utils/logger.js\");\n/*\n * Copyright 2014 Samsung Information Systems America, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *        http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Author: Koushik Sen\n\n// do not remove the following comment\n// JALANGI DO NOT INSTRUMENT\n\n\n/**\n * @description\n * --------------------------------\n * This class is used to check whether the attacker-injected value can flow to the taint sinks.\n * It will check the arguments of the sinks to see whether it contains string: HULK\n */\nclass DOMClobberingVerifier {\n  constructor(sandbox) {\n    this.taintSinkRules = new TaintSinkRules();\n    this.logger = new _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Logger({\n      level: 'info',\n      name: 'TheHulk'\n    });\n\n    this.report = [];\n    this.payload = \"\";\n    this.injected = false;\n  }\n  \n  /**\n   * This callback is called before the execution of a JavaScript file\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {string} instrumentedFileName - Name of the instrumented script file\n   * @param {string} originalFileName - Name of the original script file\n   */\n  scriptEnter(iid, instrumentedFileName, originalFileName) {\n    if (!this.injected) {\n      try {\n        document.head.insertAdjacentHTML('beforeend', this.payload);\n        J$$.analysis.injected = true;\n      } catch (error) {\n        console.error(\"Error injecting the HTML markup:\", error);\n      }\n    }\n  }\n\n  /**\n   * This callback is called before a function, method, or constructor invocation.\n   * Note that a method invocation also triggers a {@link MyAnalysis#getFieldPre} and a\n   * {@link MyAnalysis#getField} callbacks.\n   *\n   * @example\n   * y.f(a, b, c)\n   *\n   * // the above call roughly gets instrumented as follows:\n   *\n   * var skip = false;\n   * var aret = analysis.invokeFunPre(113, f, y, [a, b, c], false, true);\n   * if (aret) {\n   *     f = aret.f;\n   *     y = aret.y;\n   *     args = aret.args;\n   *     skip = aret.skip\n   * }\n   * if (!skip) {\n   *     f.apply(y, args);\n   * }\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {function} f - The function object that going to be invoked\n   * @param {object} base - The receiver object for the function <tt>f</tt>\n   * @param {Array} args - The array of arguments passed to <tt>f</tt>\n   * @param {boolean} isConstructor - True if <tt>f</tt> is invoked as a constructor\n   * @param {boolean} isMethod - True if <tt>f</tt> is invoked as a method\n   * @param {number} functionIid - The iid (i.e. the unique instruction identifier) where the function was created\n   * @param {number} functionSid - The sid (i.e. the unique script identifier) where the function was created\n   * {@link MyAnalysis#functionEnter} when the function <tt>f</tt> is executed.  The <tt>functionIid</tt> can be\n   * treated as the static identifier of the function <tt>f</tt>.  Note that a given function code block can\n   * create several function objects, but each such object has a common <tt>functionIid</tt>, which is the iid\n   * that is passed to {@link MyAnalysis#functionEnter} when the function executes.\n   * @returns {{f: function, base: Object, args: Array, skip: boolean}|undefined} - If an object is returned and\n   * the <tt>skip</tt> property of the object is true, then the invocation operation is skipped.\n   * Original <tt>f</tt>, <tt>base</tt>, and <tt>args</tt> are replaced with that from the returned object if\n   * an object is returned.\n   *\n   */\n  invokeFunPre (iid, f, base, args, isConstructor, isMethod, functionIid, functionSid) {\n    try{\n      let reason = this.taintSinkRules.checkTaintAtSinkInvokeFun(f, base, args);\n      if (reason) {\n        this.logger.reportVerifedFlow(reason, this.payload);\n        __reportDangerousFlowPlaywright && __reportDangerousFlowPlaywright({\n          sink: reason,\n          payload: this.payload\n        });\n      }\n    } finally {\n      return {f: f, base: base, args: args, skip: false};\n    }\n  };\n\n  /**\n   * This callback is called before a import module function invocation.\n   * @param {string|URL} moduleURL \n   */\n  importModulePre(moduleURL) {\n    if ((typeof moduleURL === 'string' && moduleURL.toLowerCase().includes('hulk')) ||\n        (moduleURL instanceof URL && moduleURL.origin.includes('hulk'))) {\n      this.logger.reportVerifedFlow(\"SINK-TO-IMPORT-MODULE\", this.payload);\n      __reportDangerousFlowPlaywright && __reportDangerousFlowPlaywright({\n        sink: \"SINK-TO-IMPORT-MODULE\",\n        payload: this.payload\n      });\n    }\n  }\n\n  /**\n   * This callback is called before a property of an object is written.\n   * \n   * @steps\n   * 1/ We will instrument the code if it has been set to .innerHTML\n   * \n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {*} base - Base object\n   * @param {*} offset - Property\n   * @param {*} val - Value to be stored in <code>base[offset]</code>\n   * @param {boolean} isComputed - True if property is accessed using square brackets.  For example,\n   * <tt>isComputed</tt> is <tt>true</tt> if the get field operation is <tt>o[p]</tt>, and <tt>false</tt>\n   * if the get field operation is <tt>o.p</tt>\n   * @param {boolean} isOpAssign - True if the operation is of the form <code>o.p op= e</code>\n   * @returns {{base: *, offset: *, val: *, skip: boolean} | undefined} -  If an object is returned and the <tt>skip</tt>\n   * property is true, then the put field operation is skipped.  Original <tt>base</tt>, <tt>offset</tt>, and\n   * <tt>val</tt> are replaced with that from the returned object if an object is returned.\n   */\n  putFieldPre (iid, base, offset, val, isComputed, isOpAssign) {\n    try{\n      let reason = this.taintSinkRules.checkTaintAtSinkPutField(base, offset, val);\n      if (reason) {\n        this.logger.reportVerifedFlow(reason, this.payload);\n        __reportDangerousFlowPlaywright && __reportDangerousFlowPlaywright({\n          sink: reason,\n          payload: this.payload\n        });\n      }\n    } finally {\n    return {base: base, offset: offset, val: val, skip: false};\n    }\n  };\n}\n\n\nclass TaintSinkRules {\n\n  /**\n   * @description\n   * --------------------------------\n   * This class defines the taint sink policy.\n   * This function will be invoked during the putField operation hook.\n   * \n   * SINK-TYPE-1-0:\n   * - SINK-TO-SCRIPT-SRC\n   * - Tainted value flows to the script.src property.\n   * - E.g. script.src = taintedValue\n   * - Conditions:\n   *   - `base` is a script element\n   *   - `offset` is 'src'\n   * \n   * SINK-TYPE-1-1:\n   * - SINK-TO-DOM-ELEMENT-INNERHTML\n   * - Tainted value flows to the innerHTML property of a DOM element.\n   * - E.g. element.innerHTML = taintedValue\n   * - Conditions:\n   *   - `base` is a DOM element\n   *   - `offset` is 'innerHTML'\n   * \n   * SINK-TYPE-1-2:\n   * - SINK-TO-DOM-ELEMENT-OUTERHTML\n   * - Tainted value flows to the outerHTML property of a DOM element.\n   * - E.g. element.outerHTML = taintedValue\n   * - Conditions:\n   *   - `base` is a DOM element\n   *   - `offset` is 'outerHTML'\n   * \n   * SINK-TYPE-1-3:\n   * - SINK-TO-DOM-ELEMENT-SRCDOC\n   * - Tainted value flows to the srcdoc property of an iframe element.\n   * - E.g. iframe.srcdoc = taintedValue\n   * - Conditions:\n   *   - `base` is an iframe element\n   *   - `offset` is 'srcdoc'\n   * \n   * SINK-TYPE-1-4:\n   * - SINK-TO-LINK-HREF\n   * - Tainted value flows to the srcdoc property of an iframe element.\n   * - E.g. link.rel = 'script'; link.href = taintedValue\n   * - Conditions:\n   *   - `base` is an link element\n   *   - `offset` is 'href'\n   *   - (`base.rel` is 'script') \n   *     sometimes rel attribute is defined after href attribute\n   * \n   * SINK-TYPE-2:\n   * - SINK-TO-WINDOW-LOCATION\n   * - Tainted value flows to the window.location property.\n   * - E.g. window.location = taintedValue\n   * - Conditions:\n   *   - `base` is the window object\n   *   - `offset` is 'location'\n   * \n   * SINK-TYPE-3:\n   * - SINK-TO-LOCATION-HREF\n   * - Tainted value flows to the href property of the window.location object.\n   * - E.g. window.location.href = taintedValue\n   * - Conditions:\n   *   - `base` is the window.location object\n   *   - `offset` is 'href'\n   * \n   * SINK-TYPE-4:\n   * - SINK-TO-DOCUMENT-COOKIE\n   * - Tainted value flows to the cookie property of the document object.\n   * - E.g. document.cookie = taintedValue\n   * - Conditions:\n   *   - `base` is the document object\n   *   - `offset` is 'cookie'\n   * \n   * SINK-TYPE-5:\n   * - SINK-TO-DOCUMENT-DOMAIN\n   * - Tainted value flows to the domain property of the document object.\n   * - E.g. document.domain = taintedValue\n   * - Conditions:\n   *   - `base` is the document object\n   *   - `offset` is 'domain'\n   * \n   * @param {*} base - The base object of the getField operation (which should not be a WrappedValue).\n   * @param {*} offset - The offset (property name) of the getField operation.\n   * @param {*} val - The value being assigned in the getField operation.\n   * @param {number} iid - The instruction id.\n   */\n  checkTaintAtSinkPutField(base, offset, val) {\n    if (\n      !(typeof val === 'string' || val instanceof URL) ||\n      !(val.toString().toLowerCase().includes('hulk'))\n    ) {\n      return;\n    }\n\n    if (base instanceof Element) {\n      try {\n        if (base.tagName && base.tagName.toUpperCase() === 'SCRIPT' && offset === 'src') {\n          return \"SINK-TO-SCRIPT-SRC\";\n        } else if (base.tagName && base.tagName.toUpperCase() === 'SCRIPT' && offset === 'text') {\n          return \"SINK-TO-SCRIPT-TEXT\";\n        } else if (offset === 'innerHTML' || offset === 'outerHTML') {\n          return `SINK-TO-DOM-ELEMENT-${offset.toUpperCase()}`;\n        } else if (offset === 'srcdoc') {\n          return \"SINK-TO-DOM-ELEMENT-SRCDOC\";\n        } else if (base.tagName && base.tagName.toUpperCase() === 'LINK' && offset === 'href') {\n          return \"SINK-TO-LINK-HREF\";\n        }\n      } catch (e) {\n        // Have seen exceptions where base.tagName will cause Illegal invocation error\n      }\n    }\n\n    if (base === window && offset === 'location') {\n      return \"SINK-TO-WINDOW-LOCATION\";\n    }\n\n    if (base === window.location && offset === 'href') {\n      return \"SINK-TO-LOCATION-HREF\";\n    }\n\n    if (base === document && offset === 'cookie') {\n      return \"SINK-TO-DOCUMENT-COOKIE\";\n    }\n\n    if (base === document && offset === 'domain') {\n      return \"SINK-TO-DOCUMENT-DOMAIN\";\n    }\n\n    return false;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * This function will be invoked during the call operation hook\n   * \n   * @param {Function} f - The function that is being called.\n   * @param {*} base - The base object of the function call.\n   * @param {Array} args - The arguments to the function.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   */\n  checkTaintAtSinkInvokeFun(f, base, args) {\n    const hasTaintedArgs = args.some(\n      (arg) => (typeof arg === 'string' || arg instanceof URL) && arg.toString().toLowerCase().includes('hulk')\n    );\n\n    if (f.name === 'eval' && args.length && hasTaintedArgs) {\n      return \"SINK-TO-EVAL\";\n    }\n\n    if (f.name === 'Function' && args.length && hasTaintedArgs) {\n      return \"SINK-TO-FUNCTION\";\n    }\n  \n    if ((f.name === 'setTimeout' || f.name === 'setInterval') && args.length && hasTaintedArgs) {\n      return `SINK-TO-${f.name.toUpperCase()}`;\n    }\n\n    if (base === document && (f.name === 'write' || f.name === 'writeln') && args.length && hasTaintedArgs) {\n      return `SINK-TO-DOCUMENT-${f.name.toUpperCase()}`;\n    }\n\n\n    if (f.name === 'setAttribute' && base && base.tagName && base.tagName.toUpperCase() === 'SCRIPT' &&\n        args.length >= 2 && (typeof args[1] === 'string' || args[1] instanceof URL) &&\n        args[1].toString().toLowerCase().includes('hulk')\n    ) {\n      return \"SINK-TO-SETATTRIBUTE-SCRIPT-SRC\";\n    }\n\n    if (f.name === 'fetch' && args.length && hasTaintedArgs) {\n      return \"SINK-TO-FETCH\";\n    }\n\n    // Assume the base's toString shouldn't be overwritten\n    // If it is overwritten, we will get recursive function call\n    if (this.safeToString(base) === '[object XMLHttpRequest]' && f.name === 'open' &&\n        args.length && hasTaintedArgs\n    ) {\n      return \"SINK-TO-XMLHTTPREQUEST-OPEN\";\n    }\n\n    if (this.isLocationObject(base) && (f.name === 'replace' || f.name === 'assign') &&\n        args.length && hasTaintedArgs\n    ) {\n      return `SINK-TO-LOCATION-${f.name.toUpperCase()}`;\n    }\n\n    // if (base === JSON && f.name === 'parse') {\n    //   if (args.length && TaintHelper.isTainted(args[0])) {\n    //     return [\"SINK-TO-JSON-PARSE\", args[0]];\n    //   }\n    // }\n\n    if (\n      (base === window.localStorage || base === window.sessionStorage) &&\n      f.name === 'setItem' &&\n      args.length &&\n      (typeof args[1] === 'string' || args[1] instanceof URL) &&\n      args[1].toString().toLowerCase().includes('hulk')\n    ) {\n      return `SINK-TO-${base === window.localStorage ? 'LOCALSTORAGE' : 'SESSIONSTORAGE'}-SETITEM`;\n    }\n\n    return false;\n  }\n\n  isDOMElement(element) {\n    return element instanceof Element;\n  }\n\n  isLocationObject(obj) {\n    return obj === window.location || obj === location;\n  }\n\n  safeToString(value) {\n    try {\n      if (value === null || value === undefined) {\n        return value + '';\n      }\n\n      if (this.isPrimitive(value)) {\n        return value.toString();\n      } else {\n        // Hopefully this will not trigger any getter or user-defined toString\n        if (value instanceof RegExp) {\n          return value.toString();\n        }\n        return Object.prototype.toString.call(value);\n      }\n      \n    } catch (e) {\n      return '[Unable to convert to string]';\n    }\n  }\n\n  isPrimitive(value) {\n    return value !== Object(value);\n  }\n\n}\n\n//# sourceURL=webpack://thehulk-taint-analysis/./src/others/dom-clobbering-verifier.js?");

/***/ }),

/***/ "./src/utils/logger.js":
/*!*****************************!*\
  !*** ./src/utils/logger.js ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Logger: () => (/* binding */ Logger)\n/* harmony export */ });\n// JALANGI DO NOT INSTRUMENT\n/**\n * @description:\n * --------------------------------\n * This class implements a logger to replace the log4js module which\n * is not compatible with webpack bundle.\n */\nclass Logger {\n  constructor(config={level: 'info', name: 'TheHulk'}) {\n    this.name = config.name;\n    this.level = config.level;\n    this.logUnsupportBuiltin = config.logUnsupportBuiltin;\n    this.logTaintInstall = config.logTaintInstall;\n    this.logClobberableSource = config.logClobberableSource;\n    this.logClobberableSink = config.logClobberableSink;\n\n    this.exposeToPlaywright = config.exposeToPlaywright;\n\n    this.levels = ['debug', 'info', 'warn', 'error'];\n    this.levelIndex = this.levels.indexOf(this.level);\n  }\n\n  log(level, message) {\n    const levelIndex = this.levels.indexOf(level);\n    if (levelIndex >= this.levelIndex) {\n      const logMessage = `[${new Date().toISOString()}]-[${this.name}]-[${level.toUpperCase()}]-${message}`;\n      switch (level) {\n        case 'debug':\n          console.log(logMessage);\n          break;\n        case 'info':\n          console.log(`\\x1b[32m%s\\x1b[0m`, logMessage);\n          break;\n        case 'warn':\n          console.log(`\\x1b[33m%s\\x1b[0m`, logMessage);\n          break;\n        case 'error':\n          console.log(`\\x1b[31m%s\\x1b[0m`, logMessage);\n          break;\n      }\n    }\n  }\n\n  debug(...args) {\n    this.log('debug', args.map(Logger.safeToString).join(' '));\n  }\n\n  info(...args) {\n    this.log('info', args.map(Logger.safeToString).join(' '));\n  }\n\n  warn(...args) {\n    this.log('warn', args.map(Logger.safeToString).join(' '));\n  }\n\n  error(...args) {\n    this.log('error', args.map(Logger.safeToString).join(' '));\n  }\n\n  reportVulnFlow(sourceReason, sinkReason, taintedValue) {\n    console.log(\"%c[TheHulk] Found a dangerous flow from %s to %s: \\n%o\",\n                'background: #222; color: #bada55',            \n                sourceReason, sinkReason, taintedValue);\n  }\n\n  reportVerifedFlow(sinkReason, payload, url) {\n    console.log(\"%c[TheHulk] Verified a dangerous flow to %s: %o\",\n                'background: #222; color: #bada55',            \n                sinkReason, payload);\n  }\n\n  /**\n   * We assume the f has been checked to be a native function already\n   * @param {Function} f \n   * @param {*} base \n   */\n  reportUnsupportedBuiltin(f, base) {\n    if (!this.logUnsupportBuiltin) {\n      return;\n    }\n\n    let fullName = \"unknown\";\n\n    // If base is a object, e.g. \"hello\"\n    if (base && base.constructor && base.constructor.name) {\n      fullName = `${base.constructor.name}.${f.name}`;\n    }\n    // If base is a function, e.g. String()\n    if (base && typeof base === \"function\") {\n      fullName = `${base.name}.${f.name}`;\n    }\n\n    this.debug(`Unsupported builtin ${fullName}`);\n  }\n\n  reportTaintInstall(value) {\n    if (!this.logTaintInstall) {\n      return;\n    }\n\n    this.debug(\"Taint installed to:\", value);\n  }\n\n  static safeToString(value) {\n    try {\n      return value != null? value.toString() : 'null';\n    } catch (e) {\n      return '[Unable to convert to string]';\n    }\n  }\n}\n\n//# sourceURL=webpack://thehulk-taint-analysis/./src/utils/logger.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/entry.js");
/******/ 	
/******/ })()
;