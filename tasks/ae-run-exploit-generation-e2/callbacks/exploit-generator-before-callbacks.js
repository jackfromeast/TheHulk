module.exports = {
  generateExploitBeforeCallbacks
};

const fs = require('fs').promises;
const path = require('path');
const { exec } = require('child_process');

/**
 * @description
 * --------------------------------
 * The callback function will be invoked after visiting the page
 *
 * @param {Visitor} visitor 
 * @param {*} page 
 */
async function generateExploitBeforeCallbacks(visitor, page) {
  if (page.generatedExp) {
    return;
  }

  const taintflowsPath = path.resolve(
    visitor.config.others.EXPLOIT_INPUTS_FOLDER,
    visitor.domain,
    visitor.curURLHash,
    "crawler",
    'taintflows.json'
  );

  const exploitCLIPath = path.join(visitor.hulkdir, 'exploit-gen', 'src', 'exploit.js');
  const exploitPath = path.join(visitor.webpageCrawlerFolder, 'exploit.txt');

  await runExploitGen(exploitCLIPath, taintflowsPath, exploitPath, visitor.logger);

  // Copy the taintflows.json to the webpage crawler folder if it exists
  try {
    await fs.access(taintflowsPath);
    await fs.mkdir(visitor.webpageCrawlerFolder, { recursive: true });
    await fs.copyFile(taintflowsPath, path.join(visitor.webpageCrawlerFolder, 'taintflows.json'));
  } catch (err) {
    ;
  }

  page.generatedExp = true;
}

async function runExploitGen(exploitCLIPath, traceFile, exploitPath, logger) {
  if (await isFileEmpty(traceFile, logger)) {
    logger.warn(`Skipping empty taintflows.json: ${traceFile}`);
    return;
  }

  const command = `node ${exploitCLIPath} -t ${traceFile} -o ${exploitPath}`;

  try {
    await new Promise((resolve) => {
      exec(command, (error, stdout, stderr) => {
        if (error) {
          logger.error(`Error executing ${command}: ${error.message}`);
          return resolve();
        }

        resolve();
      });
    });
  } catch (unexpectedError) {
    logger.error(`Unexpected error processing ${traceFile}: ${unexpectedError.message}`);
  }
}

async function isFileEmpty(filePath, logger) {
  try {
    const content = await fs.readFile(filePath, 'utf8');
    return content.trim().length === 0 || content.trim() === '[]';
  } catch (error) {
    return true;
  }
}
