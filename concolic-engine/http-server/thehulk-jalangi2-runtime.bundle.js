/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/astUtil.js":
/*!************************!*\
  !*** ./src/astUtil.js ***!
  \************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n/*\n * Copyright 2013 Samsung Information Systems America, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *        http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Author: Koushik Sen\n// Author: Manu Sridharan\n\n/*jslint node: true */\n/*global window */\n\n// do not remove the following comment\n// JALANGI DO NOT INSTRUMENT\n\nif (typeof J$$ === 'undefined') {\n  J$$ = {};\n}\n(function (sandbox) {\n  var astUtil = sandbox.astUtil;\n  if (typeof astUtil !== 'undefined') {\n    return;\n  } else {\n    astUtil = sandbox.astUtil = {};\n  }\n  var Constants = sandbox.Constants;\n  var HOP = Constants.HOP;\n  var JALANGI_VAR = Constants.JALANGI_VAR;\n\n  /**\n   * information on surrounding AST context, to be used by visitors passed\n   * to transformAst()\n   */\n  var CONTEXT = {\n    // TODO what is this?\n    RHS: 1,\n    // TODO what is this?\n    IGNORE: 2,\n    // inside the properties of an ObjectExpression\n    OEXP: 3,\n    // inside the formal parameters of a FunctionDeclaration or FunctionExpression\n    PARAMS: 4,\n    // TODO what is this?\n    OEXP2: 5,\n    // inside a getter\n    GETTER: 6,\n    // inside a setter\n    SETTER: 7,\n    TYPEOF: 8\n  };\n\n  /**\n   * invoked by transformAst() to see if a sub-ast should be ignored.  For now,\n   * only ignoring calls to J$.I()\n   */\n  function ignoreSubAst(node) {\n    return node.type === 'CallExpression' && node.callee.type === 'MemberExpression' && node.callee.object.type === 'Identifier' && node.callee.object.name === JALANGI_VAR && node.callee.property.type === 'Identifier' && node.callee.property.name === 'I';\n  }\n\n  /**\n   * generic AST visitor that allows for AST transformation.\n   *\n   * @param object the root AST node to be visited\n   * @param visitorPost an object defining visitor methods to be executed after a node's children\n   * have been visited.  The properties of visitorPost should be named with AST node types, and the\n   * property values should be functions that take the node to be visited and a context value (see\n   * the CONTEXT object above).  E.g., a post-visitor could be:\n   * { 'AssignmentExpression': function (node, context) {\n   *      // node.type === 'AssignmentExpression'\n   *   }\n   * }\n   * The value returned by the visitorPost method for a node will replace the node in the AST.\n   * @param visitorPre an object defining visitor methods to be executed before a node's children\n   * have been visited.  Structure should be similar to visitorPost (see above).  The return value\n   * of visitorPre functions is ignored.\n   * @param context the context of the surrounding AST; see the CONTEXT object above\n   * @param {boolean?} noIgnore if true, no sub-ast will be ignored.  Otherwise, sub-ASTs will be ignored\n   * if ignoreAST() returns true.\n   */\n  function transformAst(object, visitorPost, visitorPre, context, noIgnore) {\n    var key, child, type, ret, newContext;\n    type = object.type;\n    if (visitorPre && HOP(visitorPre, type)) {\n      visitorPre[type](object, context);\n    }\n    for (key in object) {\n      //            if (object.hasOwnProperty(key)) {\n      child = object[key];\n      if (_typeof(child) === 'object' && child !== null && key !== \"scope\" && (noIgnore || !ignoreSubAst(object))) {\n        if (type === 'AssignmentExpression' && key === 'left' || type === 'UpdateExpression' && key === 'argument' || type === 'UnaryExpression' && key === 'argument' && object.operator === 'delete' || type === 'ForInStatement' && key === 'left' || (type === 'FunctionExpression' || type === 'FunctionDeclaration') && key === 'id' || type === 'LabeledStatement' && key === 'label' || type === 'BreakStatement' && key === 'label' || type === 'CatchClause' && key === 'param' || type === 'ContinueStatement' && key === 'label' || (type === 'CallExpression' || type === 'NewExpression') && key === 'callee' && (object.callee.type === 'MemberExpression' || object.callee.type === 'Identifier' && object.callee.name === 'eval') || type === 'VariableDeclarator' && key === 'id' || type === 'MemberExpression' && !object.computed && key === 'property') {\n          newContext = CONTEXT.IGNORE;\n        } else if (type === 'ObjectExpression' && key === 'properties') {\n          newContext = CONTEXT.OEXP;\n        } else if ((type === 'FunctionExpression' || type === 'FunctionDeclaration') && key === 'params') {\n          newContext = CONTEXT.PARAMS;\n        } else if (context === CONTEXT.OEXP) {\n          newContext = CONTEXT.OEXP2;\n        } else if (context === CONTEXT.OEXP2 && key === 'key') {\n          newContext = CONTEXT.IGNORE;\n        } else if (context === CONTEXT.PARAMS) {\n          newContext = CONTEXT.IGNORE;\n        } else if (object.key && key === 'value' && object.kind === 'get') {\n          newContext = CONTEXT.GETTER;\n        } else if (object.key && key === 'value' && object.kind === 'set') {\n          newContext = CONTEXT.SETTER;\n        } else if (type === 'CallExpression' && key === 'callee' && child.type === 'Identifier' && child.name === 'eval') {\n          newContext = CONTEXT.IGNORE;\n        } else if (type === 'UnaryExpression' && key === 'argument' && object.operator === 'typeof' && child.type === 'Identifier') {\n          newContext = CONTEXT.TYPEOF;\n        } else {\n          newContext = CONTEXT.RHS;\n        }\n        if (key !== 'bodyOrig') {\n          object[key] = transformAst(child, visitorPost, visitorPre, newContext, noIgnore);\n        }\n      }\n      //            }\n    }\n    if (visitorPost && HOP(visitorPost, type)) {\n      ret = visitorPost[type](object, context);\n    } else {\n      ret = object;\n    }\n    return ret;\n  }\n\n  /**\n   * computes a map from iids to the corresponding AST nodes for root.  The root AST is destructively updated to\n   * include SymbolicReference nodes that reference other nodes by iid, in order to save space in the map.\n   */\n  function serialize(root) {\n    // Stores a pointer to the most-recently encountered node representing a function or a\n    // top-level script.  We need this stored pointer since a function expression or declaration\n    // has no associated IID, but we'd like to have the ASTs as entries in the table.  Instead,\n    // we associate the AST with the IID for the corresponding function-enter or script-enter IID.\n    // We don't need a stack here since we only use this pointer at the next function-enter or script-enter,\n    // and there cannot be a nested function declaration in-between.\n    var parentFunOrScript = root;\n    var iidToAstTable = {};\n    function handleFun(node) {\n      parentFunOrScript = node;\n    }\n    var visitorPre = {\n      'Program': handleFun,\n      'FunctionDeclaration': handleFun,\n      'FunctionExpression': handleFun\n    };\n    function canMakeSymbolic(node) {\n      if (node.callee.object) {\n        var callee = node.callee;\n        // we can replace calls to J$$ functions with a SymbolicReference iff they have an IID as their first\n        // argument.  'instrumentCode', 'getConcrete', and 'I' do not take an IID.\n        // TODO are we missing other cases?\n        if (callee.object.name === 'J$$' && callee.property.name !== \"instrumentCode\" && callee.property.name !== \"getConcrete\" && callee.property.name !== \"I\" && node.arguments[0]) {\n          return true;\n        }\n      }\n      return false;\n    }\n    function setSerializedAST(iid, ast) {\n      var entry = iidToAstTable[iid];\n      if (!entry) {\n        entry = {};\n        iidToAstTable[iid] = entry;\n      }\n      entry.serializedAST = ast;\n    }\n    var visitorPost = {\n      'CallExpression': function CallExpression(node) {\n        try {\n          if (node.callee.object && node.callee.object.name === 'J$$' && (node.callee.property.name === 'Se' || node.callee.property.name === 'Fe')) {\n            // associate IID with the AST of the containing function / script\n            setSerializedAST(node.arguments[0].value, parentFunOrScript);\n            return node;\n          } else if (canMakeSymbolic(node)) {\n            setSerializedAST(node.arguments[0].value, node);\n            return {\n              type: \"SymbolicReference\",\n              value: node.arguments[0].value\n            };\n          }\n          return node;\n        } catch (e) {\n          console.log(JSON.stringify(node));\n          throw e;\n        }\n      }\n    };\n    transformAst(root, visitorPost, visitorPre);\n    return iidToAstTable;\n  }\n\n  /**\n   * given an iidToAstTable constructed by the serialize() function, destructively\n   * update the AST values to remove SymbolicReference nodes, replacing them with a\n   * pointer to the appropriate actual AST node.\n   */\n  function deserialize(iidToAstTable) {\n    Object.keys(iidToAstTable).forEach(function (iid) {\n      var curAst = iidToAstTable[iid].serializedAST;\n      if (curAst) {\n        var visitorPost = {\n          'SymbolicReference': function SymbolicReference(node) {\n            var targetAST = iidToAstTable[node.value].serializedAST;\n            if (!targetAST) {\n              throw \"bad symbolic reference\";\n            }\n            return targetAST;\n          }\n        };\n        transformAst(curAst, visitorPost);\n      }\n    });\n  }\n\n  /**\n   * given an instrumented AST, returns an array of IIDs corresponding to \"top-level expressions,\"\n   * i.e., expressions that are not nested within another\n   * @param ast\n   */\n  function computeTopLevelExpressions(ast) {\n    var exprDepth = 0;\n    var exprDepthStack = [];\n    var topLevelExprs = [];\n    var visitorIdentifyTopLevelExprPre = {\n      \"CallExpression\": function CallExpression(node) {\n        if (node.callee.type === 'MemberExpression' && node.callee.object.type === 'Identifier' && node.callee.object.name === JALANGI_VAR) {\n          var funName = node.callee.property.name;\n          if (exprDepth === 0 && (funName === 'A' || funName === 'P' || funName === 'G' || funName === 'R' || funName === 'W' || funName === 'H' || funName === 'T' || funName === 'Rt' || funName === 'B' || funName === 'U' || funName === 'C' || funName === 'C1' || funName === 'C2') || exprDepth === 1 && (funName === 'F' || funName === 'M')) {\n            topLevelExprs.push(node.arguments[0].value);\n          }\n          exprDepth++;\n        } else if (node.callee.type === 'CallExpression' && node.callee.callee.type === 'MemberExpression' && node.callee.callee.object.type === 'Identifier' && node.callee.callee.object.name === JALANGI_VAR && (node.callee.callee.property.name === 'F' || node.callee.callee.property.name === 'M')) {\n          exprDepth++;\n        }\n      },\n      \"FunctionExpression\": function FunctionExpression(node, context) {\n        exprDepthStack.push(exprDepth);\n        exprDepth = 0;\n      },\n      \"FunctionDeclaration\": function FunctionDeclaration(node) {\n        exprDepthStack.push(exprDepth);\n        exprDepth = 0;\n      }\n    };\n    var visitorIdentifyTopLevelExprPost = {\n      \"CallExpression\": function CallExpression(node) {\n        if (node.callee.type === 'MemberExpression' && node.callee.object.type === 'Identifier' && node.callee.object.name === JALANGI_VAR) {\n          exprDepth--;\n        } else if (node.callee.type === 'CallExpression' && node.callee.callee.type === 'MemberExpression' && node.callee.callee.object.type === 'Identifier' && node.callee.callee.object.name === JALANGI_VAR && (node.callee.callee.property.name === 'F' || node.callee.callee.property.name === 'M')) {\n          exprDepth--;\n        }\n        return node;\n      },\n      \"FunctionExpression\": function FunctionExpression(node, context) {\n        exprDepth = exprDepthStack.pop();\n        return node;\n      },\n      \"FunctionDeclaration\": function FunctionDeclaration(node) {\n        exprDepth = exprDepthStack.pop();\n        return node;\n      }\n    };\n    transformAst(ast, visitorIdentifyTopLevelExprPost, visitorIdentifyTopLevelExprPre, CONTEXT.RHS);\n    return topLevelExprs;\n  }\n  astUtil.serialize = serialize;\n  astUtil.deserialize = deserialize;\n  astUtil.JALANGI_VAR = JALANGI_VAR;\n  astUtil.CONTEXT = CONTEXT;\n  astUtil.transformAst = transformAst;\n  astUtil.computeTopLevelExpressions = computeTopLevelExpressions;\n})(J$$);\n\n// exports J$$.astUtil\n// depends on J$$.Constants\n\n//# sourceURL=webpack://runtime-jalangi2/./src/astUtil.js?");

/***/ }),

/***/ "./src/config.js":
/*!***********************!*\
  !*** ./src/config.js ***!
  \***********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/*\n * Copyright (c) 2014 Samsung Electronics Co., Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *        http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// do not remove the following comment\n// JALANGI DO NOT INSTRUMENT\nif (typeof J$$ === 'undefined') {\n  J$$ = {};\n}\n(function (sandbox) {\n  if (typeof sandbox.Config !== 'undefined') {\n    return;\n  }\n  var Config = sandbox.Config = {};\n  Config.DEBUG = false;\n  Config.WARN = false;\n  Config.SERIOUS_WARN = false;\n  // make MAX_BUF_SIZE slightly less than 2^16, to allow over low-level overheads\n  Config.MAX_BUF_SIZE = 64000;\n  Config.LOG_ALL_READS_AND_BRANCHES = false;\n\n  //**********************************************************\n  //  Functions for selective instrumentation of operations\n  //**********************************************************\n  // In the following functions\n  // return true in a function, if you want the ast node (passed as the second argument) to be instrumented\n  // ast node gets instrumented if you do not define the corresponding function\n  Config.ENABLE_SAMPLING = false;\n  //    Config.INSTR_INIT = function(name, ast) { return false; };\n  //    Config.INSTR_READ = function(name, ast) { return false; };\n  //    Config.INSTR_WRITE = function(name, ast) { return true; };\n  //    Config.INSTR_GETFIELD = function(offset, ast) { return true; }; // offset is null if the property is computed\n  //    Config.INSTR_PUTFIELD = function(offset, ast) { return true; }; // offset is null if the property is computed\n  //    Config.INSTR_BINARY = function(operator, ast) { return true; };\n  //    Config.INSTR_PROPERTY_BINARY_ASSIGNMENT = function(operator, offset, ast) { return true; }; // a.x += e or a[e1] += e2\n  //    Config.INSTR_UNARY = function(operator, ast) { return true; };\n  //    Config.INSTR_LITERAL = function(literal, ast) { return true;}; // literal gets some dummy value if the type is object, function, or array\n  //    Config.INSTR_CONDITIONAL = function(type, ast) { return true; }; // type could be \"&&\", \"||\", \"switch\", \"other\"\n  //    Config.INSTR_TRY_CATCH_ARGUMENTS = function(ast) {return false; }; // wrap function and script bodies with try catch block and use arguments in J$.Fe.  DO NOT USE THIS.\n  //    Config.INSTR_END_EXPRESSION = function(ast) {return true; }; // top-level expression marker\n})(J$$);\n\n//# sourceURL=webpack://runtime-jalangi2/./src/config.js?");

/***/ }),

/***/ "./src/constants.js":
/*!**************************!*\
  !*** ./src/constants.js ***!
  \**************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n/*\n * Copyright (c) 2014 Samsung Electronics Co., Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *        http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// do not remove the following comment\n// JALANGI DO NOT INSTRUMENT\nif (typeof J$$ === 'undefined') {\n  J$$ = {};\n}\n(function (sandbox) {\n  if (typeof sandbox.Constants !== 'undefined') {\n    return;\n  }\n  var Constants = sandbox.Constants = {};\n  Constants.isBrowser = !(typeof exports !== 'undefined' && this.exports !== exports);\n  var APPLY = Constants.APPLY = Function.prototype.apply;\n  var CALL = Constants.CALL = Function.prototype.call;\n  APPLY.apply = APPLY;\n  APPLY.call = CALL;\n  CALL.apply = APPLY;\n  CALL.call = CALL;\n  var HAS_OWN_PROPERTY = Constants.HAS_OWN_PROPERTY = Object.prototype.hasOwnProperty;\n  Constants.HAS_OWN_PROPERTY_CALL = Object.prototype.hasOwnProperty.call;\n  var PREFIX1 = Constants.JALANGI_VAR = \"J$$\";\n  Constants.SPECIAL_PROP = \"*\" + PREFIX1 + \"*\";\n  Constants.SPECIAL_PROP2 = \"*\" + PREFIX1 + \"I*\";\n  Constants.SPECIAL_PROP3 = \"*\" + PREFIX1 + \"C*\";\n  Constants.SPECIAL_PROP4 = \"*\" + PREFIX1 + \"W*\";\n  Constants.SPECIAL_PROP_SID = \"*\" + PREFIX1 + \"SID*\";\n  Constants.SPECIAL_PROP_IID = \"*\" + PREFIX1 + \"IID*\";\n  Constants.UNKNOWN = -1;\n\n  //-------------------------------- End constants ---------------------------------\n\n  //-------------------------------------- Constant functions -----------------------------------------------------------\n\n  var HOP = Constants.HOP = function (obj, prop) {\n    return prop + \"\" === '__proto__' || CALL.call(HAS_OWN_PROPERTY, obj, prop); //Constants.HAS_OWN_PROPERTY_CALL.apply(Constants.HAS_OWN_PROPERTY, [obj, prop]);\n  };\n  Constants.hasGetterSetter = function (obj, prop, isGetter) {\n    if (typeof Object.getOwnPropertyDescriptor !== 'function') {\n      return true;\n    }\n    while (obj !== null) {\n      if (_typeof(obj) !== 'object' && typeof obj !== 'function') {\n        return false;\n      }\n      var desc = Object.getOwnPropertyDescriptor(obj, prop);\n      if (desc !== undefined) {\n        if (isGetter && typeof desc.get === 'function') {\n          return true;\n        }\n        if (!isGetter && typeof desc.set === 'function') {\n          return true;\n        }\n      } else if (HOP(obj, prop)) {\n        return false;\n      }\n      obj = obj.__proto__;\n    }\n    return false;\n  };\n  Constants.debugPrint = function (s) {\n    if (sandbox.Config.DEBUG) {\n      console.log(\"***\" + s);\n    }\n  };\n  Constants.warnPrint = function (iid, s) {\n    if (sandbox.Config.WARN && iid !== 0) {\n      console.log(\"        at \" + iid + \" \" + s);\n    }\n  };\n  Constants.seriousWarnPrint = function (iid, s) {\n    if (sandbox.Config.SERIOUS_WARN && iid !== 0) {\n      console.log(\"        at \" + iid + \" Serious \" + s);\n    }\n  };\n})(J$$);\n\n//# sourceURL=webpack://runtime-jalangi2/./src/constants.js?");

/***/ }),

/***/ "./src/entry.js":
/*!**********************!*\
  !*** ./src/entry.js ***!
  \**********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config.js */ \"./src/config.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants.js */ \"./src/constants.js\");\n/* harmony import */ var _astUtil_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./astUtil.js */ \"./src/astUtil.js\");\n/* harmony import */ var _runtime_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./runtime.js */ \"./src/runtime.js\");\n/* harmony import */ var _iidToLocation_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./iidToLocation.js */ \"./src/iidToLocation.js\");\n/* harmony import */ var _esnstrument_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./esnstrument.js */ \"./src/esnstrument.js\");\n\n\n\n\n\n\n\n//# sourceURL=webpack://runtime-jalangi2/./src/entry.js?");

/***/ }),

/***/ "./src/esnstrument.js":
/*!****************************!*\
  !*** ./src/esnstrument.js ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n/*\n * Copyright 2013 Samsung Information Systems America, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *        http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Author: Koushik Sen\n\n// do not remove the following comment\n// JALANGI DO NOT INSTRUMENT\n\n/*jslint node: true browser: true */\n/*global astUtil acorn esotope J$$ */\n\nif (typeof J$$ === 'undefined') {\n  J$$ = {};\n}\nvar acorn = require('acorn');\nvar esotope = require('esotope');\nvar babel = require('@babel/core');\n(function (sandbox) {\n  if (typeof sandbox.instrumentCode !== 'undefined') {\n    return;\n  }\n  function es6Transform(code) {\n    if (typeof babel !== 'undefined' && !process.env['NO_ES7']) {\n      var res = babel.transform(code, {\n        retainLines: true,\n        sourceType: 'script',\n        presets: ['../node_modules/@babel/preset-env']\n      }).code;\n      if (res && res.indexOf('use strict') != -1) {\n        res = res.replace(/.use strict.;\\n?/, '');\n      }\n      return res;\n    } else {\n      console.log('There is no babel loaded');\n      return code;\n    }\n  }\n  var global = this;\n  var JSON = {\n    parse: global.JSON.parse,\n    stringify: global.JSON.stringify\n  };\n  var astUtil = sandbox.astUtil;\n  var Config = sandbox.Config;\n  var Constants = sandbox.Constants;\n  var JALANGI_VAR = Constants.JALANGI_VAR;\n  var RP = JALANGI_VAR + \"_\";\n\n  //    var N_LOG_LOAD = 0,\n  //    var N_LOG_FUN_CALL = 1,\n  //    N_LOG_METHOD_CALL = 2,\n  var N_LOG_FUNCTION_ENTER = 4,\n    //    N_LOG_FUNCTION_RETURN = 5,\n    N_LOG_SCRIPT_ENTER = 6,\n    //    N_LOG_SCRIPT_EXIT = 7,\n    N_LOG_GETFIELD = 8,\n    //    N_LOG_GLOBAL = 9,\n    N_LOG_ARRAY_LIT = 10,\n    N_LOG_OBJECT_LIT = 11,\n    N_LOG_FUNCTION_LIT = 12,\n    N_LOG_RETURN = 13,\n    N_LOG_REGEXP_LIT = 14,\n    //    N_LOG_LOCAL = 15,\n    //    N_LOG_OBJECT_NEW = 16,\n    N_LOG_READ = 17,\n    //    N_LOG_FUNCTION_ENTER_NORMAL = 18,\n    N_LOG_HASH = 19,\n    N_LOG_SPECIAL = 20,\n    N_LOG_STRING_LIT = 21,\n    N_LOG_NUMBER_LIT = 22,\n    N_LOG_BOOLEAN_LIT = 23,\n    N_LOG_UNDEFINED_LIT = 24,\n    N_LOG_NULL_LIT = 25;\n  var logFunctionEnterFunName = JALANGI_VAR + \".Fe\";\n  var logFunctionReturnFunName = JALANGI_VAR + \".Fr\";\n  var logFunCallFunName = JALANGI_VAR + \".F\";\n  var logMethodCallFunName = JALANGI_VAR + \".M\";\n  var logAssignFunName = JALANGI_VAR + \".A\";\n  var logPutFieldFunName = JALANGI_VAR + \".P\";\n  var logGetFieldFunName = JALANGI_VAR + \".G\";\n  var logScriptEntryFunName = JALANGI_VAR + \".Se\";\n  var logScriptExitFunName = JALANGI_VAR + \".Sr\";\n  var logReadFunName = JALANGI_VAR + \".R\";\n  var logWriteFunName = JALANGI_VAR + \".W\";\n  var logIFunName = JALANGI_VAR + \".I\";\n  var logHashFunName = JALANGI_VAR + \".H\";\n  var logLitFunName = JALANGI_VAR + \".T\";\n  var logInitFunName = JALANGI_VAR + \".N\";\n  var logReturnFunName = JALANGI_VAR + \".Rt\";\n  var logThrowFunName = JALANGI_VAR + \".Th\";\n  var logReturnAggrFunName = JALANGI_VAR + \".Ra\";\n  var logUncaughtExceptionFunName = JALANGI_VAR + \".Ex\";\n  var logLastComputedFunName = JALANGI_VAR + \".L\";\n  var logTmpVarName = JALANGI_VAR + \"._tm_p\";\n  var logSampleFunName = JALANGI_VAR + \".S\";\n  var logWithFunName = JALANGI_VAR + \".Wi\";\n  var logBinaryOpFunName = JALANGI_VAR + \".B\";\n  var logUnaryOpFunName = JALANGI_VAR + \".U\";\n  var logConditionalFunName = JALANGI_VAR + \".C\";\n  var logSwitchLeftFunName = JALANGI_VAR + \".C1\";\n  var logSwitchRightFunName = JALANGI_VAR + \".C2\";\n  var logLastFunName = JALANGI_VAR + \"._\";\n  var logX1FunName = JALANGI_VAR + \".X1\";\n  var instrumentCodeFunName = JALANGI_VAR + \".instrumentEvalCode\";\n  var Syntax = {\n    AssignmentExpression: 'AssignmentExpression',\n    ArrayExpression: 'ArrayExpression',\n    BlockStatement: 'BlockStatement',\n    BinaryExpression: 'BinaryExpression',\n    BreakStatement: 'BreakStatement',\n    CallExpression: 'CallExpression',\n    CatchClause: 'CatchClause',\n    ConditionalExpression: 'ConditionalExpression',\n    ContinueStatement: 'ContinueStatement',\n    DoWhileStatement: 'DoWhileStatement',\n    DebuggerStatement: 'DebuggerStatement',\n    EmptyStatement: 'EmptyStatement',\n    ExpressionStatement: 'ExpressionStatement',\n    ForStatement: 'ForStatement',\n    ForInStatement: 'ForInStatement',\n    FunctionDeclaration: 'FunctionDeclaration',\n    FunctionExpression: 'FunctionExpression',\n    Identifier: 'Identifier',\n    IfStatement: 'IfStatement',\n    Literal: 'Literal',\n    LabeledStatement: 'LabeledStatement',\n    LogicalExpression: 'LogicalExpression',\n    MemberExpression: 'MemberExpression',\n    NewExpression: 'NewExpression',\n    ObjectExpression: 'ObjectExpression',\n    Program: 'Program',\n    Property: 'Property',\n    ReturnStatement: 'ReturnStatement',\n    SequenceExpression: 'SequenceExpression',\n    SwitchStatement: 'SwitchStatement',\n    SwitchCase: 'SwitchCase',\n    ThisExpression: 'ThisExpression',\n    ThrowStatement: 'ThrowStatement',\n    TryStatement: 'TryStatement',\n    UnaryExpression: 'UnaryExpression',\n    UpdateExpression: 'UpdateExpression',\n    VariableDeclaration: 'VariableDeclaration',\n    VariableDeclarator: 'VariableDeclarator',\n    WhileStatement: 'WhileStatement',\n    WithStatement: 'WithStatement'\n  };\n  function createBitPattern() {\n    var ret = 0;\n    var i;\n    for (i = 0; i < arguments.length; i++) {\n      ret = (ret << 1) + (arguments[i] ? 1 : 0);\n    }\n    return ret;\n  }\n  function HOP(obj, prop) {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n  }\n  function isArr(val) {\n    return Object.prototype.toString.call(val) === '[object Array]';\n  }\n  function MAP(arr, fun) {\n    var len = arr.length;\n    if (!isArr(arr)) {\n      throw new TypeError();\n    }\n    if (typeof fun !== \"function\") {\n      throw new TypeError();\n    }\n    var res = new Array(len);\n    for (var i = 0; i < len; i++) {\n      if (i in arr) {\n        res[i] = fun(arr[i]);\n      }\n    }\n    return res;\n  }\n  function regex_escape(text) {\n    return text.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\n  }\n\n  // name of the file containing the instrumented code\n\n  var IID_INC_STEP = 8;\n  // current static identifier for each conditional expression\n  var condIid;\n  var memIid;\n  var opIid;\n  var hasInitializedIIDs = false;\n  var origCodeFileName;\n  var instCodeFileName;\n  var iidSourceInfo;\n  function getIid() {\n    var tmpIid = memIid;\n    memIid = memIid + IID_INC_STEP;\n    return createLiteralAst(tmpIid);\n  }\n  function getPrevIidNoInc() {\n    return createLiteralAst(memIid - IID_INC_STEP);\n  }\n  function getCondIid() {\n    var tmpIid = condIid;\n    condIid = condIid + IID_INC_STEP;\n    return createLiteralAst(tmpIid);\n  }\n  function getOpIid() {\n    var tmpIid = opIid;\n    opIid = opIid + IID_INC_STEP;\n    return createLiteralAst(tmpIid);\n  }\n  function printLineInfoAux(i, ast) {\n    if (ast && ast.loc) {\n      iidSourceInfo[i] = [ast.loc.start.line, ast.loc.start.column + 1, ast.loc.end.line, ast.loc.end.column + 1];\n    }\n  }\n\n  // iid+2 is usually unallocated\n  // we are using iid+2 for the sub-getField operation of a method call\n  // see analysis.M\n  function printSpecialIidToLoc(ast0) {\n    printLineInfoAux(memIid + 2, ast0);\n  }\n  function printIidToLoc(ast0) {\n    printLineInfoAux(memIid, ast0);\n  }\n  function printModIidToLoc(ast0) {\n    printLineInfoAux(memIid, ast0);\n    printLineInfoAux(memIid + 2, ast0);\n  }\n  function printOpIidToLoc(ast0) {\n    printLineInfoAux(opIid, ast0);\n  }\n  function printCondIidToLoc(ast0) {\n    printLineInfoAux(condIid, ast0);\n  }\n\n  // J$_i in expression context will replace it by an AST\n  // {J$_i} will replace the body of the block statement with an array of statements passed as argument\n\n  function replaceInStatement(code) {\n    var asts = arguments;\n    var visitorReplaceInExpr = {\n      'Identifier': function Identifier(node) {\n        if (node.name.indexOf(RP) === 0) {\n          var i = parseInt(node.name.substring(RP.length));\n          return asts[i];\n        } else {\n          return node;\n        }\n      },\n      'BlockStatement': function BlockStatement(node) {\n        if (node.body[0].type === 'ExpressionStatement' && isArr(node.body[0].expression)) {\n          node.body = node.body[0].expression;\n        }\n        return node;\n      }\n    };\n    //        StatCollector.resumeTimer(\"internalParse\");\n    var ast = acorn.parse(code);\n    //        StatCollector.suspendTimer(\"internalParse\");\n    //        StatCollector.resumeTimer(\"replace\");\n    var newAst = astUtil.transformAst(ast, visitorReplaceInExpr, undefined, undefined, true);\n    //console.log(newAst);\n    //        StatCollector.suspendTimer(\"replace\");\n    return newAst.body;\n  }\n  function replaceInExpr(code) {\n    var ret = replaceInStatement.apply(this, arguments);\n    return ret[0].expression;\n  }\n  function createLiteralAst(name) {\n    return {\n      type: Syntax.Literal,\n      value: name\n    };\n  }\n  function createIdentifierAst(name) {\n    return {\n      type: Syntax.Identifier,\n      name: name\n    };\n  }\n  function transferLoc(toNode, fromNode) {\n    if (fromNode.loc) toNode.loc = fromNode.loc;\n    if (fromNode.raw) toNode.raw = fromNode.loc;\n  }\n  function idsOfGetterSetter(node) {\n    var ret = {},\n      isEmpty = true;\n    if (node.type === \"ObjectExpression\") {\n      var kind,\n        len = node.properties.length;\n      for (var i = 0; i < len; i++) {\n        if ((kind = node.properties[i].kind) === 'get' || kind === 'set') {\n          ret[kind + node.properties[i].key.name] = node.properties[i].value.funId;\n          isEmpty = false;\n        }\n      }\n    }\n    return isEmpty ? undefined : ret;\n  }\n  function checkAndGetIid(funId, sid, funName) {\n    var id = getIid();\n    if (!Config.requiresInstrumentation || Config.requiresInstrumentation(id, funId, sid, funName)) {\n      return id;\n    } else {\n      return undefined;\n    }\n  }\n  function modifyAst(ast, modifier, term) {\n    var ret;\n    var i = 3; // no. of formal parameters\n    while (term.indexOf('$$') >= 0) {\n      term = term.replace(/\\$\\$/, arguments[i]);\n      i++;\n    }\n    var args = [];\n    args.push(term);\n    for (; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    printIidToLoc(ast);\n    ret = modifier.apply(this, args);\n    transferLoc(ret, ast);\n    return ret;\n  }\n  function wrapPutField(node, base, offset, rvalue, isComputed) {\n    if (!Config.INSTR_PUTFIELD || Config.INSTR_PUTFIELD(isComputed ? null : offset.value, node)) {\n      printIidToLoc(node);\n      var ret = replaceInExpr(logPutFieldFunName + \"(\" + RP + \"1, \" + RP + \"2, \" + RP + \"3, \" + RP + \"4,\" + createBitPattern(isComputed, false) + \")\", getIid(), base, offset, rvalue);\n      transferLoc(ret, node);\n      return ret;\n    } else {\n      return node;\n    }\n  }\n  function wrapModAssign(node, base, offset, op, rvalue, isComputed) {\n    if (!Config.INSTR_PROPERTY_BINARY_ASSIGNMENT || Config.INSTR_PROPERTY_BINARY_ASSIGNMENT(op, node.computed ? null : offset.value, node)) {\n      printModIidToLoc(node);\n      var ret = replaceInExpr(logAssignFunName + \"(\" + RP + \"1,\" + RP + \"2,\" + RP + \"3,\" + RP + \"4,\" + createBitPattern(isComputed) + \")(\" + RP + \"5)\", getIid(), base, offset, createLiteralAst(op), rvalue);\n      transferLoc(ret, node);\n      return ret;\n    } else {\n      return node;\n    }\n  }\n  function wrapMethodCall(node, base, offset, isCtor, isComputed) {\n    printIidToLoc(node);\n    printSpecialIidToLoc(node.callee);\n    var ret = replaceInExpr(logMethodCallFunName + \"(\" + RP + \"1, \" + RP + \"2, \" + RP + \"3, \" + createBitPattern(isCtor, isComputed) + \")\", getIid(), base, offset);\n    transferLoc(ret, node.callee);\n    return ret;\n  }\n  function wrapFunCall(node, ast, isCtor) {\n    printIidToLoc(node);\n    var ret = replaceInExpr(logFunCallFunName + \"(\" + RP + \"1, \" + RP + \"2, \" + createBitPattern(isCtor) + \")\", getIid(), ast);\n    transferLoc(ret, node.callee);\n    return ret;\n  }\n  function wrapGetField(node, base, offset, isComputed) {\n    if (!Config.INSTR_GETFIELD || Config.INSTR_GETFIELD(node.computed ? null : offset.value, node)) {\n      printIidToLoc(node);\n      var ret = replaceInExpr(logGetFieldFunName + \"(\" + RP + \"1, \" + RP + \"2, \" + RP + \"3,\" + createBitPattern(isComputed, false, false) + \")\", getIid(), base, offset);\n      transferLoc(ret, node);\n      return ret;\n    } else {\n      return node;\n    }\n  }\n  function wrapRead(node, name, val, isReUseIid, isGlobal, isScriptLocal) {\n    if (!Config.INSTR_READ || Config.INSTR_READ(name, node)) {\n      printIidToLoc(node);\n      var ret = replaceInExpr(logReadFunName + \"(\" + RP + \"1, \" + RP + \"2, \" + RP + \"3,\" + createBitPattern(isGlobal, isScriptLocal) + \")\", isReUseIid ? getPrevIidNoInc() : getIid(), name, val);\n      transferLoc(ret, node);\n      return ret;\n    } else {\n      return val;\n    }\n  }\n\n  //    function wrapReadWithUndefinedCheck(node, name) {\n  //        var ret = replaceInExpr(\n  //            \"(\"+logIFunName+\"(typeof (\"+name+\") === 'undefined'? \"+RP+\"2 : \"+RP+\"3))\",\n  //            createIdentifierAst(name),\n  //            wrapRead(node, createLiteralAst(name),createIdentifierAst(\"undefined\")),\n  //            wrapRead(node, createLiteralAst(name),createIdentifierAst(name), true)\n  //        );\n  //        transferLoc(ret, node);\n  //        return ret;\n  //    }\n\n  function wrapReadWithUndefinedCheck(node, name) {\n    var ret;\n\n    //if (name !== 'location') {\n    //    ret = replaceInExpr(\n    //        \"(\" + logIFunName + \"(typeof (\" + name + \") === 'undefined'? (\" + name + \"=\" + RP + \"2) : (\" + name + \"=\" + RP + \"3)))\",\n    //        createIdentifierAst(name),\n    //        wrapRead(node, createLiteralAst(name), createIdentifierAst(\"undefined\"), false, true, true),\n    //        wrapRead(node, createLiteralAst(name), createIdentifierAst(name), true, true, true)\n    //    );\n    //} else {\n    ret = replaceInExpr(\"(\" + logIFunName + \"(typeof (\" + name + \") === 'undefined'? (\" + RP + \"2) : (\" + RP + \"3)))\", createIdentifierAst(name), wrapRead(node, createLiteralAst(name), createIdentifierAst(\"undefined\"), false, true, false), wrapRead(node, createLiteralAst(name), createIdentifierAst(name), true, true, false));\n    //        }\n    transferLoc(ret, node);\n    return ret;\n  }\n  function wrapWrite(node, name, val, lhs, isGlobal, isScriptLocal, isDeclaration) {\n    if (!Config.INSTR_WRITE || Config.INSTR_WRITE(name, node)) {\n      printIidToLoc(node);\n      var ret = replaceInExpr(logWriteFunName + \"(\" + RP + \"1, \" + RP + \"2, \" + RP + \"3, \" + RP + \"4,\" + createBitPattern(isGlobal, isScriptLocal, isDeclaration) + \")\", getIid(), name, val, lhs);\n      transferLoc(ret, node);\n      return ret;\n    } else {\n      return val;\n    }\n  }\n  function wrapWriteWithUndefinedCheck(node, name, val, lhs) {\n    if (!Config.INSTR_WRITE || Config.INSTR_WRITE(name, node)) {\n      printIidToLoc(node);\n      //        var ret2 = replaceInExpr(\n      //            \"(\"+logIFunName+\"(typeof (\"+name+\") === 'undefined'? \"+RP+\"2 : \"+RP+\"3))\",\n      //            createIdentifierAst(name),\n      //            wrapRead(node, createLiteralAst(name),createIdentifierAst(\"undefined\")),\n      //            wrapRead(node, createLiteralAst(name),createIdentifierAst(name), true)\n      //        );\n      var ret = replaceInExpr(logWriteFunName + \"(\" + RP + \"1, \" + RP + \"2, \" + RP + \"3, \" + logIFunName + \"(typeof(\" + lhs.name + \")==='undefined'?undefined:\" + lhs.name + \"),\" + createBitPattern(true, false, false) + \")\", getIid(), name, val);\n      transferLoc(ret, node);\n      return ret;\n    } else {\n      return val;\n    }\n  }\n  function wrapRHSOfModStore(node, left, right, op) {\n    var ret = replaceInExpr(RP + \"1 \" + op + \" \" + RP + \"2\", left, right);\n    transferLoc(ret, node);\n    return ret;\n  }\n  function makeNumber(node, left) {\n    var ret = replaceInExpr(\" + \" + RP + \"1 \", left);\n    transferLoc(ret, node);\n    return ret;\n  }\n  function wrapLHSOfModStore(node, left, right) {\n    var ret = replaceInExpr(RP + \"1 = \" + RP + \"2\", left, right);\n    transferLoc(ret, node);\n    return ret;\n  }\n  function ifObjectExpressionHasGetterSetter(node) {\n    if (node.type === \"ObjectExpression\") {\n      var kind,\n        len = node.properties.length;\n      for (var i = 0; i < len; i++) {\n        if ((kind = node.properties[i].kind) === 'get' || kind === 'set') {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  var dummyFun = function dummyFun() {};\n  var dummyObject = {};\n  var dummyArray = [];\n  function getLiteralValue(funId, node) {\n    if (node.name === \"undefined\") {\n      return undefined;\n    } else if (node.name === \"NaN\") {\n      return NaN;\n    } else if (node.name === \"Infinity\") {\n      return Infinity;\n    }\n    switch (funId) {\n      case N_LOG_NUMBER_LIT:\n      case N_LOG_STRING_LIT:\n      case N_LOG_NULL_LIT:\n      case N_LOG_REGEXP_LIT:\n      case N_LOG_BOOLEAN_LIT:\n        return node.value;\n      case N_LOG_ARRAY_LIT:\n        return dummyArray;\n      case N_LOG_FUNCTION_LIT:\n        return dummyFun;\n      case N_LOG_OBJECT_LIT:\n        return dummyObject;\n    }\n    throw new Error(funId + \" not known\");\n  }\n  function getFnIdFromAst(ast) {\n    var entryExpr = ast.body.body[0];\n    if (entryExpr.type != 'ExpressionStatement') {\n      console.log(JSON.stringify(entryExpr));\n      throw new Error(\"IllegalStateException\");\n    }\n    entryExpr = entryExpr.expression;\n    if (entryExpr.type != 'CallExpression') {\n      throw new Error(\"IllegalStateException\");\n    }\n    if (entryExpr.callee.type != 'MemberExpression') {\n      throw new Error(\"IllegalStateException\");\n    }\n    if (entryExpr.callee.object.name != JALANGI_VAR) {\n      throw new Error(\"IllegalStateException\");\n    }\n    if (entryExpr.callee.property.name != 'Fe') {\n      throw new Error(\"IllegalStateException\");\n    }\n    return entryExpr['arguments'][0].value;\n  }\n  function wrapLiteral(node, ast, funId) {\n    if (!Config.INSTR_LITERAL || Config.INSTR_LITERAL(getLiteralValue(funId, node), node)) {\n      printIidToLoc(node);\n      var hasGetterSetter = ifObjectExpressionHasGetterSetter(node);\n      var ret;\n      if (funId == N_LOG_FUNCTION_LIT) {\n        var internalFunId = null;\n        if (node.type == 'FunctionExpression') {\n          internalFunId = getFnIdFromAst(node);\n        } else {\n          if (node.type != 'Identifier') {\n            throw new Error(\"IllegalStateException\");\n          }\n          internalFunId = getFnIdFromAst(scope.funNodes[node.name]);\n        }\n        ret = replaceInExpr(logLitFunName + \"(\" + RP + \"1, \" + RP + \"2, \" + RP + \"3,\" + hasGetterSetter + \", \" + internalFunId + \")\", getIid(), ast, createLiteralAst(funId), internalFunId);\n      } else {\n        ret = replaceInExpr(logLitFunName + \"(\" + RP + \"1, \" + RP + \"2, \" + RP + \"3,\" + hasGetterSetter + \")\", getIid(), ast, createLiteralAst(funId));\n      }\n      transferLoc(ret, node);\n      return ret;\n    } else {\n      return node;\n    }\n  }\n  function wrapReturn(node, expr) {\n    var lid = expr === null ? node : expr;\n    printIidToLoc(lid);\n    if (expr === null) {\n      expr = createIdentifierAst(\"undefined\");\n    }\n    var ret = replaceInExpr(logReturnFunName + \"(\" + RP + \"1, \" + RP + \"2)\", getIid(), expr);\n    transferLoc(ret, lid);\n    return ret;\n  }\n  function wrapThrow(node, expr) {\n    printIidToLoc(expr);\n    var ret = replaceInExpr(logThrowFunName + \"(\" + RP + \"1, \" + RP + \"2)\", getIid(), expr);\n    transferLoc(ret, expr);\n    return ret;\n  }\n  function wrapWithX1(node, ast) {\n    if (!Config.INSTR_END_EXPRESSION || Config.INSTR_END_EXPRESSION(node)) {\n      if (!ast || ast.type.indexOf(\"Expression\") <= 0) return ast;\n      printIidToLoc(node);\n      var ret = replaceInExpr(logX1FunName + \"(\" + RP + \"1,\" + RP + \"2)\", getIid(), ast);\n      transferLoc(ret, node);\n      return ret;\n    } else {\n      return ast;\n    }\n  }\n  function wrapHash(node, ast) {\n    printIidToLoc(node);\n    var ret = replaceInExpr(logHashFunName + \"(\" + RP + \"1, \" + RP + \"2)\", getIid(), ast);\n    transferLoc(ret, node);\n    return ret;\n  }\n  function wrapEvalArg(ast) {\n    printIidToLoc(ast);\n    var ret = replaceInExpr(instrumentCodeFunName + \"(\" + RP + \"1, \" + RP + \"2, true)\", ast, getIid());\n    transferLoc(ret, ast);\n    return ret;\n  }\n  function wrapUnaryOp(node, argument, operator) {\n    if (!Config.INSTR_UNARY || Config.INSTR_UNARY(operator, node)) {\n      printOpIidToLoc(node);\n      var ret = replaceInExpr(logUnaryOpFunName + \"(\" + RP + \"1,\" + RP + \"2,\" + RP + \"3)\", getOpIid(), createLiteralAst(operator), argument);\n      transferLoc(ret, node);\n      return ret;\n    } else {\n      return node;\n    }\n  }\n  function wrapBinaryOp(node, left, right, operator, isComputed) {\n    if (!Config.INSTR_BINARY || Config.INSTR_BINARY(operator, operator)) {\n      printOpIidToLoc(node);\n      var ret = replaceInExpr(logBinaryOpFunName + \"(\" + RP + \"1, \" + RP + \"2, \" + RP + \"3, \" + RP + \"4,\" + createBitPattern(isComputed, false, false) + \")\", getOpIid(), createLiteralAst(operator), left, right);\n      transferLoc(ret, node);\n      return ret;\n    } else {\n      return node;\n    }\n  }\n  function wrapLogicalAnd(node, left, right) {\n    if (!Config.INSTR_CONDITIONAL || Config.INSTR_CONDITIONAL(\"&&\", node)) {\n      printCondIidToLoc(node);\n      var ret = replaceInExpr(logConditionalFunName + \"(\" + RP + \"1, \" + RP + \"2)?\" + RP + \"3:\" + logLastFunName + \"()\", getCondIid(), left, right);\n      transferLoc(ret, node);\n      return ret;\n    } else {\n      return node;\n    }\n  }\n  function wrapLogicalOr(node, left, right) {\n    if (!Config.INSTR_CONDITIONAL || Config.INSTR_CONDITIONAL(\"||\", node)) {\n      printCondIidToLoc(node);\n      var ret = replaceInExpr(logConditionalFunName + \"(\" + RP + \"1, \" + RP + \"2)?\" + logLastFunName + \"():\" + RP + \"3\", getCondIid(), left, right);\n      transferLoc(ret, node);\n      return ret;\n    } else {\n      return node;\n    }\n  }\n  function wrapSwitchDiscriminant(node, discriminant) {\n    if (!Config.INSTR_CONDITIONAL || Config.INSTR_CONDITIONAL(\"switch\", node)) {\n      printCondIidToLoc(node);\n      var ret = replaceInExpr(logSwitchLeftFunName + \"(\" + RP + \"1, \" + RP + \"2)\", getCondIid(), discriminant);\n      transferLoc(ret, node);\n      return ret;\n    } else {\n      return node;\n    }\n  }\n  function wrapSwitchTest(node, test) {\n    if (!Config.INSTR_CONDITIONAL || Config.INSTR_CONDITIONAL(\"switch\", node)) {\n      printCondIidToLoc(node);\n      var ret = replaceInExpr(logSwitchRightFunName + \"(\" + RP + \"1, \" + RP + \"2)\", getCondIid(), test);\n      transferLoc(ret, node);\n      return ret;\n    } else {\n      return node;\n    }\n  }\n  function wrapWith(node) {\n    if (!Config.INSTR_CONDITIONAL || Config.INSTR_CONDITIONAL(\"with\", node)) {\n      printIidToLoc(node);\n      var ret = replaceInExpr(logWithFunName + \"(\" + RP + \"1, \" + RP + \"2)\", getIid(), node);\n      transferLoc(ret, node);\n      return ret;\n    } else {\n      return node;\n    }\n  }\n  function wrapConditional(node, test) {\n    if (node === null) {\n      return node;\n    } // to handle for(;;) ;\n\n    if (!Config.INSTR_CONDITIONAL || Config.INSTR_CONDITIONAL(\"other\", node)) {\n      printCondIidToLoc(node);\n      var ret = replaceInExpr(logConditionalFunName + \"(\" + RP + \"1, \" + RP + \"2)\", getCondIid(), test);\n      transferLoc(ret, node);\n      return ret;\n    } else {\n      return node;\n    }\n  }\n\n  //    function createCallWriteAsStatement(node, name, val) {\n  //        printIidToLoc(node);\n  //        var ret = replaceInStatement(\n  //            logWriteFunName + \"(\" + RP + \"1, \" + RP + \"2, \" + RP + \"3)\",\n  //            getIid(),\n  //            name,\n  //            val\n  //        );\n  //        transferLoc(ret[0].expression, node);\n  //        return ret;\n  //    }\n\n  function createExpressionStatement(lhs, node) {\n    var ret;\n    ret = replaceInStatement(RP + \"1 = \" + RP + \"2\", lhs, node);\n    transferLoc(ret[0].expression, node);\n    return ret;\n  }\n  function createCallInitAsStatement(node, name, val, isArgumentSync, lhs, isCatchParam, isAssign) {\n    printIidToLoc(node);\n    var ret;\n    if (isAssign) ret = replaceInStatement(RP + \"1 = \" + logInitFunName + \"(\" + RP + \"2, \" + RP + \"3, \" + RP + \"4, \" + createBitPattern(isArgumentSync, false, isCatchParam) + \")\", lhs, getIid(), name, val);else ret = replaceInStatement(logInitFunName + \"(\" + RP + \"1, \" + RP + \"2, \" + RP + \"3, \" + createBitPattern(isArgumentSync, false, isCatchParam) + \")\", getIid(), name, val);\n    transferLoc(ret[0].expression, node);\n    return ret;\n  }\n  function createCallAsFunEnterStatement(node) {\n    printIidToLoc(node);\n    var ret = replaceInStatement(logFunctionEnterFunName + \"(\" + RP + \"1,arguments.callee, this, arguments)\", getIid());\n    transferLoc(ret[0].expression, node);\n    return ret;\n  }\n  function createCallAsScriptEnterStatement(node) {\n    printIidToLoc(node);\n    var ret = replaceInStatement(logScriptEntryFunName + \"(\" + RP + \"1,\" + RP + \"2, \" + RP + \"3)\", getIid(), createLiteralAst(instCodeFileName), createLiteralAst(origCodeFileName));\n    transferLoc(ret[0].expression, node);\n    return ret;\n  }\n  var labelCounter = 0;\n  function wrapForIn(node, left, right, body) {\n    printIidToLoc(node);\n    var tmp,\n      extra,\n      isDeclaration = left.type === 'VariableDeclaration';\n    if (isDeclaration) {\n      var name = node.left.declarations[0].id.name;\n      tmp = replaceInExpr(name + \" = \" + logTmpVarName);\n    } else {\n      tmp = replaceInExpr(RP + \"1 = \" + logTmpVarName, left);\n    }\n    transferLoc(tmp, node);\n    extra = instrumentStore(tmp, isDeclaration);\n    var ret;\n    if (body.type === 'BlockExpression') {\n      body = body.body;\n    } else {\n      body = [body];\n    }\n    if (isDeclaration) {\n      ret = replaceInStatement(\"function n() {  for(\" + logTmpVarName + \" in \" + RP + \"1) {var \" + name + \" = \" + RP + \"2;\\n {\" + RP + \"3}}}\", right, wrapWithX1(node, extra.right), body);\n    } else {\n      ret = replaceInStatement(\"function n() {  for(\" + logTmpVarName + \" in \" + RP + \"1) {\" + RP + \"2;\\n {\" + RP + \"3}}}\", right, wrapWithX1(node, extra), body);\n    }\n    ret = ret[0].body.body[0];\n    transferLoc(ret, node);\n    return ret;\n  }\n  function wrapForInBody(node, body, name) {\n    printIidToLoc(node);\n    var ret = replaceInStatement(\"function n() { \" + logInitFunName + \"(\" + RP + \"1, '\" + name + \"',\" + name + \",\" + createBitPattern(false, true, false) + \");\\n {\" + RP + \"2}}\", getIid(), [body]);\n    ret = ret[0].body;\n    transferLoc(ret, node);\n    return ret;\n  }\n  function wrapCatchClause(node, body, name) {\n    var ret;\n    if (!Config.INSTR_INIT || Config.INSTR_INIT(node)) {\n      body.unshift(createCallInitAsStatement(node, createLiteralAst(name), createIdentifierAst(name), false, createIdentifierAst(name), true, true)[0]);\n    }\n  }\n  function wrapScriptBodyWithTryCatch(node, body) {\n    if (!Config.INSTR_TRY_CATCH_ARGUMENTS || Config.INSTR_TRY_CATCH_ARGUMENTS(node)) {\n      printIidToLoc(node);\n      var iid1 = getIid();\n      printIidToLoc(node);\n      var l = labelCounter++;\n      var ret = replaceInStatement(\"function n() { jalangiLabel\" + l + \": while(true) { try {\" + RP + \"1} catch(\" + JALANGI_VAR + \"e) { //console.log(\" + JALANGI_VAR + \"e); console.log(\" + JALANGI_VAR + \"e.stack);\\n  \" + logUncaughtExceptionFunName + \"(\" + RP + \"2,\" + JALANGI_VAR + \"e); } finally { if (\" + logScriptExitFunName + \"(\" + RP + \"3)) { \" + logLastComputedFunName + \"(); continue jalangiLabel\" + l + \";\\n } else {\\n  \" + logLastComputedFunName + \"(); break jalangiLabel\" + l + \";\\n }}\\n }}\", body, iid1, getIid());\n      //console.log(JSON.stringify(ret));\n\n      ret = ret[0].body.body;\n      transferLoc(ret[0], node);\n      return ret;\n    } else {\n      return body;\n    }\n  }\n  function wrapFunBodyWithTryCatch(node, body) {\n    if (!Config.INSTR_TRY_CATCH_ARGUMENTS || Config.INSTR_TRY_CATCH_ARGUMENTS(node)) {\n      printIidToLoc(node);\n      var iid1 = getIid();\n      printIidToLoc(node);\n      var l = labelCounter++;\n      var ret = replaceInStatement(\"function n() { jalangiLabel\" + l + \": while(true) { try {\" + RP + \"1} catch(\" + JALANGI_VAR + \"e) { //console.log(\" + JALANGI_VAR + \"e); console.log(\" + JALANGI_VAR + \"e.stack);\\n \" + logUncaughtExceptionFunName + \"(\" + RP + \"2,\" + JALANGI_VAR + \"e); } finally { if (\" + logFunctionReturnFunName + \"(\" + RP + \"3)) continue jalangiLabel\" + l + \";\\n else \\n  return \" + logReturnAggrFunName + \"();\\n }\\n }}\", body, iid1, getIid());\n      //console.log(JSON.stringify(ret));\n\n      ret = ret[0].body.body;\n      transferLoc(ret[0], node);\n      return ret;\n    } else {\n      return body;\n    }\n  }\n  function syncDefuns(node, scope, isScript) {\n    var ret = [],\n      ident;\n    if (!isScript) {\n      if (!Config.INSTR_TRY_CATCH_ARGUMENTS || Config.INSTR_TRY_CATCH_ARGUMENTS(node)) {\n        if (!Config.INSTR_INIT || Config.INSTR_INIT(node)) {\n          ident = createIdentifierAst(\"arguments\");\n          ret = ret.concat(createCallInitAsStatement(node, createLiteralAst(\"arguments\"), ident, true, ident, false, true));\n        }\n      }\n    }\n    if (scope) {\n      for (var name in scope.vars) {\n        if (HOP(scope.vars, name)) {\n          if (scope.vars[name] === \"defun\") {\n            if (!Config.INSTR_INIT || Config.INSTR_INIT(node)) {\n              ident = createIdentifierAst(name);\n              ident.loc = scope.funLocs[name];\n              ret = ret.concat(createCallInitAsStatement(node, createLiteralAst(name), wrapLiteral(ident, ident, N_LOG_FUNCTION_LIT), false, ident, false, true));\n            } else {\n              ident = createIdentifierAst(name);\n              ident.loc = scope.funLocs[name];\n              ret = ret.concat(createExpressionStatement(ident, wrapLiteral(ident, ident, N_LOG_FUNCTION_LIT)));\n            }\n          }\n          if (scope.vars[name] === \"lambda\") {\n            if (!Config.INSTR_INIT || Config.INSTR_INIT(node)) {\n              ident = createIdentifierAst(name);\n              ident.loc = scope.funLocs[name];\n              ret = ret.concat(createCallInitAsStatement(node, createLiteralAst(name), ident, false, ident, false, true));\n            }\n          }\n          if (scope.vars[name] === \"arg\") {\n            if (!Config.INSTR_INIT || Config.INSTR_INIT(node)) {\n              ident = createIdentifierAst(name);\n              ret = ret.concat(createCallInitAsStatement(node, createLiteralAst(name), ident, true, ident, false, true));\n            }\n          }\n          if (scope.vars[name] === \"var\") {\n            if (!Config.INSTR_INIT || Config.INSTR_INIT(node)) {\n              ret = ret.concat(createCallInitAsStatement(node, createLiteralAst(name), createIdentifierAst(name), false, undefined, false, false));\n            }\n          }\n        }\n      }\n    }\n    return ret;\n  }\n  var scope;\n  function instrumentFunctionEntryExit(node, ast) {\n    var body;\n    if (!Config.INSTR_TRY_CATCH_ARGUMENTS || Config.INSTR_TRY_CATCH_ARGUMENTS(node)) {\n      body = createCallAsFunEnterStatement(node);\n    } else {\n      body = [];\n    }\n    body = body.concat(syncDefuns(node, scope, false)).concat(ast);\n    return body;\n  }\n\n  //    function instrumentFunctionEntryExit(node, ast) {\n  //        return wrapFunBodyWithTryCatch(node, ast);\n  //    }\n\n  /**\n   * instruments entry of a script.  Adds the script entry (J$.Se) callback,\n   * and the J$.N init callbacks for locals.\n   *\n   */\n  function instrumentScriptEntryExit(node, body0) {\n    var body;\n    if (!Config.INSTR_TRY_CATCH_ARGUMENTS || Config.INSTR_TRY_CATCH_ARGUMENTS(node)) {\n      body = createCallAsScriptEnterStatement(node);\n    } else {\n      body = [];\n    }\n    body = body.concat(syncDefuns(node, scope, true)).concat(body0);\n    return body;\n  }\n  function getPropertyAsAst(ast) {\n    return ast.computed ? ast.property : createLiteralAst(ast.property.name);\n  }\n  function instrumentCall(callAst, isCtor) {\n    var ast = callAst.callee;\n    var ret;\n    if (ast.type === 'MemberExpression') {\n      ret = wrapMethodCall(callAst, ast.object, getPropertyAsAst(ast), isCtor, ast.computed);\n      return ret;\n    } else if (ast.type === 'Identifier' && ast.name === \"eval\") {\n      return ast;\n    } else {\n      ret = wrapFunCall(callAst, ast, isCtor);\n      return ret;\n    }\n  }\n  function instrumentStore(node, isDeclaration) {\n    var ret;\n    if (node.left.type === 'Identifier') {\n      if (scope.hasVar(node.left.name)) {\n        ret = wrapWrite(node.right, createLiteralAst(node.left.name), node.right, node.left, false, scope.isGlobal(node.left.name), isDeclaration);\n      } else {\n        ret = wrapWriteWithUndefinedCheck(node.right, createLiteralAst(node.left.name), node.right, node.left);\n      }\n      node.right = ret;\n      return node;\n    } else {\n      ret = wrapPutField(node, node.left.object, getPropertyAsAst(node.left), node.right, node.left.computed);\n      return ret;\n    }\n  }\n  function instrumentLoad(ast, isTypeof) {\n    var ret;\n    if (ast.type === 'Identifier') {\n      if (ast.name === \"undefined\") {\n        ret = wrapLiteral(ast, ast, N_LOG_UNDEFINED_LIT);\n        return ret;\n      } else if (ast.name === \"NaN\" || ast.name === \"Infinity\") {\n        ret = wrapLiteral(ast, ast, N_LOG_NUMBER_LIT);\n        return ret;\n      }\n      if (ast.name === JALANGI_VAR) {\n        return ast;\n      } else if (scope.hasVar(ast.name)) {\n        ret = wrapRead(ast, createLiteralAst(ast.name), ast, false, false, scope.isGlobal(ast.name));\n        return ret;\n      } else if (isTypeof) {\n        ret = wrapReadWithUndefinedCheck(ast, ast.name);\n        return ret;\n      } else {\n        ret = wrapRead(ast, createLiteralAst(ast.name), ast, false, true, false);\n        return ret;\n      }\n    } else if (ast.type === 'MemberExpression') {\n      return wrapGetField(ast, ast.object, getPropertyAsAst(ast), ast.computed);\n    } else {\n      return ast;\n    }\n  }\n  function instrumentLoadModStore(node, isNumber) {\n    if (node.left.type === 'Identifier') {\n      var tmp0 = instrumentLoad(node.left, false);\n      if (isNumber) {\n        tmp0 = makeNumber(node, instrumentLoad(tmp0, false));\n      }\n      var tmp1 = wrapRHSOfModStore(node.right, tmp0, node.right, node.operator.substring(0, node.operator.length - 1));\n      var tmp2;\n      if (scope.hasVar(node.left.name)) {\n        tmp2 = wrapWrite(node, createLiteralAst(node.left.name), tmp1, node.left, false, scope.isGlobal(node.left.name), false);\n      } else {\n        tmp2 = wrapWriteWithUndefinedCheck(node, createLiteralAst(node.left.name), tmp1, node.left);\n      }\n      tmp2 = wrapLHSOfModStore(node, node.left, tmp2);\n      return tmp2;\n    } else {\n      var ret = wrapModAssign(node, node.left.object, getPropertyAsAst(node.left), node.operator.substring(0, node.operator.length - 1), node.right, node.left.computed);\n      return ret;\n    }\n  }\n  function instrumentPreIncDec(node) {\n    var right = createLiteralAst(1);\n    right = wrapLiteral(right, right, N_LOG_NUMBER_LIT);\n    var ret = wrapRHSOfModStore(node, node.argument, right, node.operator.substring(0, 1) + \"=\");\n    return instrumentLoadModStore(ret, true);\n  }\n  function adjustIncDec(op, ast) {\n    if (op === '++') {\n      op = '-';\n    } else {\n      op = '+';\n    }\n    var right = createLiteralAst(1);\n    right = wrapLiteral(right, right, N_LOG_NUMBER_LIT);\n    var ret = wrapRHSOfModStore(ast, ast, right, op);\n    return ret;\n  }\n\n  // Should 'Program' nodes in the AST be wrapped with prefix code to load libraries,\n  // code to indicate script entry and exit, etc.?\n  // we need this flag since when we're instrumenting eval'd code, the code is parsed\n  // as a top-level 'Program', but the wrapping code may not be syntactically valid in\n  // the surrounding context, e.g.:\n  //    var y = eval(\"x + 1\");\n\n  function setScope(node) {\n    scope = node.scope;\n  }\n  function funCond0(node) {\n    node.test = wrapWithX1(node, node.test);\n    node.init = wrapWithX1(node, node.init);\n    node.update = wrapWithX1(node, node.update);\n    return node;\n  }\n  function mergeBodies(node) {\n    printIidToLoc(node);\n    var ret = replaceInStatement(\"function n() { if (!\" + logSampleFunName + \"(\" + RP + \"1, arguments.callee)){\" + RP + \"2} else {\" + RP + \"3}}\", getIid(), node.bodyOrig.body, node.body.body);\n    node.body.body = ret[0].body.body;\n    delete node.bodyOrig;\n    return node;\n  }\n  function regExpToJSON() {\n    var str = this.source;\n    var glb = this.global;\n    var ignoreCase = this.ignoreCase;\n    var multiline = this.multiline;\n    var obj = {\n      type: 'J$$.AST.REGEXP',\n      value: str,\n      glb: glb,\n      ignoreCase: ignoreCase,\n      multiline: multiline\n    };\n    return obj;\n  }\n  function JSONStringifyHandler(key, value) {\n    if (key === 'scope') {\n      return undefined;\n    }\n    if (value instanceof RegExp) {\n      return regExpToJSON.call(value);\n    } else {\n      return value;\n    }\n  }\n  function JSONParseHandler(key, value) {\n    var ret = value,\n      flags = '';\n    if (_typeof(value) === 'object' && value && value.type === 'J$$.AST.REGEXP') {\n      if (value.glb) flags += 'g';\n      if (value.ignoreCase) flags += 'i';\n      if (value.multiline) flags += 'm';\n      ret = RegExp(value.value, flags);\n    }\n    return ret;\n  }\n  function clone(src) {\n    var ret = JSON.parse(JSON.stringify(src, JSONStringifyHandler), JSONParseHandler);\n    return ret;\n  }\n\n  /*\n   function constructEmptyObject(o) {\n   function F() {}\n   F.prototype = o;\n   return new F();\n   }\n    function clone(src) { // from http://davidwalsh.name/javascript-clone\n   function mixin(dest, source, copyFunc) {\n   var name, s, i, empty = {};\n   for(name in source){\n   // the (!(name in empty) || empty[name] !== s) condition avoids copying properties in \"source\"\n   // inherited from Object.prototype.\t For example, if dest has a custom toString() method,\n   // don't overwrite it with the toString() method that source inherited from Object.prototype\n   s = source[name];\n   if(!(name in dest) || (dest[name] !== s && (!(name in empty) || empty[name] !== s))){\n   dest[name] = copyFunc ? copyFunc(s) : s;\n   }\n   }\n   return dest;\n   }\n    if(!src || typeof src != \"object\" || Object.prototype.toString.call(src) === \"[object Function]\"){\n   // null, undefined, any non-object, or function\n   return src;\t// anything\n   }\n   if(src.nodeType && \"cloneNode\" in src){\n   // DOM Node\n   return src.cloneNode(true); // Node\n   }\n   if(src instanceof Date){\n   // Date\n   return new Date(src.getTime());\t// Date\n   }\n   if(src instanceof RegExp){\n   // RegExp\n   return new RegExp(src);   // RegExp\n   }\n   var r, i, l;\n   if(src instanceof Array){\n   // array\n   r = [];\n   for(i = 0, l = src.length; i < l; ++i){\n   if(i in src){\n   r.push(clone(src[i]));\n   }\n   }\n   // we don't clone functions for performance reasons\n   //\t\t}else if(d.isFunction(src)){\n   //\t\t\t// function\n   //\t\t\tr = function(){ return src.apply(this, arguments); };\n   }else{\n   // generic objects\n   try {\n   r = constructEmptyObject(src);\n   //                r = src.constructor ? new src.constructor() : {};\n   } catch (e) {\n   console.log(src);\n   throw e;\n   }\n   }\n   return mixin(r, src, clone);\n    }\n   */\n  var visitorCloneBodyPre = {\n    \"FunctionExpression\": function FunctionExpression(node) {\n      node.bodyOrig = clone(node.body);\n      return node;\n    },\n    \"FunctionDeclaration\": function FunctionDeclaration(node) {\n      node.bodyOrig = clone(node.body);\n      return node;\n    }\n  };\n  var visitorMergeBodyPre = {\n    \"FunctionExpression\": mergeBodies,\n    \"FunctionDeclaration\": mergeBodies\n  };\n  var visitorRRPre = {\n    'Program': setScope,\n    'FunctionDeclaration': setScope,\n    'FunctionExpression': setScope,\n    'CatchClause': setScope\n  };\n  var visitorRRPost = {\n    'Literal': function Literal(node, context) {\n      if (context === astUtil.CONTEXT.RHS) {\n        var litType;\n        switch (_typeof(node.value)) {\n          case 'number':\n            litType = N_LOG_NUMBER_LIT;\n            break;\n          case 'string':\n            litType = N_LOG_STRING_LIT;\n            break;\n          case 'object':\n            // for null\n            if (node.value === null) litType = N_LOG_NULL_LIT;else litType = N_LOG_REGEXP_LIT;\n            break;\n          case 'boolean':\n            litType = N_LOG_BOOLEAN_LIT;\n            break;\n        }\n        var ret1 = wrapLiteral(node, node, litType);\n        return ret1;\n      } else {\n        return node;\n      }\n    },\n    \"Program\": function Program(node) {\n      var ret = instrumentScriptEntryExit(node, node.body);\n      node.body = ret;\n      scope = scope.parent;\n      return node;\n    },\n    \"VariableDeclaration\": function VariableDeclaration(node) {\n      var declarations = MAP(node.declarations, function (def) {\n        if (def.init !== null) {\n          var init = wrapWrite(def.init, createLiteralAst(def.id.name), def.init, def.id, false, scope.isGlobal(def.id.name), true);\n          init = wrapWithX1(def.init, init);\n          def.init = init;\n        }\n        return def;\n      });\n      node.declarations = declarations;\n      return node;\n    },\n    \"NewExpression\": function NewExpression(node) {\n      var ret = {\n        type: 'CallExpression',\n        callee: instrumentCall(node, true),\n        'arguments': node.arguments\n      };\n      transferLoc(ret, node);\n      return ret;\n      //            var ret1 = wrapLiteral(node, ret, N_LOG_OBJECT_LIT);\n      //            return ret1;\n    },\n    \"CallExpression\": function CallExpression(node) {\n      var isEval = node.callee.type === 'Identifier' && node.callee.name === \"eval\";\n      var callee = instrumentCall(node, false);\n      node.callee = callee;\n      if (isEval) {\n        node.arguments = MAP(node.arguments, wrapEvalArg);\n      }\n      return node;\n    },\n    \"AssignmentExpression\": function AssignmentExpression(node) {\n      var ret1;\n      if (node.operator === \"=\") {\n        ret1 = instrumentStore(node, false);\n      } else {\n        ret1 = instrumentLoadModStore(node);\n      }\n      return ret1;\n    },\n    \"UpdateExpression\": function UpdateExpression(node) {\n      var ret1;\n      ret1 = instrumentPreIncDec(node);\n      if (!node.prefix) {\n        ret1 = adjustIncDec(node.operator, ret1);\n      }\n      return ret1;\n    },\n    \"FunctionExpression\": function FunctionExpression(node, context) {\n      node.body.body = instrumentFunctionEntryExit(node, node.body.body);\n      var ret1;\n      if (context === astUtil.CONTEXT.GETTER || context === astUtil.CONTEXT.SETTER) {\n        ret1 = node;\n      } else {\n        ret1 = wrapLiteral(node, node, N_LOG_FUNCTION_LIT);\n      }\n      scope = scope.parent;\n      return ret1;\n    },\n    \"FunctionDeclaration\": function FunctionDeclaration(node) {\n      //console.log(node.body.body);\n      node.body.body = instrumentFunctionEntryExit(node, node.body.body);\n      scope = scope.parent;\n      return node;\n    },\n    \"ObjectExpression\": function ObjectExpression(node) {\n      var ret1 = wrapLiteral(node, node, N_LOG_OBJECT_LIT);\n      return ret1;\n    },\n    \"ArrayExpression\": function ArrayExpression(node) {\n      var ret1 = wrapLiteral(node, node, N_LOG_ARRAY_LIT);\n      return ret1;\n    },\n    'ThisExpression': function ThisExpression(node) {\n      var ret = wrapRead(node, createLiteralAst('this'), node, false, false, false);\n      return ret;\n    },\n    'Identifier': function Identifier(node, context) {\n      if (context === astUtil.CONTEXT.RHS) {\n        var ret = instrumentLoad(node, false);\n        return ret;\n      } else if (context === astUtil.CONTEXT.TYPEOF) {\n        ret = instrumentLoad(node, true);\n        return ret;\n      } else {\n        return node;\n      }\n    },\n    'MemberExpression': function MemberExpression(node, context) {\n      if (context === astUtil.CONTEXT.RHS) {\n        var ret = instrumentLoad(node, false);\n        return ret;\n      } else {\n        return node;\n      }\n    },\n    \"SequenceExpression\": function SequenceExpression(node) {\n      var i = 0,\n        len = node.expressions.length;\n      for (i = 0; i < len - 1 /* the last expression is the result, do not wrap that */; i++) {\n        node.expressions[i] = wrapWithX1(node.expressions[i], node.expressions[i]);\n      }\n      return node;\n    },\n    \"ForInStatement\": function ForInStatement(node) {\n      var ret = wrapHash(node.right, node.right);\n      node.right = ret;\n      node = wrapForIn(node, node.left, node.right, node.body);\n      //var name;\n      //if (node.left.type === 'VariableDeclaration') {\n      //    name = node.left.declarations[0].id.name;\n      //} else {\n      //    name = node.left.name;\n      //}\n      //node.body = wrapForInBody(node, node.body, name);\n      return node;\n    },\n    \"CatchClause\": function CatchClause(node) {\n      var name;\n      name = node.param.name;\n      wrapCatchClause(node, node.body.body, name);\n      scope = scope.parent;\n      return node;\n    },\n    \"ReturnStatement\": function ReturnStatement(node) {\n      var ret = wrapReturn(node, node.argument);\n      node.argument = wrapWithX1(node, ret);\n      return node;\n    },\n    \"ThrowStatement\": function ThrowStatement(node) {\n      var ret = wrapThrow(node, node.argument);\n      node.argument = wrapWithX1(node, ret);\n      return node;\n    },\n    \"ExpressionStatement\": function ExpressionStatement(node) {\n      node.expression = wrapWithX1(node, node.expression);\n      return node;\n    }\n  };\n  function funCond(node) {\n    var ret = wrapConditional(node.test, node.test);\n    node.test = ret;\n    node.test = wrapWithX1(node, node.test);\n    node.init = wrapWithX1(node, node.init);\n    node.update = wrapWithX1(node, node.update);\n    return node;\n  }\n  var visitorOps = {\n    \"Program\": function Program(node) {\n      var body = wrapScriptBodyWithTryCatch(node, node.body);\n      //                var ret = prependScriptBody(node, body);\n      node.body = body;\n      return node;\n    },\n    'BinaryExpression': function BinaryExpression(node) {\n      var ret = wrapBinaryOp(node, node.left, node.right, node.operator);\n      return ret;\n    },\n    'LogicalExpression': function LogicalExpression(node) {\n      var ret;\n      if (node.operator === \"&&\") {\n        ret = wrapLogicalAnd(node, node.left, node.right);\n      } else if (node.operator === \"||\") {\n        ret = wrapLogicalOr(node, node.left, node.right);\n      }\n      return ret;\n    },\n    'UnaryExpression': function UnaryExpression(node) {\n      var ret;\n      if (node.operator === \"void\") {\n        return node;\n      } else if (node.operator === \"delete\") {\n        if (node.argument.object) {\n          ret = wrapBinaryOp(node, node.argument.object, getPropertyAsAst(node.argument), node.operator, node.argument.computed);\n        } else {\n          return node;\n        }\n      } else {\n        ret = wrapUnaryOp(node, node.argument, node.operator);\n      }\n      return ret;\n    },\n    \"SwitchStatement\": function SwitchStatement(node) {\n      var dis = wrapSwitchDiscriminant(node.discriminant, node.discriminant);\n      dis = wrapWithX1(node.discriminant, dis);\n      var cases = MAP(node.cases, function (acase) {\n        var test;\n        if (acase.test) {\n          test = wrapSwitchTest(acase.test, acase.test);\n          acase.test = wrapWithX1(acase.test, test);\n        }\n        return acase;\n      });\n      node.discriminant = dis;\n      node.cases = cases;\n      return node;\n    },\n    \"FunctionExpression\": function FunctionExpression(node) {\n      node.body.body = wrapFunBodyWithTryCatch(node, node.body.body);\n      return node;\n    },\n    \"FunctionDeclaration\": function FunctionDeclaration(node) {\n      node.body.body = wrapFunBodyWithTryCatch(node, node.body.body);\n      return node;\n    },\n    \"WithStatement\": function WithStatement(node) {\n      node.object = wrapWith(node.object);\n      return node;\n    },\n    \"ConditionalExpression\": funCond,\n    \"IfStatement\": funCond,\n    \"WhileStatement\": funCond,\n    \"DoWhileStatement\": funCond,\n    \"ForStatement\": funCond\n  };\n  function addScopes(ast) {\n    function Scope(parent, isCatch) {\n      this.vars = {};\n      this.funLocs = {};\n      this.funNodes = {};\n      this.hasEval = false;\n      this.hasArguments = false;\n      this.parent = parent;\n      this.isCatch = isCatch;\n    }\n    Scope.prototype.addVar = function (name, type, loc, node) {\n      var tmpScope = this;\n      if (this.isCatch && type !== 'catch') {\n        tmpScope = this.parent;\n      }\n      if (tmpScope.vars[name] !== 'arg') {\n        tmpScope.vars[name] = type;\n      }\n      if (type === 'defun') {\n        tmpScope.funLocs[name] = loc;\n        tmpScope.funNodes[name] = node;\n      }\n    };\n    Scope.prototype.hasOwnVar = function (name) {\n      var s = this;\n      if (s && HOP(s.vars, name)) return s.vars[name];\n      return null;\n    };\n    Scope.prototype.hasVar = function (name) {\n      var s = this;\n      while (s !== null) {\n        if (HOP(s.vars, name)) return s.vars[name];\n        s = s.parent;\n      }\n      return null;\n    };\n    Scope.prototype.isGlobal = function (name) {\n      var s = this;\n      while (s !== null) {\n        if (HOP(s.vars, name) && s.parent !== null) {\n          return false;\n        }\n        s = s.parent;\n      }\n      return true;\n    };\n    Scope.prototype.addEval = function () {\n      var s = this;\n      while (s !== null) {\n        s.hasEval = true;\n        s = s.parent;\n      }\n    };\n    Scope.prototype.addArguments = function () {\n      var s = this;\n      while (s !== null) {\n        s.hasArguments = true;\n        s = s.parent;\n      }\n    };\n    Scope.prototype.usesEval = function () {\n      return this.hasEval;\n    };\n    Scope.prototype.usesArguments = function () {\n      return this.hasArguments;\n    };\n    var currentScope = null;\n\n    // rename arguments to J$_arguments\n    var fromName = 'arguments';\n    var toName = JALANGI_VAR + \"_arguments\";\n    function handleFun(node) {\n      var oldScope = currentScope;\n      currentScope = new Scope(currentScope);\n      node.scope = currentScope;\n      if (node.type === 'FunctionDeclaration') {\n        oldScope.addVar(node.id.name, \"defun\", node.loc, node);\n        MAP(node.params, function (param) {\n          if (param.name === fromName) {\n            // rename arguments to J$_arguments\n            param.name = toName;\n          }\n          currentScope.addVar(param.name, \"arg\");\n        });\n      } else if (node.type === 'FunctionExpression') {\n        if (node.id !== null) {\n          currentScope.addVar(node.id.name, \"lambda\");\n        }\n        MAP(node.params, function (param) {\n          if (param.name === fromName) {\n            // rename arguments to J$_arguments\n            param.name = toName;\n          }\n          currentScope.addVar(param.name, \"arg\");\n        });\n      }\n    }\n    function handleVar(node) {\n      currentScope.addVar(node.id.name, \"var\");\n    }\n    function handleCatch(node) {\n      var oldScope = currentScope;\n      currentScope = new Scope(currentScope, true);\n      node.scope = currentScope;\n      currentScope.addVar(node.param.name, \"catch\");\n    }\n    function popScope(node) {\n      currentScope = currentScope.parent;\n      return node;\n    }\n    var visitorPre = {\n      'Program': handleFun,\n      'FunctionDeclaration': handleFun,\n      'FunctionExpression': handleFun,\n      'VariableDeclarator': handleVar,\n      'CatchClause': handleCatch\n    };\n    var visitorPost = {\n      'Program': popScope,\n      'FunctionDeclaration': popScope,\n      'FunctionExpression': popScope,\n      'CatchClause': popScope,\n      'Identifier': function Identifier(node, context) {\n        // rename arguments to J$_arguments\n        if (context === astUtil.CONTEXT.RHS && node.name === fromName && currentScope.hasOwnVar(toName)) {\n          node.name = toName;\n        }\n        return node;\n      },\n      \"UpdateExpression\": function UpdateExpression(node) {\n        // rename arguments to J$_arguments\n        if (node.argument.type === 'Identifier' && node.argument.name === fromName && currentScope.hasOwnVar(toName)) {\n          node.argument.name = toName;\n        }\n        return node;\n      },\n      \"AssignmentExpression\": function AssignmentExpression(node) {\n        // rename arguments to J$_arguments\n        if (node.left.type === 'Identifier' && node.left.name === fromName && currentScope.hasOwnVar(toName)) {\n          node.left.name = toName;\n        }\n        return node;\n      }\n    };\n    astUtil.transformAst(ast, visitorPost, visitorPre);\n  }\n\n  // START of Liang Gong's AST post-processor\n  function hoistFunctionDeclaration(ast, hoisteredFunctions) {\n    var key,\n      child,\n      startIndex = 0;\n    if (ast.body) {\n      var newBody = [];\n      if (ast.body.length > 0) {\n        // do not hoister function declaration before J$.Fe or J$.Se\n        if (ast.body[0].type === 'ExpressionStatement') {\n          if (ast.body[0].expression.type === 'CallExpression') {\n            if (ast.body[0].expression.callee.object && ast.body[0].expression.callee.object.name === 'J$$' && ast.body[0].expression.callee.property && (ast.body[0].expression.callee.property.name === 'Se' || ast.body[0].expression.callee.property.name === 'Fe')) {\n              newBody.push(ast.body[0]);\n              startIndex = 1;\n            }\n          }\n        }\n      }\n      for (var i = startIndex; i < ast.body.length; i++) {\n        if (ast.body[i].type === 'FunctionDeclaration') {\n          newBody.push(ast.body[i]);\n          if (newBody.length !== i + 1) {\n            hoisteredFunctions.push(ast.body[i].id.name);\n          }\n        }\n      }\n      for (var i = startIndex; i < ast.body.length; i++) {\n        if (ast.body[i].type !== 'FunctionDeclaration') {\n          newBody.push(ast.body[i]);\n        }\n      }\n      while (ast.body.length > 0) {\n        ast.body.pop();\n      }\n      for (var i = 0; i < newBody.length; i++) {\n        ast.body.push(newBody[i]);\n      }\n    } else {\n      //console.log(typeof ast.body);\n    }\n    for (key in ast) {\n      if (ast.hasOwnProperty(key)) {\n        child = ast[key];\n        if (_typeof(child) === 'object' && child !== null && key !== \"scope\") {\n          hoistFunctionDeclaration(child, hoisteredFunctions);\n        }\n      }\n    }\n    return ast;\n  }\n\n  // END of Liang Gong's AST post-processor\n\n  function transformString(code, visitorsPost, visitorsPre) {\n    //         StatCollector.resumeTimer(\"parse\");\n    //        console.time(\"parse\")\n    //        var newAst = esprima.parse(code, {loc:true, range:true});\n    var newAst = acorn.parse(es6Transform(code), {\n      locations: true,\n      ecmaVersion: 6\n    });\n    //        console.timeEnd(\"parse\")\n    //        StatCollector.suspendTimer(\"parse\");\n    //        StatCollector.resumeTimer(\"transform\");\n    //        console.time(\"transform\")\n    addScopes(newAst);\n    var len = visitorsPost.length;\n    for (var i = 0; i < len; i++) {\n      newAst = astUtil.transformAst(newAst, visitorsPost[i], visitorsPre[i], astUtil.CONTEXT.RHS);\n    }\n    //        console.timeEnd(\"transform\")\n    //        StatCollector.suspendTimer(\"transform\");\n    //        console.log(JSON.stringify(newAst,null,\"  \"));\n    return newAst;\n  }\n\n  // if this string is discovered inside code passed to instrumentCode(),\n  // the code will not be instrumented\n  var noInstr = \"// JALANGI DO NOT INSTRUMENT\";\n  function initializeIIDCounters(forEval) {\n    var adj = forEval ? IID_INC_STEP / 2 : 0;\n    condIid = IID_INC_STEP + adj + 0;\n    memIid = IID_INC_STEP + adj + 1;\n    opIid = IID_INC_STEP + adj + 2;\n  }\n  function instrumentEvalCode(code, iid, isDirect) {\n    return instrumentCode({\n      code: code,\n      thisIid: iid,\n      isEval: true,\n      inlineSourceMap: true,\n      inlineSource: true,\n      isDirect: isDirect\n    }).code;\n  }\n  function removeShebang(code) {\n    if (code.indexOf(\"#!\") == 0) {\n      return code.substring(code.indexOf(\"\\n\") + 1);\n    }\n    return code;\n  }\n\n  /**\n   * Instruments the provided code.\n   *\n   * @param {{isEval: boolean, code: string, thisIid: int, origCodeFileName: string, instCodeFileName: string, inlineSourceMap: boolean, inlineSource: boolean, url: string, isDirect: boolean }} options\n   * @return {{code:string, instAST: object, sourceMapObject: object, sourceMapString: string}}\n   *\n   */\n  function instrumentCode(options) {\n    var aret,\n      skip = false;\n    var isEval = options.isEval,\n      code = options.code,\n      thisIid = options.thisIid,\n      inlineSource = options.inlineSource,\n      url = options.url;\n    iidSourceInfo = {};\n    initializeIIDCounters(isEval);\n    instCodeFileName = options.instCodeFileName ? options.instCodeFileName : options.isDirect ? \"eval\" : \"evalIndirect\";\n    origCodeFileName = options.origCodeFileName ? options.origCodeFileName : options.isDirect ? \"eval\" : \"evalIndirect\";\n    if (sandbox.analysis && sandbox.analysis.instrumentCodePre) {\n      aret = sandbox.analysis.instrumentCodePre(thisIid, code, options.isDirect);\n      if (aret) {\n        code = aret.code;\n        skip = aret.skip;\n      }\n    }\n    if (!skip && typeof code === 'string' && code.indexOf(noInstr) < 0) {\n      try {\n        code = removeShebang(code);\n        iidSourceInfo = {};\n        var newAst;\n        if (Config.ENABLE_SAMPLING) {\n          newAst = transformString(code, [visitorCloneBodyPre, visitorRRPost, visitorOps, visitorMergeBodyPre], [undefined, visitorRRPre, undefined, undefined]);\n        } else {\n          newAst = transformString(code, [visitorRRPost, visitorOps], [visitorRRPre, undefined]);\n        }\n        // post-process AST to hoist function declarations (required for Firefox)\n        var hoistedFcts = [];\n        newAst = hoistFunctionDeclaration(newAst, hoistedFcts);\n        var newCode = esotope.generate(newAst, {\n          comment: true,\n          parse: acorn.parse\n        });\n        code = newCode + \"\\n\" + noInstr + \"\\n\";\n      } catch (ex) {\n        console.log(\"Failed to instrument\", code);\n        throw ex;\n      }\n    }\n    var tmp = {};\n    tmp.nBranches = iidSourceInfo.nBranches = (condIid / IID_INC_STEP - 1) * 2;\n    tmp.originalCodeFileName = iidSourceInfo.originalCodeFileName = origCodeFileName;\n    tmp.instrumentedCodeFileName = iidSourceInfo.instrumentedCodeFileName = instCodeFileName;\n    if (url) {\n      tmp.url = iidSourceInfo.url = url;\n    }\n    if (isEval) {\n      tmp.evalSid = iidSourceInfo.evalSid = sandbox.sid;\n      tmp.evalIid = iidSourceInfo.evalIid = thisIid;\n    }\n    if (inlineSource) {\n      tmp.code = iidSourceInfo.code = options.code;\n    }\n    var prepend = JSON.stringify(iidSourceInfo);\n    var instCode;\n    if (options.inlineSourceMap) {\n      instCode = JALANGI_VAR + \".iids = \" + prepend + \";\\n\" + code;\n    } else {\n      instCode = JALANGI_VAR + \".iids = \" + JSON.stringify(tmp) + \";\\n\" + code;\n    }\n    if (isEval && sandbox.analysis && sandbox.analysis.instrumentCode) {\n      aret = sandbox.analysis.instrumentCode(thisIid, instCode, newAst, options.isDirect);\n      if (aret) {\n        instCode = aret.result;\n      }\n    }\n    return {\n      code: instCode,\n      instAST: newAst,\n      sourceMapObject: iidSourceInfo,\n      sourceMapString: prepend\n    };\n  }\n  sandbox.instrumentCode = instrumentCode;\n  sandbox.instrumentEvalCode = instrumentEvalCode;\n})(J$$);\n\n// exports J$$.instrumentCode\n// exports J$$.instrumentEvalCode\n// depends on acorn\n// depends on esotope\n// depends on babel\n// depends on J$$.Constants\n// depends on J$$.Config\n// depends on J$$.astUtil\n\n//# sourceURL=webpack://runtime-jalangi2/./src/esnstrument.js?");

/***/ }),

/***/ "./src/iidToLocation.js":
/*!******************************!*\
  !*** ./src/iidToLocation.js ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/*\n * Copyright 2013-2014 Samsung Information Systems America, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *        http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Author: Koushik Sen\n// do not remove the following comment\n// JALANGI DO NOT INSTRUMENT\n\nif (typeof J$$ === 'undefined') {\n  J$$ = {};\n}\n(function (sandbox) {\n  if (typeof sandbox.iidToLocation !== 'undefined') {\n    return;\n  }\n  sandbox.iidToLocation = function (sid, iid) {\n    var ret,\n      arr,\n      gid = sid;\n    if (sandbox.smap) {\n      if (typeof sid === 'string' && sid.indexOf(':') >= 0) {\n        sid = sid.split(':');\n        iid = parseInt(sid[1]);\n        sid = parseInt(sid[0]);\n      } else {\n        gid = sid + \":\" + iid;\n      }\n      if (ret = sandbox.smap[sid]) {\n        var fname = ret.originalCodeFileName;\n        if (ret.evalSid !== undefined) {\n          fname = fname + sandbox.iidToLocation(ret.evalSid, ret.evalIid);\n        }\n        arr = ret[iid];\n        if (arr) {\n          if (sandbox.Results) {\n            return \"<a href=\\\"javascript:iidToDisplayCodeLocation('\" + gid + \"');\\\">(\" + fname + \":\" + arr[0] + \":\" + arr[1] + \":\" + arr[2] + \":\" + arr[3] + \")</a>\";\n          } else {\n            return \"(\" + fname + \":\" + arr[0] + \":\" + arr[1] + \":\" + arr[2] + \":\" + arr[3] + \")\";\n          }\n        } else {\n          return \"(\" + fname + \":iid\" + iid + \")\";\n        }\n      }\n    }\n    return sid + \"\";\n  };\n  sandbox.getGlobalIID = function (iid) {\n    return sandbox.sid + \":\" + iid;\n  };\n})(J$$);\n\n//# sourceURL=webpack://runtime-jalangi2/./src/iidToLocation.js?");

/***/ }),

/***/ "./src/runtime.js":
/*!************************!*\
  !*** ./src/runtime.js ***!
  \************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n/*\n * Copyright 2014 Samsung Information Systems America, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *        http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Author: Koushik Sen\n\n// do not remove the following comment\n// JALANGI DO NOT INSTRUMENT\n\n// wrap in anonymous function to create local namespace when in browser\n// create / reset J$$ global variable to hold analysis runtime\nif (typeof J$$ === 'undefined') {\n  J$$ = {};\n}\n(function (sandbox) {\n  if (typeof sandbox.B !== 'undefined') {\n    return;\n  }\n  //----------------------------------- Begin Jalangi Library backend ---------------------------------\n\n  // stack of return values from instrumented functions.\n  // we need to keep a stack since a function may return and then\n  // have another function call in a finally block (see test\n  // call_in_finally.js)\n\n  var global = this;\n  var Function = global.Function;\n  var returnStack = [];\n  var wrappedExceptionVal;\n  var lastVal;\n  var switchLeft;\n  var switchKeyStack = [];\n  var argIndex;\n  var EVAL_ORG = eval;\n  var lastComputedValue;\n  var SPECIAL_PROP_SID = sandbox.Constants.SPECIAL_PROP_SID;\n  var SPECIAL_PROP_IID = sandbox.Constants.SPECIAL_PROP_IID;\n  function getPropSafe(base, prop) {\n    if (base === null || base === undefined) {\n      return undefined;\n    }\n    return base[prop];\n  }\n  function decodeBitPattern(i, len) {\n    var ret = new Array(len);\n    for (var j = 0; j < len; j++) {\n      var val = i & 1 ? true : false;\n      ret[len - j - 1] = val;\n      i = i >> 1;\n    }\n    return ret;\n  }\n  function createBitPattern() {\n    var ret = 0;\n    var i;\n    for (i = 0; i < arguments.length; i++) {\n      ret = (ret << 1) + (arguments[i] ? 1 : 0);\n    }\n    return ret;\n  }\n  var sidStack = [],\n    sidCounter = 0;\n  function createAndAssignNewSid() {\n    sidStack.push(sandbox.sid);\n    sandbox.sid = sidCounter = sidCounter + 1;\n    if (!sandbox.smap) sandbox.smap = {};\n    sandbox.smap[sandbox.sid] = sandbox.iids;\n  }\n  function rollBackSid() {\n    sandbox.sid = sidStack.pop();\n  }\n  function associateSidWithFunction(f, iid) {\n    if (typeof f === 'function') {\n      if (Object && Object.defineProperty && typeof Object.defineProperty === 'function') {\n        Object.defineProperty(f, SPECIAL_PROP_SID, {\n          enumerable: false,\n          writable: true\n        });\n        Object.defineProperty(f, SPECIAL_PROP_IID, {\n          enumerable: false,\n          writable: true\n        });\n      }\n      f[SPECIAL_PROP_SID] = sandbox.sid;\n      f[SPECIAL_PROP_IID] = iid;\n    }\n  }\n  function updateSid(f) {\n    sidStack.push(sandbox.sid);\n    sandbox.sid = getPropSafe(f, SPECIAL_PROP_SID);\n  }\n\n  // unused\n  function isNative(f) {\n    return f.toString().indexOf('[native code]') > -1 || f.toString().indexOf('[object ') === 0;\n  }\n\n  //   function callAsNativeConstructorWithEval(Constructor, args) {\n  //       var a = [];\n  //       for (var i = 0; i < args.length; i++)\n  //           a[i] = 'args[' + i + ']';\n  //       var eval = EVAL_ORG;\n  //       return eval('new Constructor(' + a.join() + ')');\n  //   }\n\n  function callAsNativeConstructorWithoutEval(Constructor, args) {\n    // Create a function that will call the constructor with the provided arguments\n    var func = new Function('Constructor', 'args', \"return new Constructor(\".concat(args.map(function (_, i) {\n      return 'args[' + i + ']';\n    }).join(', '), \");\"));\n    // Call the function with the constructor and the arguments\n    return func(Constructor, args);\n  }\n  function callAsNativeConstructor(Constructor, args) {\n    if (args.length === 0) {\n      return new Constructor();\n    }\n    if (args.length === 1) {\n      return new Constructor(args[0]);\n    }\n    if (args.length === 2) {\n      return new Constructor(args[0], args[1]);\n    }\n    if (args.length === 3) {\n      return new Constructor(args[0], args[1], args[2]);\n    }\n    if (args.length === 4) {\n      return new Constructor(args[0], args[1], args[2], args[3]);\n    }\n    if (args.length === 5) {\n      return new Constructor(args[0], args[1], args[2], args[3], args[4]);\n    }\n    return callAsNativeConstructorWithoutEval(Constructor, args);\n  }\n  function callAsConstructor(Constructor, args) {\n    var ret;\n    if (true) {\n      ret = callAsNativeConstructor(Constructor, args);\n      return ret;\n    } else { var Temp, inst; }\n  }\n  function invokeEval(base, f, args, iid) {\n    return f(sandbox.instrumentEvalCode(args[0], iid, false));\n  }\n  function invokeFunctionDecl(base, f, args, iid) {\n    // Invoke with the original parameters to preserve exceptional behavior if input is invalid\n    f.apply(base, args);\n    // Otherwise input is valid, so instrument and invoke via eval\n    var newArgs = [];\n    for (var i = 0; i < args.length - 1; i++) {\n      newArgs[i] = args[i];\n    }\n    var code = '(function(' + newArgs.join(', ') + ') { ' + args[args.length - 1] + ' })';\n    var code = sandbox.instrumentEvalCode(code, iid, false);\n    // Using EVAL_ORG instead of eval() is important as it preserves the scoping semantics of Function()\n    var out = EVAL_ORG(code);\n    return out;\n  }\n  function callFun(f, base, args, isConstructor, iid) {\n    var result;\n    pushSwitchKey();\n    try {\n      if (f === EVAL_ORG) {\n        result = invokeEval(base, f, args, iid);\n      } else if (f === Function) {\n        result = invokeFunctionDecl(base, f, args, iid);\n      } else if (isConstructor) {\n        result = callAsConstructor(f, args);\n      } else {\n        result = Function.prototype.apply.call(f, base, args);\n      }\n      return result;\n    } finally {\n      popSwitchKey();\n    }\n  }\n  function invokeFun(iid, base, f, args, isConstructor, isMethod) {\n    var aret,\n      skip = false,\n      result;\n    if (sandbox.analysis && sandbox.analysis.invokeFunPre) {\n      aret = sandbox.analysis.invokeFunPre(iid, f, base, args, isConstructor, isMethod, getPropSafe(f, SPECIAL_PROP_IID), getPropSafe(f, SPECIAL_PROP_SID));\n      if (aret) {\n        f = aret.f;\n        base = aret.base;\n        args = aret.args;\n        skip = aret.skip;\n      }\n    }\n    if (!skip) {\n      result = callFun(f, base, args, isConstructor, iid);\n    }\n    if (sandbox.analysis && sandbox.analysis.invokeFun) {\n      aret = sandbox.analysis.invokeFun(iid, f, base, args, result, isConstructor, isMethod, getPropSafe(f, SPECIAL_PROP_IID), getPropSafe(f, SPECIAL_PROP_SID));\n      if (aret) {\n        result = aret.result;\n      }\n    }\n    return result;\n  }\n\n  // Function call (e.g., f())\n  function F(iid, f, flags) {\n    var bFlags = decodeBitPattern(flags, 1); // [isConstructor]\n    return function () {\n      var base = this;\n      return lastComputedValue = invokeFun(iid, base, f, arguments, bFlags[0], false);\n    };\n  }\n\n  // Method call (e.g., e.f())\n  function M(iid, base, offset, flags) {\n    var bFlags = decodeBitPattern(flags, 2); // [isConstructor, isComputed]\n    var f = G(iid + 2, base, offset, createBitPattern(bFlags[1], false, true));\n    return function () {\n      return lastComputedValue = invokeFun(iid, base, f, arguments, bFlags[0], true);\n    };\n  }\n\n  // Ignore argument (identity).\n  function I(val) {\n    return val;\n  }\n  var hasGetOwnPropertyDescriptor = typeof Object.getOwnPropertyDescriptor === 'function';\n  // object/function/regexp/array Literal\n  function T(iid, val, type, hasGetterSetter, internalIid) {\n    var aret;\n    associateSidWithFunction(val, internalIid);\n    if (hasGetterSetter) {\n      for (var offset in val) {\n        if (hasGetOwnPropertyDescriptor && val.hasOwnProperty(offset)) {\n          var desc = Object.getOwnPropertyDescriptor(val, offset);\n          if (desc !== undefined) {\n            if (typeof desc.get === 'function') {\n              T(iid, desc.get, 12, false, internalIid);\n            }\n            if (typeof desc.set === 'function') {\n              T(iid, desc.set, 12, false, internalIid);\n            }\n          }\n        }\n      }\n    }\n    if (sandbox.analysis && sandbox.analysis.literal) {\n      aret = sandbox.analysis.literal(iid, val, hasGetterSetter);\n      if (aret) {\n        val = aret.result;\n      }\n    }\n    return lastComputedValue = val;\n  }\n\n  // wrap object o in for (x in o) { ... }\n  function H(iid, val) {\n    var aret;\n    if (sandbox.analysis && sandbox.analysis.forinObject) {\n      aret = sandbox.analysis.forinObject(iid, val);\n      if (aret) {\n        val = aret.result;\n      }\n    }\n    return val;\n  }\n\n  // variable declaration (Init)\n  function N(iid, name, val, flags) {\n    var bFlags = decodeBitPattern(flags, 3); // [isArgument, isLocalSync, isCatchParam]\n    // isLocalSync is only true when we sync variables inside a for-in loop\n    var aret;\n    if (bFlags[0]) {\n      argIndex++;\n    }\n    if (!bFlags[1] && sandbox.analysis && sandbox.analysis.declare) {\n      if (bFlags[0] && argIndex > 1) {\n        aret = sandbox.analysis.declare(iid, name, val, bFlags[0], argIndex - 2, bFlags[2]);\n      } else {\n        aret = sandbox.analysis.declare(iid, name, val, bFlags[0], -1, bFlags[2]);\n      }\n      if (aret) {\n        val = aret.result;\n      }\n    }\n    return val;\n  }\n\n  // getField (property read)\n  function G(iid, base, offset, flags) {\n    var bFlags = decodeBitPattern(flags, 3); // [isComputed, isOpAssign, isMethodCall]\n\n    var aret,\n      skip = false,\n      val;\n    if (sandbox.analysis && sandbox.analysis.getFieldPre) {\n      aret = sandbox.analysis.getFieldPre(iid, base, offset, bFlags[0], bFlags[1], bFlags[2]);\n      if (aret) {\n        base = aret.base;\n        offset = aret.offset;\n        skip = aret.skip;\n      }\n    }\n    if (!skip) {\n      val = base[offset];\n    }\n    if (sandbox.analysis && sandbox.analysis.getField) {\n      aret = sandbox.analysis.getField(iid, base, offset, val, bFlags[0], bFlags[1], bFlags[2]);\n      if (aret) {\n        val = aret.result;\n      }\n    }\n    return lastComputedValue = val;\n  }\n\n  // putField (property write)\n  function P(iid, base, offset, val, flags) {\n    var bFlags = decodeBitPattern(flags, 2); // [isComputed, isOpAssign]\n\n    var aret,\n      skip = false;\n    if (sandbox.analysis && sandbox.analysis.putFieldPre) {\n      aret = sandbox.analysis.putFieldPre(iid, base, offset, val, bFlags[0], !!bFlags[1]);\n      if (aret) {\n        base = aret.base;\n        offset = aret.offset;\n        val = aret.val;\n        skip = aret.skip;\n      }\n    }\n    if (!skip) {\n      base[offset] = val;\n    }\n    if (sandbox.analysis && sandbox.analysis.putField) {\n      aret = sandbox.analysis.putField(iid, base, offset, val, bFlags[0], !!bFlags[1]);\n      if (aret) {\n        val = aret.result;\n      }\n    }\n    return lastComputedValue = val;\n  }\n\n  // variable write\n  // isGlobal means that the variable is global and not declared as var\n  // isScriptLocal means that the variable is global and is declared as var\n  function R(iid, name, val, flags) {\n    var aret;\n    var bFlags = decodeBitPattern(flags, 2); // [isGlobal, isScriptLocal]\n\n    if (sandbox.analysis && sandbox.analysis.read) {\n      aret = sandbox.analysis.read(iid, name, val, bFlags[0], bFlags[1]);\n      if (aret) {\n        val = aret.result;\n      }\n    }\n    return lastComputedValue = val;\n  }\n\n  // variable write\n  function W(iid, name, val, lhs, flags) {\n    var bFlags = decodeBitPattern(flags, 3); //[isGlobal, isScriptLocal, isDeclaration]\n    var aret;\n    if (sandbox.analysis && sandbox.analysis.write) {\n      aret = sandbox.analysis.write(iid, name, val, lhs, bFlags[0], bFlags[1]);\n      if (aret) {\n        val = aret.result;\n      }\n    }\n    if (!bFlags[2]) {\n      return lastComputedValue = val;\n    } else {\n      lastComputedValue = undefined;\n      return val;\n    }\n  }\n\n  // with statement\n  function Wi(iid, val) {\n    if (sandbox.analysis && sandbox.analysis._with) {\n      aret = sandbox.analysis._with(iid, val);\n      if (aret) {\n        val = aret.result;\n      }\n    }\n    return val;\n  }\n\n  // Uncaught exception\n  function Ex(iid, e) {\n    wrappedExceptionVal = {\n      exception: e\n    };\n  }\n\n  // Throw statement\n  function Th(iid, val) {\n    var aret;\n    if (sandbox.analysis && sandbox.analysis._throw) {\n      aret = sandbox.analysis._throw(iid, val);\n      if (aret) {\n        val = aret.result;\n      }\n    }\n    return lastComputedValue = val;\n  }\n\n  // Return statement\n  function Rt(iid, val) {\n    var aret;\n    if (sandbox.analysis && sandbox.analysis._return) {\n      aret = sandbox.analysis._return(iid, val);\n      if (aret) {\n        val = aret.result;\n      }\n    }\n    returnStack.pop();\n    returnStack.push(val);\n    return lastComputedValue = val;\n  }\n\n  // Actual return from function, invoked from 'finally' block\n  // added around every function by instrumentation.  Reads\n  // the return value stored by call to Rt()\n  function Ra() {\n    var returnVal = returnStack.pop();\n    wrappedExceptionVal = undefined;\n    return returnVal;\n  }\n\n  // Function enter\n  function Fe(iid, f, dis /* this */, args) {\n    argIndex = 0;\n    returnStack.push(undefined);\n    wrappedExceptionVal = undefined;\n    updateSid(f);\n    if (sandbox.analysis && sandbox.analysis.functionEnter) {\n      sandbox.analysis.functionEnter(iid, f, dis, args);\n    }\n  }\n\n  // Function exit\n  function Fr(iid) {\n    var isBacktrack = false,\n      tmp,\n      aret,\n      returnVal;\n    returnVal = returnStack.pop();\n    if (sandbox.analysis && sandbox.analysis.functionExit) {\n      aret = sandbox.analysis.functionExit(iid, returnVal, wrappedExceptionVal);\n      if (aret) {\n        returnVal = aret.returnVal;\n        wrappedExceptionVal = aret.wrappedExceptionVal;\n        isBacktrack = aret.isBacktrack;\n      }\n    }\n    rollBackSid();\n    if (!isBacktrack) {\n      returnStack.push(returnVal);\n    }\n    // if there was an uncaught exception, throw it\n    // here, to preserve exceptional control flow\n    if (wrappedExceptionVal !== undefined) {\n      tmp = wrappedExceptionVal.exception;\n      wrappedExceptionVal = undefined;\n      throw tmp;\n    }\n    return isBacktrack;\n  }\n\n  // Script enter\n  function Se(iid, val, origFileName) {\n    createAndAssignNewSid();\n    if (sandbox.analysis && sandbox.analysis.scriptEnter) {\n      sandbox.analysis.scriptEnter(iid, val, origFileName);\n    }\n    lastComputedValue = undefined;\n  }\n\n  // Script exit\n  function Sr(iid) {\n    var tmp, aret, isBacktrack;\n    if (sandbox.analysis && sandbox.analysis.scriptExit) {\n      aret = sandbox.analysis.scriptExit(iid, wrappedExceptionVal);\n      if (aret) {\n        wrappedExceptionVal = aret.wrappedExceptionVal;\n        isBacktrack = aret.isBacktrack;\n      }\n    }\n    rollBackSid();\n    if (wrappedExceptionVal !== undefined) {\n      tmp = wrappedExceptionVal.exception;\n      wrappedExceptionVal = undefined;\n      throw tmp;\n    }\n    return isBacktrack;\n  }\n\n  // Modify and assign +=, -= ...\n  function A(iid, base, offset, op, flags) {\n    var bFlags = decodeBitPattern(flags, 1); // [isComputed]\n    // avoid iid collision: make sure that iid+2 has the same source map as iid (@todo)\n    var oprnd1 = G(iid + 2, base, offset, createBitPattern(bFlags[0], true, false));\n    return function (oprnd2) {\n      // still possible to get iid collision with a mem operation\n      var val = B(iid, op, oprnd1, oprnd2, createBitPattern(false, true, false));\n      return P(iid, base, offset, val, createBitPattern(bFlags[0], true));\n    };\n  }\n\n  // Binary operation\n  function B(iid, op, left, right, flags) {\n    var bFlags = decodeBitPattern(flags, 3); // [isComputed, isOpAssign, isSwitchCaseComparison]\n    var result,\n      aret,\n      skip = false;\n    if (sandbox.analysis && sandbox.analysis.binaryPre) {\n      aret = sandbox.analysis.binaryPre(iid, op, left, right, bFlags[1], bFlags[2], bFlags[0]);\n      if (aret) {\n        op = aret.op;\n        left = aret.left;\n        right = aret.right;\n        skip = aret.skip;\n      }\n    }\n    if (!skip) {\n      switch (op) {\n        case \"+\":\n          result = left + right;\n          break;\n        case \"-\":\n          result = left - right;\n          break;\n        case \"*\":\n          result = left * right;\n          break;\n        case \"/\":\n          result = left / right;\n          break;\n        case \"%\":\n          result = left % right;\n          break;\n        case \"<<\":\n          result = left << right;\n          break;\n        case \">>\":\n          result = left >> right;\n          break;\n        case \">>>\":\n          result = left >>> right;\n          break;\n        case \"<\":\n          result = left < right;\n          break;\n        case \">\":\n          result = left > right;\n          break;\n        case \"<=\":\n          result = left <= right;\n          break;\n        case \">=\":\n          result = left >= right;\n          break;\n        case \"==\":\n          result = left == right;\n          break;\n        case \"!=\":\n          result = left != right;\n          break;\n        case \"===\":\n          result = left === right;\n          break;\n        case \"!==\":\n          result = left !== right;\n          break;\n        case \"&\":\n          result = left & right;\n          break;\n        case \"|\":\n          result = left | right;\n          break;\n        case \"^\":\n          result = left ^ right;\n          break;\n        case \"delete\":\n          result = delete left[right];\n          break;\n        case \"instanceof\":\n          result = left instanceof right;\n          break;\n        case \"in\":\n          result = left in right;\n          break;\n        default:\n          throw new Error(op + \" at \" + iid + \" not found\");\n          break;\n      }\n    }\n    if (sandbox.analysis && sandbox.analysis.binary) {\n      aret = sandbox.analysis.binary(iid, op, left, right, result, bFlags[1], bFlags[2], bFlags[0]);\n      if (aret) {\n        result = aret.result;\n      }\n    }\n    return lastComputedValue = result;\n  }\n\n  // Unary operation\n  function U(iid, op, left) {\n    var result,\n      aret,\n      skip = false;\n    if (sandbox.analysis && sandbox.analysis.unaryPre) {\n      aret = sandbox.analysis.unaryPre(iid, op, left);\n      if (aret) {\n        op = aret.op;\n        left = aret.left;\n        skip = aret.skip;\n      }\n    }\n    if (!skip) {\n      switch (op) {\n        case \"+\":\n          result = +left;\n          break;\n        case \"-\":\n          result = -left;\n          break;\n        case \"~\":\n          result = ~left;\n          break;\n        case \"!\":\n          result = !left;\n          break;\n        case \"typeof\":\n          result = _typeof(left);\n          break;\n        case \"void\":\n          result = void left;\n          break;\n        default:\n          throw new Error(op + \" at \" + iid + \" not found\");\n          break;\n      }\n    }\n    if (sandbox.analysis && sandbox.analysis.unary) {\n      aret = sandbox.analysis.unary(iid, op, left, result);\n      if (aret) {\n        result = aret.result;\n      }\n    }\n    return lastComputedValue = result;\n  }\n  function pushSwitchKey() {\n    switchKeyStack.push(switchLeft);\n  }\n  function popSwitchKey() {\n    switchLeft = switchKeyStack.pop();\n  }\n  function last() {\n    return lastComputedValue = lastVal;\n  }\n\n  // Switch key\n  // E.g., for 'switch (x) { ... }',\n  // C1 is invoked with value of x\n  function C1(iid, left) {\n    switchLeft = left;\n    return lastComputedValue = left;\n  }\n\n  // case label inside switch\n  function C2(iid, right) {\n    var aret, result;\n\n    // avoid iid collision; iid may not have a map in the sourcemap\n    result = B(iid + 1, \"===\", switchLeft, right, createBitPattern(false, false, true));\n    if (sandbox.analysis && sandbox.analysis.conditional) {\n      aret = sandbox.analysis.conditional(iid, result);\n      if (aret) {\n        if (result && !aret.result) {\n          right = !right;\n        } else if (result && aret.result) {\n          right = switchLeft;\n        }\n      }\n    }\n    return lastComputedValue = right;\n  }\n\n  // Expression in conditional\n  function C(iid, left) {\n    var aret;\n    if (sandbox.analysis && sandbox.analysis.conditional) {\n      aret = sandbox.analysis.conditional(iid, left);\n      if (aret) {\n        left = aret.result;\n      }\n    }\n    lastVal = left;\n    return lastComputedValue = left;\n  }\n  function S(iid, f) {\n    if (sandbox.analysis && sandbox.analysis.runInstrumentedFunctionBody) {\n      return sandbox.analysis.runInstrumentedFunctionBody(iid, f, getPropSafe(f, SPECIAL_PROP_IID), getPropSafe(f, SPECIAL_PROP_SID));\n    }\n    return true;\n  }\n  function L() {\n    return lastComputedValue;\n  }\n  function X1(iid, val) {\n    if (sandbox.analysis && sandbox.analysis.endExpression) {\n      sandbox.analysis.endExpression(iid);\n    }\n    return lastComputedValue = val;\n  }\n  function endExecution() {\n    if (sandbox.analysis && sandbox.analysis.endExecution) {\n      return sandbox.analysis.endExecution();\n    }\n  }\n  function log(str) {\n    if (sandbox.Results && sandbox.Results.execute) {\n      sandbox.Results.execute(function (div, jquery, editor) {\n        div.append(str + \"<br>\");\n      });\n    } else {\n      console.log(str);\n    }\n  }\n\n  //----------------------------------- End Jalangi Library backend ---------------------------------\n\n  sandbox.U = U; // Unary operation\n  sandbox.B = B; // Binary operation\n  sandbox.C = C; // Condition\n  sandbox.C1 = C1; // Switch key\n  sandbox.C2 = C2; // case label C1 === C2\n  sandbox._ = last; // Last value passed to C\n\n  sandbox.H = H; // hash in for-in\n  sandbox.I = I; // Ignore argument\n  sandbox.G = G; // getField\n  sandbox.P = P; // putField\n  sandbox.R = R; // Read\n  sandbox.W = W; // Write\n  sandbox.N = N; // Init\n  sandbox.T = T; // object/function/regexp/array Literal\n  sandbox.F = F; // Function call\n  sandbox.M = M; // Method call\n  sandbox.A = A; // Modify and assign +=, -= ...\n  sandbox.Fe = Fe; // Function enter\n  sandbox.Fr = Fr; // Function return\n  sandbox.Se = Se; // Script enter\n  sandbox.Sr = Sr; // Script return\n  sandbox.Rt = Rt; // returned value\n  sandbox.Th = Th; // thrown value\n  sandbox.Ra = Ra;\n  sandbox.Ex = Ex;\n  sandbox.L = L;\n  sandbox.X1 = X1; // top level expression\n  sandbox.Wi = Wi; // with statement\n  sandbox.endExecution = endExecution;\n  sandbox.S = S;\n  sandbox.EVAL_ORG = EVAL_ORG;\n  sandbox.log = log;\n})(J$$);\n\n//# sourceURL=webpack://runtime-jalangi2/./src/runtime.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/entry.js");
/******/ 	
/******/ })()
;