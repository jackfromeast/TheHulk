// JALANGI DO NOT INSTRUMENT
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/coverage.js":
/*!*************************!*\
  !*** ./src/coverage.js ***!
  \*************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Coverage: () => (/* binding */ Coverage)\n/* harmony export */ });\n/* harmony import */ var _utils_iidToLocation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/iidToLocation.js */ \"./src/utils/iidToLocation.js\");\n// JALANGI DO NOT INSTRUMENT\n/**\n * Description:\n * --------------------------------\n * This script records the coverage information for the analysis.\n * \n * Usage: \n * --------------------------------\n */\n\n\nconst LAST_IID = \"LAST_IID\";\n\n/**\n * Bits for coverage info propagation\n */\n\nconst IS_TOUCHED = 0x1;\nconst CONDITIONAL_TRUE = 0x2;\nconst CONDITIONAL_FALSE = 0x4;\n\nclass Coverage {\n\n\t/**\n   * Creates an instance of Coverage.\n   * @param {any} sandbox The Jalangi sandbox\n   * _branches is an array of coverages for a given sid where the sid is branches[sid+1]\n   * @memberOf Coverage\n   */\n\tconstructor(sandbox) {\n\t\tthis._sandbox = sandbox;\n\t\tthis._branches = [];\n\t\tthis._branchFilenameMap = [];\n\t\tthis._lastIid = 0; //Store the last IID touched for search strategizer\n\n\t\tthis.brachTrace = {};\n\t}\n\n\tend() {\n\t\tconst payload = {\n\t\t\tcode: {}\n\t\t};\n\n\t\tfor (let i = 0; i < this._branches.length; i++) {\n            \n\t\t\t//SID are indexed from 1 not 0\n\t\t\tconst localSid = i + 1;\n\n\t\t\tif (this._branches[i] !== undefined) {\n\n\t\t\t\t//Deep copy the smap\n\t\t\t\tconst map = JSON.parse(JSON.stringify(this._sandbox.smap[localSid]));\n\n\t\t\t\t//Strip away any non SID related entities\n\t\t\t\tfor (const localIid in map) {\n\t\t\t\t\tif (isNaN(parseInt(localIid))) {\n\t\t\t\t\t\tdelete map[localIid];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmap[localIid] = (0,_utils_iidToLocation_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this._sandbox, localSid, localIid);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpayload[\"code\"][this._branchFilenameMap[i]] = {\n\t\t\t\t\tsmap: map,\n\t\t\t\t\tbranches: this._branches[i]\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tpayload[\"path\"] = this.brachTrace;\n\t\tpayload[LAST_IID] =\t this._lastIid;\n\t\treturn payload;\n\t}\n\n\tgetBranchInfo() {\n\n\t\t//-1 from 1-indexed sid to start from 0\n\t\tconst localIndex = this._sandbox.sid - 1;\n\t\tlet branchInfo = this._branches[localIndex];\n\n\t\tif (!branchInfo) {\n\t\t\tbranchInfo = {};\n\t\t\tthis._branches[localIndex] = branchInfo;\n\t\t\tconst map = this._sandbox.smap[this._sandbox.sid];\n\t\t\tthis._branchFilenameMap[localIndex] = map ? map.originalCodeFileName : \"Broken Filename\";\n\t\t}\n\n\t\treturn branchInfo;\n\t}\n\n\ttouch(iid) {\n\t\tthis.getBranchInfo()[iid] |= IS_TOUCHED;\n\t\tthis._lastIid = iid;\n\t}\n\n\ttouch_cnd(iid, result) {\n\t\tthis.touch(iid);\n\t\tthis.getBranchInfo()[iid] |= (result ? CONDITIONAL_TRUE : CONDITIONAL_FALSE);\n\n\t\tthis.touchBranch(iid, result);\n\t}\n\n\tlast() {\n\t\treturn this._lastIid || 0;\n\t}\n\n\ttouchBranch(iid, result) {\n\t\tlet binResult = result ? 1 : 0;\n\t\tlet gid = this._sandbox.sid + \":\" + iid;\n\n\t\tif(Object.keys(this.brachTrace).includes(gid)){\n\t\t\tthis.brachTrace[gid].push(binResult);\n\t\t}else{\n\t\t\tthis.brachTrace[gid] = [binResult];\n\t\t}\n\t}\n}\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/coverage.js?");

/***/ }),

/***/ "./src/entry.js":
/*!**********************!*\
  !*** ./src/entry.js ***!
  \**********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _taint_tracking_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./taint-tracking.js */ \"./src/taint-tracking.js\");\n// JALANGI DO NOT INSTRUMENT\n/**\n * @description\n * --------------------------------\n * This script is the entrypoint of the analysis script which will \n * 1/ read the config file and apply it\n * 2/ install the analysis class to the J$.analysis  \n * \n * @usage \n * --------------------------------\n */\n\n\n\n\nif (J$$) {\n  J$$.analysis = new _taint_tracking_js__WEBPACK_IMPORTED_MODULE_0__.TaintTracking(J$$);\n} else{\n  throw \"[TheHulk] Analysis module cannot be installed. J$$ not found.\"\n}\n\n\n\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/entry.js?");

/***/ }),

/***/ "./src/taint-sinks.js":
/*!****************************!*\
  !*** ./src/taint-sinks.js ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TaintSinkRules: () => (/* binding */ TaintSinkRules)\n/* harmony export */ });\n/* harmony import */ var _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./values/wrapped-values.js */ \"./src/values/wrapped-values.js\");\n/* harmony import */ var _values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./values/taint-info.js */ \"./src/values/taint-info.js\");\n\n\n\n\nclass TaintSinkRules {\n\n  /**\n   * @description\n   * --------------------------------\n   * This class defines the taint sink policy\n   * This function will be invoked during the putField operation hook\n   * \n   * @TODO\n   * add sink descriptions for the following cases\n   * \n   * @param {*} base - The base object of the getField operation. (which not be a WrappedValue)\n   * @param {*} offset - The offset of the getField operation.\n   * @param {*} val - The value of the getField operation.\n   * @param {number} iid - The instruction id.\n   */\n  checkTaintAtSinkPutField(base, offset, val) {\n\n    if (!this.isTainted(val)) { return false; }\n\n    if (base instanceof Element) {\n      if (base.tagName && base.tagName.toUpperCase() === 'SCRIPT' && offset === 'src') {\n        if (this.isTainted(val)) {\n          return \"SINK-TO-SCRIPT-SRC\";\n        }\n      } else if (offset === 'innerHTML' || offset === 'outerHTML') {\n        if (this.isTainted(val)) {\n          return `SINK-FROM-DOM-ELEMENT-${offset.toUpperCase()}`;\n        }\n      }\n    }\n\n    if (base === window && offset === 'location') {\n      if (this.isTainted(val)) {\n        return \"SINK-FROM-WINDOW-LOCATION\";\n      }\n    }\n\n    if (base === window.location && offset === 'href') {\n      if (this.isTainted(val)) {\n        return \"SINK-FROM-LOCATION-HREF\";\n      }\n    }\n\n    if (base === document && offset === 'cookie') {\n      if (this.isTainted(val)) {\n        return \"SINK-FROM-DOCUMENT-COOKIE\";\n      }\n    }\n\n    if (base === document && offset === 'domain') {\n      if (this.isTainted(val)) {\n        return \"SINK-FROM-DOCUMENT-DOMAIN\";\n      }\n    }\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * This function will be invoked during the call operation hook\n   * \n   * @param {Function} f - The function that is being called.\n   * @param {*} base - The base object of the function call.\n   * @param {Array} args - The arguments to the function.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   */\n  checkTaintAtSinkInvokeFun(f, base, args) {\n\n    if (f.name === 'eval') {\n      if (args.length && this.isTainted(args[0])) {\n        return [\"SINK-TO-EVAL\", args[0]];\n      }\n    }\n\n    if (f.name === 'setTimeout' || f.name === 'setInterval') {\n      if (args.length && this.isTainted(args[0])) {\n        return [`SINK-TO-${f.name.toUpperCase()}`, args[0]];\n      }\n    }\n\n    if (base === document) {\n      if (f.name === 'write' || f.name === 'writeln') {\n        if (args.length && this.isTainted(args[0])) {\n          return [`SINK-TO-DOCUMENT-${f.name.toUpperCase()}`, args[0]];\n        }\n      }\n    }\n\n    if (f.name === 'insertAdjacentHTML' && isDOMElement(base)) {\n      if (args.length >= 2 && this.isTainted(args[1])) {\n        return [\"SINK-TO-INSERTADJACENTHTML\", args[1]];\n      }\n    }\n\n    if (f.name === 'setAttribute' && base && base.tagName && base.tagName.toUpperCase() === 'SCRIPT') {\n      if (args.length >= 2 && this.isTainted(args[1])) {\n        return [\"SINK-TO-SETATTRIBUTE-SCRIPT-SRC\", args[1]];\n      }\n    }\n\n    if (f.name === 'fetch') {\n      if (args.length && this.isTainted(args[0])) {\n        return [\"SINK-TO-FETCH\", args[0]];\n      }\n    }\n\n    if (base.toString() === '[object XMLHttpRequest]' && f.name === 'open') {\n      if (args.length && this.isTainted(args[1])) {\n        return [\"SINK-TO-XMLHTTPREQUEST-OPEN\", args[1]];\n      }\n    }\n\n    if (isLocationObject(base) && (f.name === 'replace' || f.name === 'assign')) {\n      if (args.length && this.isTainted(args[0])) {\n        return [`SINK-TO-LOCATION-${f.name.toUpperCase()}`, args[0]];\n      }\n    }\n\n    if (base === JSON && f.name === 'parse') {\n      if (args.length && this.isTainted(args[0])) {\n        return [\"SINK-TO-JSON-PARSE\", args[0]];\n      }\n    }\n\n    if ((base === window.localStorage || base === window.sessionStorage) && f.name === 'setItem') {\n      if (args.length && this.isTainted(args[1])) {\n        return [`SINK-TO-${base === window.localStorage ? 'LOCALSTORAGE' : 'SESSIONSTORAGE'}-SETITEM`, args[1]];\n      }\n    }\n\n    return [false, null];\n  }\n\n  isTainted(value) {\n    return value instanceof _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__.TaintValue;\n  }\n\n  isDOMElement(element) {\n    return element instanceof Element;\n  }\n\n  isLocationObject(obj) {\n    return obj === window.location || obj === location;\n  }\n\n}\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/taint-sinks.js?");

/***/ }),

/***/ "./src/taint-sources.js":
/*!******************************!*\
  !*** ./src/taint-sources.js ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TaintSourceRules: () => (/* binding */ TaintSourceRules)\n/* harmony export */ });\n/* harmony import */ var _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./values/wrapped-values.js */ \"./src/values/wrapped-values.js\");\n/* harmony import */ var _values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./values/taint-info.js */ \"./src/values/taint-info.js\");\n\n\n\n/**\n * @description\n * --------------------------------\n * This class defines the taint source policy\n * The taint source listed below is *over-approximated*, \n * that we assume we can control the DOM elements (through DOM Clobbering & DOM APIs).\n */\nclass TaintSourceRules {\n  /**\n   * @description\n   * --------------------------------\n   * This function will be invoked during the getField operation hook\n   * \n   * SOURCE-TYPE-1: \n   * - SOURCE-FROM-DOM-ELEMENT\n   * - Value flows from the DOM Elements as taint sources\n   * - E.g. image.src, script.src, iframe.src, etc.\n   * \n   * SOURCE-TYPE-2: \n   * - SOURCE-FROM-DOCUMENT\n   * - Value flows from the document object as taint sources\n   * - E.g. document.cookie, document.domain, document.doctype, and etc.\n   * \n   * @param {*} base - The base object of the getField operation. (which not be a WrappedValue)\n   * @param {*} offset - The offset of the getField operation.\n   * @param {*} val - The value of the getField operation.\n   * @param {number} iid - The instruction id.\n   */\n  shouldTaintSourceAtGetField(base, offset, val, iid) {\n    // Check if the base is a DOM element\n    if (this.isDOMElement(base)) {\n      return \"SOURCE-FROM-DOM-ELEMENT\";\n    }\n\n    // Check if the base is the document object\n    if (this.isDocumentObject(base)) {\n      return \"SOURCE-FROM-DOCUMENT\";\n    }\n\n    return false;\n  }\n\n  isDOMElement(element) {\n    return element instanceof Element;\n  }\n\n  isDocumentObject(obj) {\n    return obj === document;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * This function will be invoked during the invokeFun operation hook\n   * \n   * SOURCE-TYPE-3:\n   * - SOURCE-FROM-BROWSER-API\n   * - Value flows from the browser APIs as taint sources\n   * - E.g. exampleAttr = div1.getAttribute(\"id\");\n   * \n   * @param {Function} f - The function being invoked.\n   * @param {*} base - The base object of the getField operation. (which should not be a WrappedValue)\n   * @param {Array} args - The arguments passed to the function.\n   * @param {*} result - The result of the getField operation.\n   * @param {number} iid - The instruction id.\n   */\n  shouldTaintSourceAtInvokeFun(f, base, args, result, iid) {\n    if (isBuiltInFunction(f) && \n       (isDOMElement(base) || isDocumentObject(base))) {\n        return \"SOURCE-FROM-BROWSER-API\";\n    }\n\n    return false;\n  }\n\n  isDOMElement(element) {\n    return element instanceof Element;\n  }\n\n  isDocumentObject(obj) {\n    return obj === document;\n  }\n\n  isBuiltInFunction(f) {\n    return typeof f === 'function' && (f === Object.prototype.toString.call(f).indexOf('[native code]') !== -1);\n  }\n}\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/taint-sources.js?");

/***/ }),

/***/ "./src/taint-tracking.js":
/*!*******************************!*\
  !*** ./src/taint-tracking.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TaintTracking: () => (/* binding */ TaintTracking)\n/* harmony export */ });\n/* harmony import */ var _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/logger.js */ \"./src/utils/logger.js\");\n/* harmony import */ var _coverage_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./coverage.js */ \"./src/coverage.js\");\n/* harmony import */ var _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./values/wrapped-values.js */ \"./src/values/wrapped-values.js\");\n/* harmony import */ var _taint_sources_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./taint-sources.js */ \"./src/taint-sources.js\");\n/* harmony import */ var _taint_sinks_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./taint-sinks.js */ \"./src/taint-sinks.js\");\n/* harmony import */ var _values_taint_info_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./values/taint-info.js */ \"./src/values/taint-info.js\");\n// JALANGI DO NOT INSTRUMENT\n/**\n * @description\n * --------------------------------\n * This script holds the concolic execution behaviors which will be invoked by the jalangi2 runtime.\n * This script will load and execute in the browser environment.\n * \n * @usage \n * --------------------------------\n */\n\n\n\n\n// import { TaintRules } from './taint-propagation-rules/rules.js';\n\n\n\n\nclass TaintTracking {\n  constructor(sandbox) {\n    this.taintID = 0;\n    this.sandbox = sandbox;\n    this.coverage = new _coverage_js__WEBPACK_IMPORTED_MODULE_1__.Coverage(sandbox);\n    this.logger = new _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Logger('debug', 'TaintTracking');\n\n    // this.taintRules = new TaintRules();\n    this.taintSourceRules = new _taint_sources_js__WEBPACK_IMPORTED_MODULE_3__.TaintSourceRules();\n    this.taintSinkRules = new _taint_sinks_js__WEBPACK_IMPORTED_MODULE_4__.TaintSinkRules();\n\n    this.dangerousFlows = [];\n  }\n\n  /**\n   * This callback is called before a binary operation. Binary operations include  +, -, *, /, %, &, |, ^,\n   * <<, >>, >>>, <, >, <=, >=, ==, !=, ===, !==, instanceof, delete, in.  No callback for <code>delete x</code>\n   * because this operation cannot be performed reflectively.\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {string} op - Operation to be performed\n   * @param {*} left - Left operand\n   * @param {*} right - Right operand\n   * @param {boolean} isOpAssign - True if the binary operation is part of an expression of the form\n   * <code>x op= e</code>\n   * @param {boolean} isSwitchCaseComparison - True if the binary operation is part of comparing the discriminant\n   * with a consequent in a switch statement.\n   * @param {boolean} isComputed - True if the operation is of the form <code>delete x[p]</code>, and false\n   * otherwise (even if the operation if of the form <code>delete x.p</code>)\n   * @returns {{op: string, left: *, right: *, skip: boolean}|undefined} - If an object is returned and the\n   * <tt>skip</tt> property is true, then the binary operation is skipped.  Original <tt>op</tt>, <tt>left</tt>,\n   * and <tt>right</tt> are replaced with that from the returned object if an object is returned.\n   */\n  binaryPre (iid, op, left, right, isOpAssign, isSwitchCaseComparison, isComputed) {\n    return {op: op, left: left, right: right, skip: false};\n  };\n\n  /**\n   * This callback is called after a binary operation. Binary operations include  +, -, *, /, %, &, |, ^,\n   * <<, >>, >>>, <, >, <=, >=, ==, !=, ===, !==, instanceof, delete, in.\n   *\n   * @steps\n   * 1/ Apply the taint propagation rules for the binary operation if one of the operands is tainted.\n   * \n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {string} op - Operation to be performed\n   * @param {*} left - Left operand\n   * @param {*} right - Right operand\n   * @param {*} result - The result of the binary operation\n   * @param {boolean} isOpAssign - True if the binary operation is part of an expression of the form\n   * <code>x op= e</code>\n   * @param {boolean} isSwitchCaseComparison - True if the binary operation is part of comparing the discriminant\n   * with a consequent in a switch statement.\n   * @param {boolean} isComputed - True if the operation is of the form <code>delete x[p]</code>, and false\n   * otherwise (even if the operation if of the form <code>delete x.p</code>)\n   * @returns {{result: *}|undefined} - If an object is returned, the result of the binary operation is\n   * replaced with the value stored in the <tt>result</tt> property of the object.\n   */\n  binary (iid, op, left, right, result, isOpAssign, isSwitchCaseComparison, isComputed) {\n    return {result: result};\n  };\n\n  /**\n   * This callback is called before a unary operation. Unary operations include  +, -, ~, !, typeof, void.\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {string} op - Operation to be performed\n   * @param {*} left - Left operand\n   * @returns {{op: *, left: *, skip: boolean} | undefined} If an object is returned and the\n   * <tt>skip</tt> property is true, then the unary operation is skipped.  Original <tt>op</tt> and <tt>left</tt>\n   * are replaced with that from the returned object if an object is returned.\n   */\n  unaryPre (iid, op, left) {\n      return {op: op, left: left, skip: false};\n  };\n\n  /**\n   * This callback is called after a unary operation. Unary operations include  +, -, ~, !, typeof, void.\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {string} op - Operation to be performed\n   * @param {*} left - Left operand\n   * @param {*} result - The result of the unary operation\n   * @returns {{result: *}|undefined} - If an object is returned, the result of the unary operation is\n   * replaced with the value stored in the <tt>result</tt> property of the object.\n   *\n   */\n  unary (iid, op, left, result) {\n      return {result: result};\n  };\n\n\n  /**\n   * This callback is called after a condition check before branching. Branching can happen in various statements\n   * including if-then-else, switch-case, while, for, ||, &&, ?:.\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {*} result - The value of the conditional expression\n   * @returns {{result: *}|undefined} - If an object is returned, the result of the conditional expression is\n   * replaced with the value stored in the <tt>result</tt> property of the object.\n   */\n  conditional (iid, result) {\n    return {result: result};\n  };\n\n  /**\n   * This callback is called before a string passed as an argument to eval or Function is instrumented.\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {*} code - Code that is going to get instrumented\n   * @param {boolean} isDirect - true if this is a direct call to eval\n   * @returns {{code: *, skip: boolean}} - If an object is returned and the\n   * <tt>skip</tt> property is true, then the instrumentation of <tt>code</tt> is skipped.\n   * Original <tt>code</tt> is replaced with that from the returned object if an object is returned.\n   */\n  instrumentCodePre (iid, code, isDirect) {\n    return {code: code, skip: false};\n  };\n\n  /**\n   * This callback is called after a string passed as an argument to eval or Function is instrumented.\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {*} newCode - Instrumented code\n   * @param {Object} newAst - The AST of the instrumented code\n   * @param {boolean} isDirect - true if this is a direct call to eval\n   * @returns {{result: *}|undefined} - If an object is returned, the instrumented code is\n   * replaced with the value stored in the <tt>result</tt> property of the object.\n   */\n  instrumentCode (iid, newCode, newAst, isDirect) {\n      return {result: newCode};\n  };\n\n\n  /**\n   * This callback is called before a function, method, or constructor invocation.\n   * \n   * @example\n   * y.f(a, b, c)\n   * --------------------------------\n   * var skip = false;\n   * var aret = analysis.invokeFunPre(113, f, y, [a, b, c], false, true);\n   * if (aret) {\n   *     f = aret.f;\n   *     y = aret.y;\n   *     args = aret.args;\n   *     skip = aret.skip\n   * }\n   * if (!skip) {\n   *     f.apply(y, args);\n   * }\n   * \n   * @steps\n   * 1/ Check the taint value at the sink function call.\n   * 2/ If a taint value is passed, check whether the function is a built-in function\n   *    and has the taint propagation rules.\n   * 3/ If the function is a built-in function and has the taint propagation rules,\n   *    we update the taint information on the return value.\n   * 4/ If the function is a built-in function and has no taint propagation rules,\n   *    we concretize the taint value and apply the original function. Concretization\n   *    will be logged.\n   * 5/ Log the coverage information for the analysis.\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {function} f - The function object that going to be invoked\n   * @param {object} base - The receiver object for the function <tt>f</tt>\n   * @param {Array} args - The array of arguments passed to <tt>f</tt>\n   * @param {boolean} isConstructor - True if <tt>f</tt> is invoked as a constructor\n   * @param {boolean} isMethod - True if <tt>f</tt> is invoked as a method\n   * @param {number} functionIid - The iid (i.e. the unique instruction identifier) where the function was created\n   * @param {number} functionSid - The sid (i.e. the unique script identifier) where the function was created\n   * {@link MyAnalysis#functionEnter} when the function <tt>f</tt> is executed.  The <tt>functionIid</tt> can be\n   * treated as the static identifier of the function <tt>f</tt>.  Note that a given function code block can\n   * create several function objects, but each such object has a common <tt>functionIid</tt>, which is the iid\n   * that is passed to {@link MyAnalysis#functionEnter} when the function executes.\n   * @returns {{f: function, base: Object, args: Array, skip: boolean}|undefined} - If an object is returned and\n   * the <tt>skip</tt> property of the object is true, then the invocation operation is skipped.\n   * Original <tt>f</tt>, <tt>base</tt>, and <tt>args</tt> are replaced with that from the returned object if\n   * an object is returned.\n   */\n  invokeFunPre (iid, f, base, args, isConstructor, isMethod, functionIid, functionSid) {\n    let [reason, taintedArg] = this.taintSinkPolicy.checkTaintAtSinkInvokeFun(f, base, args);\n    if (reason) {\n      // TODO: move this to another function\n      console.log(\"[TheHulk] Found a dangerous flow from %s to %s\",\n                 taintedArg.taintInfo.getTaintSourceReason(), reason);\n      this.dangerousFlows.push({\n        source: taintedArg.taintInfo.getTaintSourceReason(),\n        sourceLocation: taintedArg.taintInfo.getTaintSourceLocation(),\n        sink: reason,\n        sinkLocation: iid,\n        taintValue: taintedArg\n      });\n    }\n\n    // Check if any of the arguments are tainted\n    let taintedArgs = args.filter(arg => arg instanceof _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_2__.TaintValue);\n    // if (taintedArgs.length > 0) {\n      \n\n\n\n    // Check if the function is a built-in function\n    // TODO - move this to another function\n    \n\n\n    return {f: f, base: base, args: args, skip: false};\n  };\n\n  /**\n   * This callback is called after a function, method, or constructor invocation.\n   *\n   * @example\n   * x = y.f(a, b, c)\n   * --------------------------------\n   * var skip = false;\n   * var aret = analysis.invokeFunPre(113, f, y, [a, b, c], false, true);\n   * if (aret) {\n   *     f = aret.f;\n   *     y = aret.y;\n   *     args = aret.args;\n   *     skip = aret.skip\n   * }\n   * if (!skip) {\n   *     result =f.apply(y, args);\n   * }\n   * aret = analysis.invokeFun(117, f, y, args, result, false, true);\n   * if (aret) {\n   *     x = aret.result\n   * } else {\n   *     x = result;\n   * }\n   * \n   * @steps\n   * 1/ Taint the retrun value if the function api is a taint source.\n   * 2/ Log the coverage information for the analysis.\n   * \n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {function} f - The function object that was invoked\n   * @param {*} base - The receiver object for the function <tt>f</tt>\n   * @param {Array} args - The array of arguments passed to <tt>f</tt>\n   * @param {*} result - The value returned by the invocation\n   * @param {boolean} isConstructor - True if <tt>f</tt> is invoked as a constructor\n   * @param {boolean} isMethod - True if <tt>f</tt> is invoked as a method\n   * @param {number} functionIid - The iid (i.e. the unique instruction identifier) where the function was created\n   * @param {number} functionSid - The sid (i.e. the unique script identifier) where the function was created\n   * {@link MyAnalysis#functionEnter} when the function f is executed.  <tt>functionIid</tt> can be treated as the\n   * static identifier of the function <tt>f</tt>.  Note that a given function code block can create several function\n   * objects, but each such object has a common <tt>functionIid</tt>, which is the iid that is passed to\n   * {@link MyAnalysis#functionEnter} when the function executes.\n   * @returns {{result: *}| undefined} - If an object is returned, the return value of the invoked function is\n   * replaced with the value stored in the <tt>result</tt> property of the object.  This enables one to change the\n   * value that is returned by the actual function invocation.\n   *\n   */\n  invokeFun (iid, f, base, args, result, isConstructor, isMethod, functionIid, functionSid) {\n    let reason = this.taintSourceRules.shouldTaintSourceAtInvokeFun(f, base, args, result);\n    if (reason) {\n      let taintInfo = new TaintInfo(iid, reason, new _values_taint_info_js__WEBPACK_IMPORTED_MODULE_5__.TaintPropOperation(\"invokeFun\", [f, base, args, result]));\n      result = new _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_2__.TaintValue(result, taintInfo);\n    }\n    return {result: result};\n  };\n\n  /**\n   * This callback is called after the creation of a literal.  A literal can be a function literal, an object literal,\n   * an array literal, a number, a string, a boolean, a regular expression, null, NaN, Infinity, or undefined.\n   *\n   * @example\n   * x = \"Hello\"\n   * --------------------------------\n   * var result = \"Hello\";\n   * var aret = analysis.literal(201, result, false);\n   * if (aret) {\n   *     result = aret.result;\n   * }\n   * x = result;\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {*} val - The literal value\n   * @param {boolean} hasGetterSetter - True if the literal is an object and the object defines getters and setters\n   * @returns {{result: *} | undefined} - If the function returns an object, then the original literal value is\n   * replaced with the value stored in the <tt>result</tt> property of the object.\n   *\n   */\n  literal(iid, val, _hasGetterSetter) {\n\t\treturn {result: val};\n\t};\n\n  /**\n  * This callback is called when a for-in loop is used to iterate the properties of an object.\n  *\n  * @example\n  * for (x in y) { }\n  * --------------------------------\n  * var aret = analysis.forinObject(iid, y);\n  * if (aret) {\n  *     y = aret.result;\n  * }\n  * for (x in y) {}\n  *\n  * @param {number} iid - Static unique instruction identifier of this callback\n  * @param {*} val - Objects whose properties are iterated in a for-in loop.\n  * @returns {{result: *} | undefined} - If the function returns an object, then the original object whose\n  * properties are being iterated is replaced with the value stored in the <tt>result</tt> property of the\n  * returned object.\n  *\n  */\n  forinObject (iid, val) {\n    return {result: val};\n  };\n\n\n  /**\n   * This callback is triggered at the beginning of a scope for every local variable declared in the scope, for\n   * every formal parameter, for every function defined using a function statement, for <tt>arguments</tt>\n   * variable, and for the formal parameter passed in a catch statement.\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {string} name - Name of the variable that is declared\n   * @param {*} val - Initial value of the variable that is declared.  Variables can be local variables, function\n   * parameters, catch parameters, <tt>arguments</tt>, or functions defined using function statements.  Variables\n   * declared with <tt>var</tt> have <tt>undefined</tt> as initial values and cannot be changed by returning a\n   * different value from this callback.  On the beginning of an execution of a function, a <tt>declare</tt>\n   * callback is called on the <tt>arguments</tt> variable.\n   * @param {boolean} isArgument - True if the variable is <tt>arguments</tt> or a formal parameter.\n   * @param {number} argumentIndex - Index of the argument in the function call.  Indices start from 0.  If the\n   * variable is not a formal parameter, then <tt>argumentIndex</tt> is -1.\n   * @param {boolean} isCatchParam - True if the variable is a parameter of a catch statement.\n   * @returns {{result: *} | undefined} - If the function returns an object, then the original initial value is\n   * replaced with the value stored in the <tt>result</tt> property of the object.  This does not apply to local\n   * variables declared with <tt>var</tt>.\n   *\n   */\n  declare (iid, name, val, isArgument, argumentIndex, isCatchParam) {\n    return {result: val};\n  };\n\n\n  /**\n   * This callback is called before a property of an object is accessed.\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {*} base - Base object\n   * @param {string|*} offset - Property\n   * @param {boolean} isComputed - True if property is accessed using square brackets.  For example,\n   * <tt>isComputed</tt> is <tt>true</tt> if the get field operation is <tt>o[p]</tt>, and <tt>false</tt>\n   * if the get field operation is <tt>o.p</tt>\n   * @param {boolean} isOpAssign - True if the operation is of the form <code>o.p op= e</code>\n   * @param {boolean} isMethodCall - True if the get field operation is part of a method call (e.g. <tt>o.p()</tt>)\n   * @returns {{base: *, offset: *, skip: boolean} | undefined} - If an object is returned and the <tt>skip</tt>\n   * property of the object is true, then the get field operation is skipped.  Original <tt>base</tt> and\n   * <tt>offset</tt> are replaced with that from the returned object if an object is returned.\n   *\n   */\n  getFieldPre (iid, base, offset, isComputed, isOpAssign, isMethodCall) {\n    return {base: base, offset: offset, skip: false};\n  };\n\n\n  /**\n   * This callback is called after a property of an object is accessed.\n   * \n   * @steps\n   * 1/ Taint sources based on the base object and the accessed property.\n   * 2/ Log the coverage information for the analysis.\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {*} base - Base object\n   * @param {string|*} offset - Property\n   * @param {*} val - Value of <code>base[offset]</code>\n   * @param {boolean} isComputed - True if property is accessed using square brackets.  For example,\n   * <tt>isComputed</tt> is <tt>true</tt> if the get field operation is <tt>o[p]</tt>, and <tt>false</tt>\n   * if the get field operation is <tt>o.p</tt>\n   * @param {boolean} isOpAssign - True if the operation is of the form <code>o.p op= e</code>\n   * @param {boolean} isMethodCall - True if the get field operation is part of a method call (e.g. <tt>o.p()</tt>)\n   * @returns {{result: *} | undefined} - If an object is returned, the value of the get field operation  is\n   * replaced with the value stored in the <tt>result</tt> property of the object.\n   */\n  getField (iid, base, offset, val, isComputed, isOpAssign, isMethodCall) {\n    let reason = this.taintSourceRules.shouldTaintSourceAtGetField(base, offset, val);\n    if (reason) {\n      let taintInfo = new TaintInfo(iid, reason, new _values_taint_info_js__WEBPACK_IMPORTED_MODULE_5__.TaintPropOperation(\"getField\", [base, offset]));\n      val = new _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_2__.TaintValue(val, taintInfo);\n    }\n\n    return {result: val};\n  };\n\n\n  /**\n   * This callback is called before a property of an object is written.\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {*} base - Base object\n   * @param {*} offset - Property\n   * @param {*} val - Value to be stored in <code>base[offset]</code>\n   * @param {boolean} isComputed - True if property is accessed using square brackets.  For example,\n   * <tt>isComputed</tt> is <tt>true</tt> if the get field operation is <tt>o[p]</tt>, and <tt>false</tt>\n   * if the get field operation is <tt>o.p</tt>\n   * @param {boolean} isOpAssign - True if the operation is of the form <code>o.p op= e</code>\n   * @returns {{base: *, offset: *, val: *, skip: boolean} | undefined} -  If an object is returned and the <tt>skip</tt>\n   * property is true, then the put field operation is skipped.  Original <tt>base</tt>, <tt>offset</tt>, and\n   * <tt>val</tt> are replaced with that from the returned object if an object is returned.\n   */\n  putFieldPre (iid, base, offset, val, isComputed, isOpAssign) {\n    return {base: base, offset: offset, val: val, skip: false};\n  };\n\n\n  /**\n   * This callback is called after a property of an object is written.\n   * \n   * @steps\n   * 1/ Check whether a taint value has been set to the sink property (e.g. .innerHTML)\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {*} base - Base object\n   * @param {*} offset - Property\n   * @param {*} val - Value to be stored in <code>base[offset]</code>\n   * @param {boolean} isComputed - True if property is accessed using square brackets.  For example,\n   * <tt>isComputed</tt> is <tt>true</tt> if the get field operation is <tt>o[p]</tt>, and <tt>false</tt>\n   * if the get field operation is <tt>o.p</tt>\n   * @param {boolean} isOpAssign - True if the operation is of the form <code>o.p op= e</code>\n   * @returns {{result: *} | undefined} -   If an object is returned, the result of the put field operation is\n   * replaced with the value stored in the <tt>result</tt> property of the object.\n   */\n  putField (iid, base, offset, val, isComputed, isOpAssign) {\n    let reason = this.taintSinkPolicy.checkTaintAtSinkPutField(base, offset, val);\n\n    if (reason) {\n      // TODO: move this to another function\n      console.log(\"[TheHulk] Found a dangerous flow from %s to %s\",\n                  val.taintInfo.getTaintSourceReason(), reason);\n      this.dangerousFlows.push({\n        source: val.taintInfo.getTaintSourceReason(),\n        sourceLocation: val.taintInfo.getTaintSourceLocation(),\n        sink: reason,\n        sinkLocation: iid,\n        taintValue: val\n      });\n    }\n\n    return {result: val};\n  };\n\n\n  /**\n   * This callback is called after a variable is read.\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {string} name - Name of the variable being read\n   * @param {*} val - Value read from the variable\n   * @param {boolean} isGlobal - True if the variable is not declared using <tt>var</tt> (e.g. <tt>console</tt>)\n   * @param {boolean} isScriptLocal - True if the variable is declared in the global scope using <tt>var</tt>\n   * @returns {{result: *} | undefined} - If an object is returned, the result of the read operation is\n   * replaced with the value stored in the <tt>result</tt> property of the object.\n   */\n  read (iid, name, val, isGlobal, isScriptLocal) {\n    return {result: val};\n  };\n\n  /**\n   * This callback is called before a variable is written.\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {string} name - Name of the variable being read\n   * @param {*} val - Value to be written to the variable\n   * @param {*} lhs - Value stored in the variable before the write operation\n   * @param {boolean} isGlobal - True if the variable is not declared using <tt>var</tt> (e.g. <tt>console</tt>)\n   * @param {boolean} isScriptLocal - True if the variable is declared in the global scope using <tt>var</tt>\n   * @returns {{result: *} | undefined} - If an object is returned, the result of the write operation is\n   * replaced with the value stored in the <tt>result</tt> property of the object.\n   */\n  write (iid, name, val, lhs, isGlobal, isScriptLocal) {\n      return {result: val};\n  };\n\n  /**\n   * This callback is called before a value is returned from a function using the <tt>return</tt> keyword.\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {*} val - Value to be returned\n   * @returns {{result: *} | undefined} - If an object is returned, the value to be returned is\n   * replaced with the value stored in the <tt>result</tt> property of the object.\n   */\n  _return (iid, val) {\n      return {result: val};\n  };\n\n  /**\n   * This callback is called before a value is thrown using the <tt>throw</tt> keyword.\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {*} val - Value to be thrown\n   * @returns {{result: *} | undefined} - If an object is returned, the value to be thrown is\n   * replaced with the value stored in the <tt>result</tt> property of the object.\n   */\n  _throw (iid, val) {\n      return {result: val};\n  };\n\n  /**\n   * This callback is called when a <tt>with</tt> statement is executed\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {*} val - Value used as an argument to <tt>with</tt>\n   * @returns {{result: *} | undefined} - If an object is returned, the value to be used in <tt>with</tt> is\n   * replaced with the value stored in the <tt>result</tt> property of the object.\n   */\n  _with (iid, val) {\n      return {result: val};\n  };\n\n\n  /**\n   * This callback is called before the execution of a function body starts.\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {function} f - The function object whose body is about to get executed\n   * @param {*} dis - The value of the <tt>this</tt> variable in the function body\n   * @param {Array} args - List of the arguments with which the function is called\n   * @returns {undefined} - Any return value is ignored\n   */\n  functionEnter (iid, f, dis, args) {};\n  \n  /**\n   * This callback is called when the execution of a function body completes\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {*} returnVal - The value returned by the function\n   * @param {{exception:*} | undefined} wrappedExceptionVal - If this parameter is an object, the function\n   * execution has thrown an uncaught exception and the exception is being stored in the <tt>exception</tt>\n   * property of the parameter\n   * @returns {{returnVal: *, wrappedExceptionVal: *, isBacktrack: boolean}}  If an object is returned, then the\n   * actual <tt>returnVal</tt> and <tt>wrappedExceptionVal.exception</tt> are replaced with that from the\n   * returned object. If an object is returned and the property <tt>isBacktrack</tt> is set, then the control-flow\n   * returns to the beginning of the function body instead of returning to the caller.  The property\n   * <tt>isBacktrack</tt> can be set to <tt>true</tt> to repeatedly execute the function body as in MultiSE\n   * symbolic execution.\n   */\n  functionExit (iid, returnVal, wrappedExceptionVal) {\n      return {returnVal: returnVal, wrappedExceptionVal: wrappedExceptionVal, isBacktrack: false};\n  };\n\n\n  /**\n   * This callback is called before the execution of a JavaScript file\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {string} instrumentedFileName - Name of the instrumented script file\n   * @param {string} originalFileName - Name of the original script file\n   */\n  scriptEnter (iid, instrumentedFileName, originalFileName) {};\n  \n\n  /**\n   * This callback is called when the execution of a JavaScript file completes\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {{exception:*} | undefined} wrappedExceptionVal - If this parameter is an object, the script\n   * execution has thrown an uncaught exception and the exception is being stored in the <tt>exception</tt>\n   * property of the parameter\n   * @returns {{wrappedExceptionVal: *, isBacktrack: boolean}} - If an object is returned, then the\n   * actual <tt>wrappedExceptionVal.exception</tt> is replaced with that from the\n   * returned object. If an object is returned and the property <tt>isBacktrack</tt> is set, then the control-flow\n   * returns to the beginning of the script body.  The property\n   * <tt>isBacktrack</tt> can be set to <tt>true</tt> to repeatedly execute the script body as in MultiSE\n   * symbolic execution.\n   */\n  scriptExit (iid, wrappedExceptionVal) {\n      return {wrappedExceptionVal: wrappedExceptionVal, isBacktrack: false};\n  };\n}\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/taint-tracking.js?");

/***/ }),

/***/ "./src/utils/iidToLocation.js":
/*!************************************!*\
  !*** ./src/utils/iidToLocation.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* Copyright (c) Royal Holloway, University of London | Contact Blake Loring (blake@parsed.uk), Duncan Mitchell (Duncan.Mitchell.2015@rhul.ac.uk), or Johannes Kinder (johannes.kinder@rhul.ac.uk) for details or support | LICENSE.md for license details */\n// JALANGI DO NOT INSTRUMENT\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(sandbox, sid, iid) {\n  const iid_string = sandbox.iidToLocation(sid, iid);\n\n  if (!iid_string) {\n      return undefined;\n  }\n\n  return iid_string.substr(1, iid_string.length - 2).split(\":\").slice(1); //Comes in the form (Filename:1:2:3:4)   \n}\n\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/utils/iidToLocation.js?");

/***/ }),

/***/ "./src/utils/logger.js":
/*!*****************************!*\
  !*** ./src/utils/logger.js ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Logger: () => (/* binding */ Logger)\n/* harmony export */ });\n// JALANGI DO NOT INSTRUMENT\n/**\n * @description:\n * --------------------------------\n * This class implements a logger to replace the log4js module which\n * is not compatible with webpack bundle.\n */\nclass Logger {\n  constructor(level = 'info', name = 'default') {\n    this.name = name;\n    this.level = level;\n    this.levels = ['debug', 'info', 'warn', 'error'];\n    this.levelIndex = this.levels.indexOf(level);\n  }\n\n  log(level, message) {\n    const levelIndex = this.levels.indexOf(level);\n    if (levelIndex >= this.levelIndex) {\n      const logMessage = `[${new Date().toISOString()}] [${level.toUpperCase()}] [${this.name}] ${message}`;\n      switch (level) {\n        case 'debug':\n          console.log(`\\x1b[34m%s\\x1b[0m`, logMessage);\n          break;\n        case 'info':\n          console.log(`\\x1b[32m%s\\x1b[0m`, logMessage);\n          break;\n        case 'warn':\n          console.log(`\\x1b[33m%s\\x1b[0m`, logMessage);\n          break;\n        case 'error':\n          console.log(`\\x1b[31m%s\\x1b[0m`, logMessage);\n          break;\n      }\n    }\n  }\n\n  debug(message) {\n    this.log('debug', message);\n  }\n\n  info(message) {\n    this.log('info', message);\n  }\n\n  warn(message) {\n    this.log('warn', message);\n  }\n\n  error(message) {\n    this.log('error', message);\n  }\n\n  alertSink(msg) {\n    console.log(\"\\x1b[31m%s\\x1b[0m\", `[!] ${msg}`);\n  }\n}\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/utils/logger.js?");

/***/ }),

/***/ "./src/values/taint-info.js":
/*!**********************************!*\
  !*** ./src/values/taint-info.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TaintInfo: () => (/* binding */ TaintInfo),\n/* harmony export */   TaintPropOperation: () => (/* binding */ TaintPropOperation)\n/* harmony export */ });\n/**\n * @description\n * --------------------------------\n * Taint information for a value.\n * This class stores the following information about a taint:\n * 1/ Taint Identifier (ID)\n * 2/ Taint Source (Location) (i.e. where the taint originated from)\n * 3/ Taint propagation operations (i.e. how the taint is being propagated)\n * \n * The taint identifier is a unique identifier for the taint source. The derived\n * values will have the same taint identifier as value from which they are derived.\n * However, the taint propagation operations will differ.\n * \n * @example\n * --------------------------------\n * let b = a.replace(/[&<>n, 0=\\/]/g, \"\");\n * a.taintInfo = { \n *    taintID: 1,\n *    taintSource: {\n *      location: 1,\n *      sourceLocation: undefined,\n *      reason: \"DOM Clobberable Lookup\",\n *      operation: \"document.cookie\"\n *    },\n *    taintPropOperations: []\n * }\n * \n * b is derived from a, so we have\n * =>\n * b.taintInfo = a.taintInfo\n * b.taintInfo.addTaintPropOperation(\"replace\", [\"/[&<>n, 0=\\/]/g\", \"\"])\n */\nclass TaintInfo {\n  /**\n   * TaintInfo constructor\n   * @param {Smi} iid \n   * @param {String} reason: The reason why the taint was introduced\n   * @param {TaintPropOperation} operation: The operation that introduced the taint\n   */\n  constructor(iid, reason, operation) {\n    this.taintID = J$$.analysis.taintID+1 || 0;\n    this.taintSource = {\n      location: iid,\n      sourceLocation: undefined, // J$$.iidToLocation(iid)\n      reason: reason,\n      operation: operation\n    }\n\n    this.taintPropOperations = [operation];\n  }\n\n  getTaintID() {\n    return this.taintID;\n  }\n\n  getTaintSource() {\n    return this.taintSource;\n  }\n\n  getTaintSourceReason() {\n    return this.taintSource.reason;\n  }\n\n  getTaintSourceLocation() {\n    return this.taintSource.location;\n  }\n\n  getTaintPropOperations() {\n    return this.taintPropOperations;\n  }\n\n  addTaintPropOperation(operation, argument, location) {\n    this.taintPropOperations.push(\n      new TaintPropOperation(operation, argument, location));\n  }\n}\n\n/**\n * @description\n * --------------------------------\n * Taint propagation operation. This class stores the operation that is being\n * performed on the taint.\n * \n * @example\n * --------------------------------\n * TAINT.replace(/[&<>n, 0=\\/]/g, \"\");\n * =>\n * new TaintPropOperation(\"replace\", [\"/[&<>n, 0=\\/]/g\", \"\"]);\n * \n */\nclass TaintPropOperation {\n  /**\n   * TaintPropOperation constructor\n   * @param {String} operation \n   * @param {Array<String>} argument\n   * @param {Number} location\n   */\n  constructor(operation, argument, location) {\n    this.operation = operation;\n    this.arguments = argument;\n    this.location = location;\n  }\n\n  getOperation() {\n    return this.operation;\n  }\n\n  getArguments() {\n    return this.arguments;\n  }\n\n}\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/values/taint-info.js?");

/***/ }),

/***/ "./src/values/wrapped-values.js":
/*!**************************************!*\
  !*** ./src/values/wrapped-values.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConcolicValue: () => (/* binding */ ConcolicValue),\n/* harmony export */   TaintValue: () => (/* binding */ TaintValue),\n/* harmony export */   WrappedValue: () => (/* binding */ WrappedValue)\n/* harmony export */ });\n// JALANGI DO NOT INSTRUMENT\nclass WrappedValue {\n  /**\n   * \n   * @TODO\n   * Append the origin location & type of the wrapped value to the constructor\n   * \n   * @param {*} concrete \n   */\n  constructor(concrete) {\n    Object.defineProperty(this, 'concrete', {\n        value: concrete,\n        enumerable: false,\n        writable: true,\n        configurable: true\n    });\n  }\n\n  clone() {\n    return new WrappedValue(this.concrete);\n  }\n\n  toString() {\n    return \"Wrapped(\" + this.concrete + \", \" + (this.rider ? this.rider.toString() : \"\") + \")\";\n  }\n\n  valueOf() {\n    return this.concrete ? this.concrete.valueOf() : this.concrete;\n  }\n\n  getConcrete() {\n    return this.concrete;\n  }\n}\n\nclass ConcolicValue extends WrappedValue { \n  constructor(concrete, symbolic, arrayType = undefined) {\n      super(concrete);\n      this.__defineProperty('symbolic', symbolic);\n      this.__defineProperty('_arrayType', arrayType);\n  }\n\n  __defineProperty(name, value){\n    Object.defineProperty(this, name, {\n        value: value,\n        enumerable: false,\n        writable: true,\n        configurable: true\n    });\n  }\n\n  toString() {\n      return \"Concolic(\" + this.concrete + \", \" + this.symbolic + \")\";\n  }\n\n  clone() {\n      return new ConcolicValue(this.concrete, this.symbolic);\n  }\n\n  getConcrete() {\n      return this.concrete;\n  }\n\n  getSymbolic() {\n      return this.symbolic;\n  }\n\n  getArrayType() {\n      return this._arrayType;\n  }\n\n}\n\nConcolicValue.getSymbolic = function(val) {\n  return val instanceof ConcolicValue ? val.symbolic : undefined;\n};\n\nConcolicValue.setSymbolic = function(val, val_s) {\n  if (val instanceof ConcolicValue) {\n      val.symbolic = val_s;\n  }\n};\n\n\n/**\n * @description\n * --------------------------------\n * TaintValue is a wrapper class for values that are tainted\n * Similar to ConcolicValue class, but with the addition of taint information\n * Ideally, all the JavaScript values can be wrapped with TaintValue\n * \n */\nclass TaintValue extends WrappedValue {\n  /**\n   * TaintValue constructor\n   * \n   * @param {*} concrete \n   * @param {TaintInfo} taintInfo \n   */\n  constructor(concrete, taintInfo) {\n    super(concrete);\n    this.__defineProperty('taintInfo', taintInfo);\n  }\n\n  __defineProperty(name, value){\n    Object.defineProperty(this, name, {\n        value: value,\n        enumerable: false,\n        writable: true,\n        configurable: true\n    });\n  }\n\n  toString() {\n    return \"TaintValue(\" + this.concrete + \", \" + this.taintInfo + \")\";\n  }\n\n  clone() {\n    return new TaintValue(this.concrete, this.taintInfo);\n  }\n\n  getConcrete() {\n    return this.concrete;\n  }\n\n  getTaintInfo() {\n    return this.taintInfo;\n  }\n}\n\n\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/values/wrapped-values.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/entry.js");
/******/ 	
/******/ })()
;