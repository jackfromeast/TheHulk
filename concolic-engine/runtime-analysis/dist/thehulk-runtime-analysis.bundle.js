// JALANGI DO NOT INSTRUMENT
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/coverage.js":
/*!*************************!*\
  !*** ./src/coverage.js ***!
  \*************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Coverage: () => (/* binding */ Coverage)\n/* harmony export */ });\n/* harmony import */ var _utils_iidToLocation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/iidToLocation.js */ \"./src/utils/iidToLocation.js\");\n// JALANGI DO NOT INSTRUMENT\n/**\n * Description:\n * --------------------------------\n * This script records the coverage information for the analysis.\n * \n * Usage: \n * --------------------------------\n */\n\n\nconst LAST_IID = \"LAST_IID\";\n\n/**\n * Bits for coverage info propagation\n */\n\nconst IS_TOUCHED = 0x1;\nconst CONDITIONAL_TRUE = 0x2;\nconst CONDITIONAL_FALSE = 0x4;\n\nclass Coverage {\n\n\t/**\n   * Creates an instance of Coverage.\n   * @param {any} sandbox The Jalangi sandbox\n   * _branches is an array of coverages for a given sid where the sid is branches[sid+1]\n   * @memberOf Coverage\n   */\n\tconstructor(sandbox) {\n\t\tthis._sandbox = sandbox;\n\t\tthis._branches = [];\n\t\tthis._branchFilenameMap = [];\n\t\tthis._lastIid = 0; //Store the last IID touched for search strategizer\n\n\t\tthis.brachTrace = {};\n\t}\n\n\tend() {\n\t\tconst payload = {\n\t\t\tcode: {}\n\t\t};\n\n\t\tfor (let i = 0; i < this._branches.length; i++) {\n            \n\t\t\t//SID are indexed from 1 not 0\n\t\t\tconst localSid = i + 1;\n\n\t\t\tif (this._branches[i] !== undefined) {\n\n\t\t\t\t//Deep copy the smap\n\t\t\t\tconst map = JSON.parse(JSON.stringify(this._sandbox.smap[localSid]));\n\n\t\t\t\t//Strip away any non SID related entities\n\t\t\t\tfor (const localIid in map) {\n\t\t\t\t\tif (isNaN(parseInt(localIid))) {\n\t\t\t\t\t\tdelete map[localIid];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmap[localIid] = (0,_utils_iidToLocation_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this._sandbox, localSid, localIid);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpayload[\"code\"][this._branchFilenameMap[i]] = {\n\t\t\t\t\tsmap: map,\n\t\t\t\t\tbranches: this._branches[i]\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tpayload[\"path\"] = this.brachTrace;\n\t\tpayload[LAST_IID] =\t this._lastIid;\n\t\treturn payload;\n\t}\n\n\tgetBranchInfo() {\n\n\t\t//-1 from 1-indexed sid to start from 0\n\t\tconst localIndex = this._sandbox.sid - 1;\n\t\tlet branchInfo = this._branches[localIndex];\n\n\t\tif (!branchInfo) {\n\t\t\tbranchInfo = {};\n\t\t\tthis._branches[localIndex] = branchInfo;\n\t\t\tconst map = this._sandbox.smap[this._sandbox.sid];\n\t\t\tthis._branchFilenameMap[localIndex] = map ? map.originalCodeFileName : \"Broken Filename\";\n\t\t}\n\n\t\treturn branchInfo;\n\t}\n\n\ttouch(iid) {\n\t\tthis.getBranchInfo()[iid] |= IS_TOUCHED;\n\t\tthis._lastIid = iid;\n\t}\n\n\ttouch_cnd(iid, result) {\n\t\tthis.touch(iid);\n\t\tthis.getBranchInfo()[iid] |= (result ? CONDITIONAL_TRUE : CONDITIONAL_FALSE);\n\n\t\tthis.touchBranch(iid, result);\n\t}\n\n\tlast() {\n\t\treturn this._lastIid || 0;\n\t}\n\n\ttouchBranch(iid, result) {\n\t\tlet binResult = result ? 1 : 0;\n\t\tlet gid = this._sandbox.sid + \":\" + iid;\n\n\t\tif(Object.keys(this.brachTrace).includes(gid)){\n\t\t\tthis.brachTrace[gid].push(binResult);\n\t\t}else{\n\t\t\tthis.brachTrace[gid] = [binResult];\n\t\t}\n\t}\n}\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/coverage.js?");

/***/ }),

/***/ "./src/entry.js":
/*!**********************!*\
  !*** ./src/entry.js ***!
  \**********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _taint_tracking_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./taint-tracking.js */ \"./src/taint-tracking.js\");\n/* harmony import */ var _taint_expose_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./taint-expose.js */ \"./src/taint-expose.js\");\n// JALANGI DO NOT INSTRUMENT\n/**\n * @description\n * --------------------------------\n * This script is the entrypoint of the analysis script which will \n * 1/ read the config file and apply it\n * 2/ install the analysis class to the J$.analysis  \n * \n * @usage \n * --------------------------------\n */\n\n\n// import { CountMostFrequentlyUsedBuiltinsAnalysis } from './others/most-frequently-used-api.js'\n\nif (J$$) {\n  J$$.analysis = new _taint_tracking_js__WEBPACK_IMPORTED_MODULE_0__.TaintTracking(J$$);\n  // J$$.analysis = new CountMostFrequentlyUsedBuiltinsAnalysis(J$$);\n} else{\n  throw \"[TheHulk] Analysis module cannot be installed. J$$ not found.\"\n}\n\n\n\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/entry.js?");

/***/ }),

/***/ "./src/rules/js-builtins/array-builtins.js":
/*!*************************************************!*\
  !*** ./src/rules/js-builtins/array-builtins.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArrayBuiltinsTaintPropRules: () => (/* binding */ ArrayBuiltinsTaintPropRules)\n/* harmony export */ });\n/* harmony import */ var _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../values/wrapped-values.js */ \"./src/values/wrapped-values.js\");\n/* harmony import */ var _values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../values/taint-info.js */ \"./src/values/taint-info.js\");\n/* harmony import */ var _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../rule-builder.js */ \"./src/rules/rule-builder.js\");\n/* harmony import */ var _rule_condition_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../rule-condition.js */ \"./src/rules/rule-condition.js\");\n/* harmony import */ var _rules_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../rules.js */ \"./src/rules/rules.js\");\n/* harmony import */ var _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../taint-helper.js */ \"./src/taint-helper.js\");\n/* harmony import */ var _utils_util_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utils/util.js */ \"./src/utils/util.js\");\n\n\n\n\n\n\n\n\nclass ArrayBuiltinsTaintPropRules {\n  constructor() {\n    this.ruleDict = [];\n    this.buildRules();\n\n    if (!_utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils) {\n      J$$.analysis.logger.error('Utils is not defined');\n    }\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * We support rules for the array builtins that follow:\n   * 1/ The return value need to be tainted if one of the elements in the array is tainted \n   *    and is not the return value itself.\n   * 2/ The return value is in type of String, not Boolean.\n   * \n   * We also need to handle the case where the element is tainted and will cause the builtins panic:\n   * - TODO:\n   * \n   * Builtins that don't need to be handled:\n   * - Array.prototype.entries\n   * - Array.prototype.keys\n   * - Array.prototype.values\n   * - Array.prototype.push\n   * - Array.prototype.pop\n   * - etc.\n   * \n   * @TODO\n   * --------------------------------\n   * TODO: condition check function should also be added to the rules Dict\n   * E.g. condition: ANY_ARGS_TAINTED OR BASE_TAINTED, FIRST_ARG_TAINTED, etc.\n   * from builtins should use the FIRST_ARG_TAINTED condition\n   * Now, all of them use the ANY_ARGS_TAINTED OR BASE_TAINTED condition\n   */\n  supportedArrayBuiltins = {\n    'from': [Array.from, this.fromArrayModel, 'BASE_TAINTED || ANY_ARGS_TAINTED'],\n    'join': [Array.prototype.join, this.joinArrayModel, 'BASE_TAINTED_RECURSIVE || FIRST_ARG_TAINTED_RECURSIVE'],\n    'toString': [Array.prototype.toString, this.toStringArrayModel, 'BASE_TAINTED'],\n    'toLocaleString': [Array.prototype.toLocaleString, this.toLocaleStringArrayModel, 'BASE_TAINTED'],\n  };\n\n  /**\n   * @description\n   * --------------------------------\n   * Here is a list of builtins that uses none affected taint propagation rules.\n   * \n   * This means, even the arguments are tainted or the return value is tainted,\n   * we don't do anything but call the original function.\n   * \n   * We need to maintain this list becuase if invokeFunPre function doesn't find the \n   * rule for the builtins, it will concreate all the base and arguments and return value.\n   * Therefore, we need to explicitly set an none-affect builtins list.\n   * \n   */\n  noneAffectBuiltins = {\n    'push': Array.prototype.push,\n    'pop': Array.prototype.pop,\n    'shift': Array.prototype.shift,\n    'unshift': Array.prototype.unshift,\n    'slice': Array.prototype.slice,\n    'reverse': Array.prototype.reverse,\n    'sort': Array.prototype.sort,\n    'splice': Array.prototype.splice,\n    'forEach': Array.prototype.forEach,\n    'map': Array.prototype.map,\n    'concat': Array.prototype.concat,\n    'splice': Array.prototype.splice,\n    'values': Array.prototype.values,\n    'includes': Array.prototype.includes,\n    'filter': Array.prototype.filter,\n    'reduce': Array.prototype.reduce,\n    'every': Array.prototype.every,\n    'flatMap': Array.prototype.flatMap,\n    'findIndex': Array.prototype.findIndex,\n    'reduceRight': Array.prototype.reduceRight,\n    'keys': Array.prototype.keys,\n    'fill': Array.prototype.fill\n  }\n\n  buildRules() {\n    for (const [fName, fGroup] of Object.entries(this.supportedArrayBuiltins)) {\n      const condition = _rule_condition_js__WEBPACK_IMPORTED_MODULE_3__.ConditionBuilder.makeCondition(fGroup[2]);\n      const rule = _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__.RuleBuilder.makeRule(fGroup[0], condition, fGroup[1]);\n      this.addRule(fGroup[0], rule);\n    }\n\n    for (const [fName, fGroup_0] of Object.entries(this.noneAffectBuiltins)) {\n      const rule = _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__.RuleBuilder.makeNoneRule(fGroup_0);\n      this.addRule(fGroup_0, rule);\n    }\n  }\n\n  addRule(func, rule) {\n    this.ruleDict.push({ func, rule });\n  }\n\n  getRule(func) {\n    const found = this.ruleDict.find(x => x.func === func);\n    return found ? found.rule : null;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the from function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: FIRST_ARG_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * Array.from(arrayLike)\n   * Array.from(arrayLike, mapFn)\n   * Array.from(arrayLike, mapFn, thisArg)\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * Array.from(\"abc\", x => x + x)\n   * TAINTED(\"abc\") -> [TAINTED(\"aa\"), TAINTED(\"bb\"), TAINTED(\"cc\")]\n   * \n   * TYPE-2:\n   * RegExpStringIterator is an array-like object usually comes from the matchAll function.\n   * E.g. TAINTED(\"abcabdadc\").matchAll(/a/g)\n   * Array.from(RegExpStringIterator)\n   * TAINTED(RegExpStringIterator) -> [[TAINTED(\"a\"), index=?], [TAINTED(\"a\"), index=?], [TAINTED(\"a\"), index=?]]\n   * \n   * TYPE-3:\n   * Array.from([TAINTED(\"a\"), \"b\", \"c\"])\n   * -> [TAINTED(\"a\"), \"b\", \"c\"]\n   * \n   * @param {Function} f - The array built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   * \n   * //TODO: FORGET TO ADD THE NEW TAINT OPERATION\n   */\n  fromArrayModel(base, args, reflected, result, iid) {\n    let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.getTaintInfo(argsArray[0]);\n\n    if (!taintInfo) { return result; }\n\n    // TYPE-1\n    if (_utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.isString(argsArray[0])) {\n      for (let i = 0; i < result.length; i++) {\n        result[i] = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result[i], taintInfo);\n      }\n    }\n\n    // TYPE-2\n    else if (_utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.isRegExpStringIterator(argsArray[0])) {\n      for (let i = 0; i < result.length; i++) {\n        result[i][0] = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result[i][0], taintInfo);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the join function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED or FIRST_ARG_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * Array.prototype.join(separator)\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED([\"a\", \"b\", \"c\"]).join(\", \")\n   * -> TAINTED(\"a, b, c\")\n   * \n   * TYPE-2:\n   * TAINTED([\"a\", \"b\", \"c\"]).join(TAINTED(\", \"))\n   * -> TAINTED(\"a, b, c\")\n   * \n   * TYPE-3:\n   * The join function will call 'toString' on each element in the array.\n   * [['a', 'b'], [TAINTED('c'), 'd']].join(TAINTED(\", \"))\n   * -> TAINTED(\"a,b,c,d\")\n   * \n   * @param {Function} f - The array built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  joinArrayModel(base, args, reflected, result, iid) {\n    let taintInfo = null;\n    let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n\n    // TYPE-1\n    if (base instanceof _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__.TaintValue) {\n      taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.getTaintInfo(base);\n    }\n\n    // TYPE-2\n    if (!taintInfo && argsArray.length > 0 && argsArray[0] instanceof _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__.TaintValue) {\n      taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.getTaintInfo(argsArray[0]);\n    }\n\n    // TYPE-3\n    if (!taintInfo) {\n      taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n    }\n\n    if (taintInfo) {\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'Array:join', base, argsArray, iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n\n    return result;\n  }\n\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the toString function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * Array.prototype.toString()\n   * \n   * @example\n   * --------------------------------\n   * CASE ONE:\n   * [TAINTED(\"a\"), \"b\", \"c\"].toString()\n   * -> TAINTED(\"a,b,c\")\n   * \n   * @param {Function} f - The array built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  toStringArrayModel(base, args, reflected, result, iid) {\n    let taintInfo = null;\n    if (_utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.isArray(base)) {\n      for (let element of base) {\n        if (element instanceof _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__.TaintValue) {\n          taintInfo = element.getTaintInfo();\n          break;\n        }\n      }\n    }\n\n    if (taintInfo) {\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'Array:toString', base, [], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    \n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the toLocaleString function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * Array.prototype.toLocaleString()\n   * \n   * @example\n   * --------------------------------\n   * CASE ONE:\n   * [TAINTED(\"a\"), \"b\", \"c\"].toLocaleString()\n   * -> TAINTED(\"a,b,c\")\n   * \n   * @param {Function} f - The array built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  toLocaleStringArrayModel(base, args, reflected, result, iid) {\n    let taintInfo = null;\n    if (_utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.isArray(base)) {\n      for (let element of base) {\n        if (element instanceof _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__.TaintValue) {\n          taintInfo = element.getTaintInfo();\n          break;\n        }\n      }\n    }\n\n    if (taintInfo) {\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'Array:toLocaleString', base, [], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    \n    return result;\n  }\n}\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/rules/js-builtins/array-builtins.js?");

/***/ }),

/***/ "./src/rules/js-builtins/boolean-builtins.js":
/*!***************************************************!*\
  !*** ./src/rules/js-builtins/boolean-builtins.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BooleanBuiltinsTaintPropRules: () => (/* binding */ BooleanBuiltinsTaintPropRules)\n/* harmony export */ });\n/* harmony import */ var _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../values/wrapped-values.js */ \"./src/values/wrapped-values.js\");\n/* harmony import */ var _values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../values/taint-info.js */ \"./src/values/taint-info.js\");\n/* harmony import */ var _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../rule-builder.js */ \"./src/rules/rule-builder.js\");\n/* harmony import */ var _rule_condition_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../rule-condition.js */ \"./src/rules/rule-condition.js\");\n/* harmony import */ var _rules_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../rules.js */ \"./src/rules/rules.js\");\n/* harmony import */ var _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../taint-helper.js */ \"./src/taint-helper.js\");\n/* harmony import */ var _utils_util_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utils/util.js */ \"./src/utils/util.js\");\n\n\n\n\n\n\n\n\nclass BooleanBuiltinsTaintPropRules {\n  constructor() {\n    this.ruleDict = [];\n    this.buildRules();\n\n    if (!_utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils) {\n      J$$.analysis.logger.error('Utils is not defined');\n    }\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * We support rules for the boolean builtins that follow:\n   * 1/ The return value needs to be tainted if the boolean itself is tainted.\n   * 2/ The return value is in type of String, not Boolean.\n   * \n   * Builtins that need to be handled:\n   * - Boolean.prototype.toString\n   * \n   * @TODO\n   * --------------------------------\n   * TODO: condition check function should also be added to the rules Dict\n   * E.g. condition: BASE_TAINTED, etc.\n   */\n  supportedBooleanBuiltins = {\n    'toString': [Boolean.prototype.toString, this.toStringBooleanModel, 'BASE_TAINTED'],\n    'valueOf': [Boolean.prototype.valueOf, this.valueOfBooleanModel, 'BASE_TAINTED'],\n  };\n\n  noneAffectBuiltins = {\n  };\n\n  buildRules() {\n    for (const [fName, fGroup] of Object.entries(this.supportedBooleanBuiltins)) {\n      const condition = _rule_condition_js__WEBPACK_IMPORTED_MODULE_3__.ConditionBuilder.makeCondition(fGroup[2]);\n      const rule = _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__.RuleBuilder.makeRule(fGroup[0], condition, fGroup[1]);\n      this.addRule(fGroup[0], rule);\n    }\n\n    for (const [fName, fGroup_0] of Object.entries(this.noneAffectBuiltins)) {\n      const rule = _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__.RuleBuilder.makeNoneRule(fGroup_0);\n      this.addRule(fGroup_0, rule);\n    }\n  }\n\n  addRule(func, rule) {\n    this.ruleDict.push({ func, rule });\n  }\n\n  getRule(func) {\n    const found = this.ruleDict.find(x => x.func === func);\n    return found ? found.rule : null;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the toString function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * Boolean.prototype.toString()\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * let bool = TAINTED(true);\n   * bool.toString(); // Returns TAINTED(\"true\")\n   * \n   * @param {Object} base - The boolean object.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  toStringBooleanModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.getTaintInfo(base);\n\n    if (taintInfo) { \n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'Boolean:toString', base, [], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the valueOf function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * Boolean.prototype.valueOf()\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * let bool = TAINTED(true);\n   * bool.valueOf(); // Returns TAINTED(true)\n   * \n   * @param {Object} base - The boolean object.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  valueOfBooleanModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.getTaintInfo(base);\n\n    if (taintInfo) { \n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'Boolean:valueOf', base, [], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n\n    return result;\n  }\n}\n\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/rules/js-builtins/boolean-builtins.js?");

/***/ }),

/***/ "./src/rules/js-builtins/json-builtins.js":
/*!************************************************!*\
  !*** ./src/rules/js-builtins/json-builtins.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JSONBuiltinsRules: () => (/* binding */ JSONBuiltinsRules)\n/* harmony export */ });\n/* harmony import */ var _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../values/wrapped-values.js */ \"./src/values/wrapped-values.js\");\n/* harmony import */ var _values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../values/taint-info.js */ \"./src/values/taint-info.js\");\n/* harmony import */ var _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../rule-builder.js */ \"./src/rules/rule-builder.js\");\n/* harmony import */ var _rule_condition_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../rule-condition.js */ \"./src/rules/rule-condition.js\");\n/* harmony import */ var _rules_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../rules.js */ \"./src/rules/rules.js\");\n/* harmony import */ var _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../taint-helper.js */ \"./src/taint-helper.js\");\n/* harmony import */ var _utils_util_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utils/util.js */ \"./src/utils/util.js\");\n\n\n\n\n\n\n\n\nclass JSONBuiltinsRules {\n  constructor() {\n    this.ruleDict = [];\n    this.buildRules();\n\n    if (!_utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils) {\n      J$$.analysis.logger.error('Utils is not defined');\n    }\n  }\n\n  supportedJSONBuiltins = {\n    'parse': [JSON.parse, this.parseJSONModel, 'FIRST_ARG_TAINTED'],\n    'stringify': [JSON.stringify, this.stringifyJSONModel, 'FIRST_ARG_TAINTED_RECURSIVE'],\n  };\n\n  noneAffectBuiltins = {};\n\n  buildRules() {\n    for (const [fName, fGroup] of Object.entries(this.supportedJSONBuiltins)) {\n      const condition = _rule_condition_js__WEBPACK_IMPORTED_MODULE_3__.ConditionBuilder.makeCondition(fGroup[2]);\n      const rule = _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__.RuleBuilder.makeRule(fGroup[0], condition, fGroup[1]);\n      this.addRule(fGroup[0], rule);\n    }\n\n    for (const [fName, fGroup_0] of Object.entries(this.noneAffectBuiltins)) {\n      const rule = _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__.RuleBuilder.makeNoneRule(fGroup_0);\n      this.addRule(fGroup_0, rule);\n    }\n  }\n\n  addRule(func, rule) {\n    this.ruleDict.push({ func, rule });\n  }\n\n  getRule(func) {\n    const found = this.ruleDict.find(x => x.func === func);\n    return found ? found.rule : null;\n  }\n\n  /**\n   * @description\n   * Apply the taint propagation rule for the JSON.parse function.\n   * \n   * @condition\n   * Condition Barrier: FIRST_ARG_TAINTED\n   * \n   * @usage\n   * JSON.parse(text)\n   * JSON.parse(text, reviver)\n   * \n   * @example\n   * TYPE-1:\n   * JSON.parse(TAINTED('{\"key\": \"value\"}'))\n   * -> TAINTED({\"key\": \"value\"})\n   * \n   * @param {Function} f - The JSON built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  parseJSONModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.getTaintInfo(args[0]);\n\n    if (taintInfo) { \n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'JSON:parse', null, args, iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n\n    return result;\n  }\n\n  /**\n   * @description\n   * Apply the taint propagation rule for the JSON.stringify function.\n   * \n   * @condition\n   * Condition Barrier: BASE_TAINTED or FIRST_ARG_TAINTED\n   * \n   * @usage\n   * JSON.stringify(value)\n   * JSON.stringify(value, replacer)\n   * JSON.stringify(value, replacer, space)\n   * \n   * @example\n   * TYPE-1:\n   * JSON.stringify(TAINTED({\"key\": \"value\"}))\n   * -> TAINTED('{\"key\": \"value\"}')\n   * \n   * @param {Function} f - The JSON built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  stringifyJSONModel(base, args, reflected, result, iid) {\n    let taintInfo = null;\n    \n    if (_taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.risTainted(args[0])) {\n      taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(args[0]);\n    }\n\n    if (taintInfo) {\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'JSON:stringify', null, args, iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n\n    return result;\n  }\n}\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/rules/js-builtins/json-builtins.js?");

/***/ }),

/***/ "./src/rules/js-builtins/number-builtins.js":
/*!**************************************************!*\
  !*** ./src/rules/js-builtins/number-builtins.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NumberBuiltinsTaintPropRules: () => (/* binding */ NumberBuiltinsTaintPropRules)\n/* harmony export */ });\n/* harmony import */ var _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../values/wrapped-values.js */ \"./src/values/wrapped-values.js\");\n/* harmony import */ var _values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../values/taint-info.js */ \"./src/values/taint-info.js\");\n/* harmony import */ var _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../rule-builder.js */ \"./src/rules/rule-builder.js\");\n/* harmony import */ var _rule_condition_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../rule-condition.js */ \"./src/rules/rule-condition.js\");\n/* harmony import */ var _rules_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../rules.js */ \"./src/rules/rules.js\");\n/* harmony import */ var _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../taint-helper.js */ \"./src/taint-helper.js\");\n/* harmony import */ var _utils_util_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utils/util.js */ \"./src/utils/util.js\");\n\n\n\n\n\n\n\n\nclass NumberBuiltinsTaintPropRules {\n  constructor() {\n    this.ruleDict = [];\n    this.buildRules();\n\n    if (!_utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils) {\n      J$$.analysis.logger.error('Utils is not defined');\n    }\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * We support rules for the number builtins that follow:\n   * 1/ The return value needs to be tainted if the number itself is tainted.\n   * 2/ The return value is in type of String, not Boolean.\n   * \n   * Builtins that need to be handled:\n   * - Number.prototype.toString\n   * \n   * @TODO\n   * --------------------------------\n   * TODO: condition check function should also be added to the rules Dict\n   * E.g. condition: BASE_TAINTED, etc.\n   */\n  supportedNumberBuiltins = {\n    'toString': [Number.prototype.toString, this.toStringNumberModel, 'BASE_TAINTED'],\n    'valueOf': [Number.prototype.valueOf, this.valueOfNumberModel, 'BASE_TAINTED'],\n  };\n\n  noneAffectBuiltins = {\n  };\n\n  buildRules() {\n    for (const [fName, fGroup] of Object.entries(this.supportedNumberBuiltins)) {\n      const condition = _rule_condition_js__WEBPACK_IMPORTED_MODULE_3__.ConditionBuilder.makeCondition(fGroup[2]);\n      const rule = _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__.RuleBuilder.makeRule(fGroup[0], condition, fGroup[1]);\n      this.addRule(fGroup[0], rule);\n    }\n\n    for (const [fName, fGroup_0] of Object.entries(this.noneAffectBuiltins)) {\n      const rule = _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__.RuleBuilder.makeNoneRule(fGroup_0);\n      this.addRule(fGroup_0, rule);\n    }\n  }\n\n  addRule(func, rule) {\n    this.ruleDict.push({ func, rule });\n  }\n\n  getRule(func) {\n    const found = this.ruleDict.find(x => x.func === func);\n    return found ? found.rule : null;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the toString function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * Number.prototype.toString()\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * let num = TAINTED(123);\n   * num.toString(); // Returns TAINTED(\"123\")\n   * \n   * @param {Object} base - The number object.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  toStringNumberModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.getTaintInfo(base);\n\n    if (taintInfo) { \n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'Number:toString', base, [], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the valueOf function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * Number.prototype.valueOf()\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * let num = TAINTED(123);\n   * num.valueOf(); // Returns TAINTED(123)\n   * \n   * @param {Object} base - The number object.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  valueOfNumberModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.getTaintInfo(base);\n\n    if (taintInfo) { \n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'Number:valueOf', base, [], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n\n    return result;\n  }\n}\n\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/rules/js-builtins/number-builtins.js?");

/***/ }),

/***/ "./src/rules/js-builtins/object-builtins.js":
/*!**************************************************!*\
  !*** ./src/rules/js-builtins/object-builtins.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ObjectBuiltinsTaintPropRules: () => (/* binding */ ObjectBuiltinsTaintPropRules)\n/* harmony export */ });\n/* harmony import */ var _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../values/wrapped-values.js */ \"./src/values/wrapped-values.js\");\n/* harmony import */ var _values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../values/taint-info.js */ \"./src/values/taint-info.js\");\n/* harmony import */ var _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../rule-builder.js */ \"./src/rules/rule-builder.js\");\n/* harmony import */ var _rule_condition_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../rule-condition.js */ \"./src/rules/rule-condition.js\");\n/* harmony import */ var _rules_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../rules.js */ \"./src/rules/rules.js\");\n/* harmony import */ var _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../taint-helper.js */ \"./src/taint-helper.js\");\n/* harmony import */ var _utils_util_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utils/util.js */ \"./src/utils/util.js\");\n\n\n\n\n\n\n\n\nclass ObjectBuiltinsTaintPropRules {\n  constructor() {\n    this.ruleDict = [];\n    this.buildRules();\n\n    if (!_utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils) {\n      J$$.analysis.logger.error('Utils is not defined');\n    }\n  }\n\n  /**\n   * For object built-ins, we select the builtins that will load values from the object.\n   * And if the object itself is tainted, we propagate the taint to the result.\n   * We don't worry about the values inside the object.\n   */\n  supportedObjectBuiltins = {\n    'assign': [Object.assign, this.assignObjectModel, 'ANY_ARGS_TAINTED'],\n    'fromEntries': [Object.fromEntries, this.fromEntriesObjectModel, 'FIRST_ARG_TAINTED'],\n    'entries': [Object.entries, this.entriesObjectModel, 'FIRST_ARG_TAINTED'],\n    'values': [Object.values, this.valuesObjectModel, 'FIRST_ARG_TAINTED'],\n  };\n\n  noneAffectBuiltins = {\n    'keys': Object.keys,\n    'defineProperty': Object.defineProperty,\n    'defineProperties': Object.defineProperties,\n    'setPrototypeOf': Object.setPrototypeOf\n  };\n\n  buildRules() {\n    for (const [fName, fGroup] of Object.entries(this.supportedObjectBuiltins)) {\n      const condition = _rule_condition_js__WEBPACK_IMPORTED_MODULE_3__.ConditionBuilder.makeCondition(fGroup[2]);\n      const rule = _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__.RuleBuilder.makeRule(fGroup[0], condition, fGroup[1]);\n      this.addRule(fGroup[0], rule);\n    }\n\n    for (const [fName, fGroup_0] of Object.entries(this.noneAffectBuiltins)) {\n      const rule = _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__.RuleBuilder.makeNoneRule(fGroup_0);\n      this.addRule(fGroup_0, rule);\n    }\n  }\n\n  addRule(func, rule) {\n    this.ruleDict.push({ func, rule });\n  }\n\n  getRule(func) {\n    const found = this.ruleDict.find(x => x.func === func);\n    return found ? found.rule : null;\n  }\n\n   /**\n   * @description\n   * Apply the taint propagation rule for the Object.assign function.\n   * \n   * @condition\n   * Condition Barrier: ANY_ARGS_TAINTED\n   * \n   * @usage\n   * Object.assign(target, ...sources)\n   * \n   * @example\n   * TYPE-1:\n   * Object.assign({}, TAINTED({a: 1}))\n   * -> TAINTED({a: 1})\n   * \n   * @param {Function} f - The Object built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n   assignObjectModel(base, args, reflected, result, iid) {\n    let taintInfo = null;\n    \n    // Skip the first argument which is the target object\n    for (let i = 1; i < args.length; i++) {\n      if (_taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.isTainted(args[i])) {\n        taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.getTaintInfo(args[i]);\n        break;\n      }\n    }\n\n    if (taintInfo) {\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'Object:assign', null, args, iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * Apply the taint propagation rule for the Object.fromEntries function.\n   * \n   * @condition\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * Object.fromEntries(iterable)\n   * \n   * @example\n   * TYPE-1:\n   * Object.fromEntries(TAINTED([['a', 1], ['b', 2]]))\n   * -> TAINTED({a: 1, b: 2})\n   * \n   * @param {Function} f - The Object built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  fromEntriesObjectModel(base, args, reflected, result, iid) {\n    if (_taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.isTainted(args[0])) {\n      let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.getTaintInfo(args[0]);\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'Object:fromEntries', null, args, iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * Apply the taint propagation rule for the Object.entries function.\n   * \n   * @condition\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * Object.entries(obj)\n   * \n   * @example\n   * TYPE-1:\n   * Object.entries(TAINTED({a: 1, b: 2}))\n   * -> TAINTED([[\"a\", 1], [\"b\", 2]])\n   * \n   * @param {Function} f - The Object built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  entriesObjectModel(base, args, reflected, result, iid) {\n    if (_taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.isTainted(args[0])) {\n      let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.getTaintInfo(args[0]);\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'Object:entries', null, args, iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * Apply the taint propagation rule for the Object.values function.\n   * \n   * @condition\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * Object.values(obj)\n   * \n   * @example\n   * TYPE-1:\n   * Object.values(TAINTED({a: 1, b: 2}))\n   * -> TAINTED([1, 2])\n   * \n   * @param {Function} f - The Object built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  valuesObjectModel(base, args, reflected, result, iid) {\n    if (_taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.isTainted(args[0])) {\n      let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.getTaintInfo(args[0]);\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'Object:values', null, args, iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    return result;\n  }\n\n  // ToString, fill me!\n}\n\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/rules/js-builtins/object-builtins.js?");

/***/ }),

/***/ "./src/rules/js-builtins/proxy-builtins.js":
/*!*************************************************!*\
  !*** ./src/rules/js-builtins/proxy-builtins.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ProxyBuiltinsTaintPropRules: () => (/* binding */ ProxyBuiltinsTaintPropRules)\n/* harmony export */ });\n/* harmony import */ var _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../values/wrapped-values.js */ \"./src/values/wrapped-values.js\");\n/* harmony import */ var _values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../values/taint-info.js */ \"./src/values/taint-info.js\");\n/* harmony import */ var _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../rule-builder.js */ \"./src/rules/rule-builder.js\");\n/* harmony import */ var _rule_condition_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../rule-condition.js */ \"./src/rules/rule-condition.js\");\n/* harmony import */ var _rules_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../rules.js */ \"./src/rules/rules.js\");\n/* harmony import */ var _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../taint-helper.js */ \"./src/taint-helper.js\");\n/* harmony import */ var _utils_util_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utils/util.js */ \"./src/utils/util.js\");\n\n\n\n\n\n\n\n\nclass ProxyBuiltinsTaintPropRules {\n  constructor() {\n    this.ruleDict = [];\n    this.buildRules();\n    this.proxyTag = Symbol('proxy');\n\n    if (!_utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils) {\n      J$$.analysis.logger.error('Utils is not defined');\n    }\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Define Proxy traps that are affected by taint and need custom handling.\n   * \n   */\n  supportedProxyBuiltins = {\n    // 'Proxy': [Proxy, this.ProxyConstructorModel, 'ALL'],\n  };\n\n  /**\n   * @description\n   * --------------------------------\n   * Here is a list of built-ins that use none affected taint propagation rules.\n   * \n   * These built-ins will not affect taint propagation even if their arguments are tainted.\n   * This explicit list helps in preventing the invocation of taint logic unnecessarily.\n   */\n  noneAffectBuiltins = {\n    'Proxy': Proxy,\n    'Proxy.revocable': Proxy.revocable\n  };\n\n  buildRules() {\n    for (const [fName, fGroup] of Object.entries(this.supportedProxyBuiltins)) {\n      const condition = _rule_condition_js__WEBPACK_IMPORTED_MODULE_3__.ConditionBuilder.makeCondition(fGroup[2]);\n      const rule = _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__.RuleBuilder.makeRule(fGroup[0], condition, fGroup[1]);\n      this.addRule(fGroup[0], rule);\n    }\n\n    for (const [fName, fGroup_0] of Object.entries(this.noneAffectBuiltins)) {\n      if (fName === \"Proxy\") {\n        const rule = _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__.RuleBuilder.makeNoneRuleForConstructor(fGroup_0);\n        this.addRule(fGroup_0, rule);\n        continue;\n      }\n      const rule = _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__.RuleBuilder.makeRule(fGroup_0);\n      this.addRule(fGroup_0, rule);\n    }\n  }\n\n  addRule(func, rule) {\n    this.ruleDict.push({ func, rule });\n  }\n\n  getRule(func) {\n    const found = this.ruleDict.find(x => x.func === func);\n    return found ? found.rule : null;\n  }\n\n}\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/rules/js-builtins/proxy-builtins.js?");

/***/ }),

/***/ "./src/rules/js-builtins/reflect-builtins.js":
/*!***************************************************!*\
  !*** ./src/rules/js-builtins/reflect-builtins.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ReflectBuiltinsTaintPropRules: () => (/* binding */ ReflectBuiltinsTaintPropRules)\n/* harmony export */ });\n/* harmony import */ var _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../values/wrapped-values.js */ \"./src/values/wrapped-values.js\");\n/* harmony import */ var _values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../values/taint-info.js */ \"./src/values/taint-info.js\");\n/* harmony import */ var _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../rule-builder.js */ \"./src/rules/rule-builder.js\");\n/* harmony import */ var _rule_condition_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../rule-condition.js */ \"./src/rules/rule-condition.js\");\n/* harmony import */ var _rules_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../rules.js */ \"./src/rules/rules.js\");\n/* harmony import */ var _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../taint-helper.js */ \"./src/taint-helper.js\");\n/* harmony import */ var _utils_util_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utils/util.js */ \"./src/utils/util.js\");\n\n\n\n\n\n\n\n\nclass ReflectBuiltinsTaintPropRules {\n  constructor() {\n    this.ruleDict = [];\n    this.buildRules();\n\n    if (!_utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils) {\n      J$$.analysis.logger.error('Utils is not defined');\n    }\n  }\n\n  /**\n   * Define Reflect built-ins that are affected by taint and need custom handling.\n   */\n  supportedReflectBuiltins = {\n    'get': [Reflect.get, this.getReflectModel, 'FIRST_ARG_TAINTED'],\n  };\n\n  noneAffectBuiltins = {\n    'set': Reflect.set,\n    'apply': Reflect.apply,\n    'ownKeys':  Reflect.ownKeys,\n    'isExtensible': Reflect.isExtensible,\n    'preventExtensions':  Reflect.preventExtensions,\n  };\n\n  buildRules() {\n    for (const [fName, fGroup] of Object.entries(this.supportedReflectBuiltins)) {\n      const condition = _rule_condition_js__WEBPACK_IMPORTED_MODULE_3__.ConditionBuilder.makeCondition(fGroup[2]);\n      const rule = _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__.RuleBuilder.makeRule(fGroup[0], condition, fGroup[1]);\n      this.addRule(fGroup[0], rule);\n    }\n\n    for (const [fName, fGroup_0] of Object.entries(this.noneAffectBuiltins)) {\n      const rule = _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__.RuleBuilder.makeNoneRule(fGroup_0);\n      this.addRule(fGroup_0, rule);\n    }\n  }\n\n  addRule(func, rule) {\n    this.ruleDict.push({ func, rule });\n  }\n\n  getRule(func) {\n    const found = this.ruleDict.find(x => x.func === func);\n    return found ? found.rule : null;\n  }\n\n  /**\n   * @description\n   * Apply the taint propagation rule for the Proxy 'get' trap.\n   * \n   * @condition\n   * Condition Barrier: BASE_TAINTED_OR_PROP_TAINTED\n   * \n   * @usage\n   * Reflect.get(target, propertyKey, receiver)\n   * \n   * @example\n   * TYPE-1:\n   * Reflect.get(TAINTED(target), \"prop\")\n   * -> TAINTED(value)\n   * \n   * @param {Object} target - The target object.\n   * @param {String} property - The property name.\n   * @param {Object} receiver - The receiver object.\n   * @param {*} result - The result of the get operation.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  getReflectModel(base, args, reflected, result, iid) {\n    if (_taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.isTainted(args[0])) {\n      let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.getTaintInfo(args[0]);\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'Proxy:get', property, [target, property, receiver], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    return result;\n  }\n}\n\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/rules/js-builtins/reflect-builtins.js?");

/***/ }),

/***/ "./src/rules/js-builtins/regexp-builtins.js":
/*!**************************************************!*\
  !*** ./src/rules/js-builtins/regexp-builtins.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RegExpBuiltinsRules: () => (/* binding */ RegExpBuiltinsRules)\n/* harmony export */ });\n/* harmony import */ var _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../values/wrapped-values.js */ \"./src/values/wrapped-values.js\");\n/* harmony import */ var _values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../values/taint-info.js */ \"./src/values/taint-info.js\");\n/* harmony import */ var _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../rule-builder.js */ \"./src/rules/rule-builder.js\");\n/* harmony import */ var _rule_condition_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../rule-condition.js */ \"./src/rules/rule-condition.js\");\n/* harmony import */ var _rules_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../rules.js */ \"./src/rules/rules.js\");\n/* harmony import */ var _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../taint-helper.js */ \"./src/taint-helper.js\");\n/* harmony import */ var _utils_util_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utils/util.js */ \"./src/utils/util.js\");\n\n\n\n\n\n\n\n\nclass RegExpBuiltinsRules {\n  constructor() {\n    this.ruleDict = [];\n    this.buildRules();\n\n    if (!_utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils) {\n      J$$.analysis.logger.error('Utils is not defined');\n    }\n  }\n\n  supportedRegExpBuiltins = {\n    'exec': [RegExp.prototype.exec, this.execRegExpModel, 'FIRST_ARG_TAINTED'],\n    'test': [RegExp.prototype.test, this.testRegExpModel, 'FIRST_ARG_TAINTED']\n  };\n\n  noneAffectBuiltins = {};\n\n  buildRules() {\n    for (const [fName, fGroup] of Object.entries(this.supportedRegExpBuiltins)) {\n      const condition = _rule_condition_js__WEBPACK_IMPORTED_MODULE_3__.ConditionBuilder.makeCondition(fGroup[2]);\n      const rule = _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__.RuleBuilder.makeRule(fGroup[0], condition, fGroup[1]);\n      this.addRule(fGroup[0], rule);\n    }\n\n    for (const [fName, fGroup_0] of Object.entries(this.noneAffectBuiltins)) {\n      const rule = _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__.RuleBuilder.makeNoneRule(fGroup_0);\n      this.addRule(fGroup_0, rule);\n    }\n  }\n\n  addRule(func, rule) {\n    this.ruleDict.push({ func, rule });\n  }\n\n  getRule(func) {\n    const found = this.ruleDict.find(x => x.func === func);\n    return found ? found.rule : null;\n  }\n\n  /**\n   * @description\n   * Apply the taint propagation rule for the RegExp.prototype.exec function.\n   * \n   * @condition\n   * Condition Barrier: FIRST_ARG_TAINTED\n   * \n   * @usage\n   * RegExp.prototype.exec(str)\n   * \n   * @example\n   * TYPE-1:\n   * /abc/.exec(TAINTED(\"abcdef\"))\n   * -> TAINTED([\"abc\"])\n   * \n   * @param {Function} f - The RegExp built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  execRegExpModel(base, args, reflected, result, iid) {\n    let taintInfo = null;\n\n    if (args.length > 0 && _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.isTainted(args[0])) {\n      taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.getTaintInfo(args[0]);\n    }\n\n    if (taintInfo) {\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'RegExp:exec', null, args, iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n\n    return result;\n  }\n\n  /**\n   * @description\n   * Apply the taint propagation rule for the RegExp.prototype.test function.\n   * \n   * @condition\n   * Condition Barrier: FIRST_ARG_TAINTED\n   * \n   * @usage\n   * RegExp.prototype.test(str)\n   * \n   * @example\n   * TYPE-1:\n   * /abc/.test(TAINTED(\"abcdef\"))\n   * -> TAINTED(true)\n   * \n   * @param {Function} f - The RegExp built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  testRegExpModel(base, args, reflected, result, iid) {\n    let taintInfo = null;\n\n    if (args.length > 0 && _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.isTainted(args[0])) {\n      taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.getTaintInfo(args[0]);\n    }\n\n    if (taintInfo) {\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'RegExp:test', null, args, iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n\n    return result;\n  }\n}\n\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/rules/js-builtins/regexp-builtins.js?");

/***/ }),

/***/ "./src/rules/js-builtins/string-builtins.js":
/*!**************************************************!*\
  !*** ./src/rules/js-builtins/string-builtins.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StringBuiltinsTaintPropRules: () => (/* binding */ StringBuiltinsTaintPropRules)\n/* harmony export */ });\n/* harmony import */ var _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../values/wrapped-values.js */ \"./src/values/wrapped-values.js\");\n/* harmony import */ var _values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../values/taint-info.js */ \"./src/values/taint-info.js\");\n/* harmony import */ var _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../rule-builder.js */ \"./src/rules/rule-builder.js\");\n/* harmony import */ var _rule_condition_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../rule-condition.js */ \"./src/rules/rule-condition.js\");\n/* harmony import */ var _rules_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../rules.js */ \"./src/rules/rules.js\");\n/* harmony import */ var _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../taint-helper.js */ \"./src/taint-helper.js\");\n/* harmony import */ var _utils_util_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utils/util.js */ \"./src/utils/util.js\");\n\n\n\n\n\n\n\n\nclass StringBuiltinsTaintPropRules {\n  constructor() {\n    this.ruleDict = [];\n    this.buildRules();\n\n    if (!_utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils) {\n      J$$.analysis.logger.error('Utils is not defined');\n    }\n  }\n\n  supportedStringBuiltins = {\n    'String': [String, this.StringConstructorModel, 'FIRST_ARG_TAINTED'],\n\n    // Base or any argument is tainted\n    'at': [String.prototype.at, this.atStringModel, 'BASE_TAINTED || ANY_ARGS_TAINTED'],\n    'charAt': [String.prototype.charAt, this.charAtStringModel, 'BASE_TAINTED || ANY_ARGS_TAINTED'],\n    'replace': [String.prototype.replace, this.replaceStringModel, 'BASE_TAINTED || ANY_ARGS_TAINTED'],\n    'replaceAll': [String.prototype.replaceAll, this.replaceAllStringModel, 'BASE_TAINTED || ANY_ARGS_TAINTED'],\n    'concat': [String.prototype.concat, this.concatStringModel, 'BASE_TAINTED || ANY_ARGS_TAINTED'],\n\n    // Only base must be tainted\n    'charCodeAt': [String.prototype.charCodeAt, this.charCodeAtStringModel, 'BASE_TAINTED'],\n    'codePointAt': [String.prototype.codePointAt, this.codePointAtStringModel, 'BASE_TAINTED'],\n    'localeCompare': [String.prototype.localeCompare, this.localeCompareStringModel, 'BASE_TAINTED'],\n    'match': [String.prototype.match, this.matchStringModel, 'BASE_TAINTED'],\n    'matchAll': [String.prototype.matchAll, this.matchAllStringModel, 'BASE_TAINTED'],\n    'replace': [String.prototype.replace, this.replaceStringModel, 'BASE_TAINTED'],\n    'replaceAll': [String.prototype.replaceAll, this.replaceAllStringModel, 'BASE_TAINTED'],\n    'search': [String.prototype.search, this.searchStringModel, 'BASE_TAINTED'],\n    'slice': [String.prototype.slice, this.sliceStringModel, 'BASE_TAINTED'],\n    'substr':  [String.prototype.substr, this.substrStringModel, 'BASE_TAINTED'],\n    'substring': [String.prototype.substring, this.substringStringModel, 'BASE_TAINTED'],\n    'split': [String.prototype.split, this.splitStringModel, 'BASE_TAINTED'],\n    'startsWith': [String.prototype.startsWith, this.startsWithStringModel, 'BASE_TAINTED'],\n    'toLocaleLowerCase': [String.prototype.toLocaleLowerCase, this.toLocaleLowerCaseStringModel, 'BASE_TAINTED'],\n    'toLocaleUpperCase': [String.prototype.toLocaleUpperCase, this.toLocaleUpperCaseStringModel, 'BASE_TAINTED'],\n    'toLowerCase': [String.prototype.toLowerCase, this.toLowerCaseStringModel, 'BASE_TAINTED'],\n    'toString': [String.prototype.toString, this.toStringStringModel, 'BASE_TAINTED'],\n    'toUpperCase': [String.prototype.toUpperCase, this.toUpperCaseStringModel, 'BASE_TAINTED'],\n    'toWellFormed': [String.prototype.toWellFormed, this.toWellFormedStringModel, 'BASE_TAINTED'],\n    'endsWith': [String.prototype.endsWith, this.endsWithStringModel, 'BASE_TAINTED'],\n    'includes': [String.prototype.includes, this.includesStringModel, 'BASE_TAINTED'],\n    'indexOf': [String.prototype.indexOf, this.indexOfStringModel, 'BASE_TAINTED'],\n    'isWellFormed': [String.prototype.isWellFormed, this.isWellFormedStringModel, 'BASE_TAINTED'],\n    'lastIndexOf': [String.prototype.lastIndexOf, this.lastIndexOfStringModel, 'BASE_TAINTED'],\n    'trim': [String.prototype.trim, this.trimStringModel, 'BASE_TAINTED'],\n    'trimEnd': [String.prototype.trimEnd, this.trimEndStringModel, 'BASE_TAINTED'],\n    'trimStart': [String.prototype.trimStart, this.trimStartStringModel, 'BASE_TAINTED'],\n    'valueOf': [String.prototype.valueOf, this.valueOfStringModel, 'BASE_TAINTED'],\n    'normalize': [String.prototype.normalize, this.normalizeStringModel, 'BASE_TAINTED'],\n    'padEnd': [String.prototype.padEnd, this.padEndStringModel, 'BASE_TAINTED'],\n    'padStart': [String.prototype.padStart, this.padStartStringModel, 'BASE_TAINTED'],\n    'repeat': [String.prototype.repeat, this.repeatStringModel, 'BASE_TAINTED'],\n\n    // Arguments only\n    // 'String': [String, this.StringModel, 'FIRST_ARGS_TAINTED'],\n    'raw': [String.raw, this.rawStringModel, 'ANY_ARGS_TAINTED'],\n    'fromCharCode': [String.fromCharCode, this.fromCharCodeStringModel, 'ANY_ARGS_TAINTED'],\n    'fromCodePoint': [String.fromCodePoint, this.fromCodePointStringModel, 'ANY_ARGS_TAINTED'],\n  };\n\n  /**\n   * @description\n   * --------------------------------\n   * Build rules for each String builtin functions.\n   * Add the rule functions to the ruleDict.\n   */\n  buildRules() {\n    for (const [fName, fGroup] of Object.entries(this.supportedStringBuiltins)) {\n      if (fName === 'String') {\n        const condition = _rule_condition_js__WEBPACK_IMPORTED_MODULE_3__.ConditionBuilder.makeCondition(fGroup[2]);\n        const rule = _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__.RuleBuilder.makeRuleForConstructor(fGroup[0], condition, fGroup[1]);\n        this.addRule(fGroup[0], rule);\n        continue;\n      }\n\n      const condition = _rule_condition_js__WEBPACK_IMPORTED_MODULE_3__.ConditionBuilder.makeCondition(fGroup[2]);\n      const rule = _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__.RuleBuilder.makeRule(fGroup[0], condition, fGroup[1]);\n      this.addRule(fGroup[0], rule);\n    }\n  }\n\n\n  /**\n   * @description\n   * --------------------------------\n   * Adds a rule to the rule dictionary.\n   * \n   * @param {Function} function - The builtin function.\n   * @param {Function} rule - The rule function to be added.\n   */\n  addRule(func, rule) {\n    this.ruleDict.push({func, rule});\n  }\n\n\n  /**\n   * @description\n   * --------------------------------\n   * Retrieves a rule for the specified putField operator.\n   * \n   * Currently, we propagate all the property lookups all the from a TaintValue\n   * Therefore, we return the rule with the key ('all', 'all')\n   * \n   * @param {string} operator - The unary operator.\n   * @returns {Function|null} The rule function if found, otherwise null.\n   */\n  getRule(func) {\n    const found = this.ruleDict.find(x => x.func === func);\n    return found ? found.rule : null;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the String constructor.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: FIRST_ARG_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * new String(value)\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * new String(TAINTED(\"Hello\"))\n   * -> TAINTED(\"Hello\")\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  StringConstructorModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.getTaintInfo(args[0]);\n    let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n    if (taintInfo) {\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'String:constructor', base, argsArray, iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the fromCharCode function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: ANY_ARGS_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * String.fromCharCode(num1, num2, ..., numN)\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * String.fromCharCode(TAINTED(65), 66)\n   * -> TAINTED(\"AB\")\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  fromCharCodeStringModel(base, args, reflected, result, iid) {\n    let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(argsArray);\n\n    if (taintInfo) {\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'String:fromCharCode', base, argsArray, iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    return result;\n  }\n\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the at function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED or ANY_ARGS_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.at(index)\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"abcdef\").at(2)\n   * -> TAINTED(\"c\")\n   * \n   * TYPE-2:\n   * \"abcdef\".at(TAINTED(2))\n   * -> TAINTED(\"c\")\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  atStringModel(base, args, reflected, result, iid) {\n    let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base) || _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(argsArray);\n\n    if (taintInfo) {\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'String:at', base, argsArray, iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the fromCodePoint function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: ANY_ARGS_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * String.fromCodePoint(num1, num2, ..., numN)\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * String.fromCodePoint(TAINTED(65), 66)\n   * -> TAINTED(\"AB\")\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  fromCodePointStringModel(base, args, reflected, result, iid) {\n    let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(argsArray);\n\n    if (taintInfo) {\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'String:fromCodePoint', base, argsArray, iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the raw function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: ANY_ARGS_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * String.raw(template, ...substitutions)\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(String.raw`Hello ${'world'}`)\n   * -> TAINTED(\"Hello world\")\n   * \n   * TYPE-2:\n   * String.raw`Hello ${TAINTED('world')}`\n   * -> TAINTED(\"Hello world\")\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  rawStringModel(base, args, reflected, result, iid) {\n    let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(argsArray);\n\n    if (taintInfo) {\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'String:raw', base, argsArray, iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the charAt function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED or ANY_ARGS_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.charAt(index)\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"abcdef\").charAt(2)\n   * -> TAINTED(\"c\")\n   * \n   * TYPE-2:\n   * \"abcdef\".charAt(TAINTED(2))\n   * -> TAINTED(\"c\")\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  charAtStringModel(base, args, reflected, result, iid) {\n    let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base) || _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(argsArray);\n\n    if (taintInfo) {\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'String:charAt', base, argsArray, iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the charCodeAt function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.charCodeAt(index)\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"abcdef\").charCodeAt(2)\n   * -> TAINTED(99)\n   * \n   * TYPE-2:\n   * \"abcdef\".charCodeAt(2)\n   * -> 99\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  charCodeAtStringModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n\n    if (taintInfo) {\n      let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'String:charCodeAt', base, argsArray, iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the codePointAt function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.codePointAt(pos)\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"abc\").codePointAt(1)\n   * -> TAINTED(98)\n   * \n   * TYPE-2:\n   * \"abc\".codePointAt(1)\n   * -> 98\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  codePointAtStringModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n\n    if (taintInfo) {\n      let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'String:codePointAt', base, argsArray, iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the concat function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED or ANY_ARGS_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * concat(str1, str2, ..., strN)\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"a\").concat(\"b\", \"c\")\n   * -> TAINTED(\"a,b,c\")\n   * \n   * TYPE-2:\n   * \"a\".concat(TAINTED(\"b\"), \"c\")\n   * -> TAINTED(\"a,b,c\")\n   * \n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  concatStringModel(base, args, reflected, result, iid) {\n    let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n    if (!taintInfo) {\n      taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(argsArray);\n    }\n\n    if (taintInfo) {\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'String:concat', base, argsArray, iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the endsWith function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.endsWith(searchString, [position])\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"Hello world\").endsWith(\"world\")\n   * -> TAINTED(true)\n   * \n   * TYPE-2:\n   * \"Hello world\".endsWith(TAINTED(\"world\"))\n   * -> true\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  endsWithStringModel(base, args, reflected, result, iid) {\n    if (_taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base)) {\n      const taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n      let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'String:endsWith', base, argsArray, iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the includes function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.includes(searchString, [position])\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"Hello world\").includes(\"world\")\n   * -> TAINTED(true)\n   * \n   * TYPE-2:\n   * \"Hello world\".includes(TAINTED(\"world\"))\n   * -> true\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  includesStringModel(base, args, reflected, result, iid) {\n    if (_taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base)) {\n      const taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n      let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'String:includes', base, argsArray, iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the indexOf function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.indexOf(searchValue, [fromIndex])\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"Hello world\").indexOf(\"world\")\n   * -> TAINTED(6)\n   * \n   * TYPE-2:\n   * \"Hello world\".indexOf(TAINTED(\"world\"))\n   * -> 6\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  indexOfStringModel(base, args, reflected, result, iid) {\n    if (_taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base)) {\n      const taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n      let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'String:indexOf', base, argsArray, iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the isWellFormed function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.isWellFormed()\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"Hello world\").isWellFormed()\n   * -> TAINTED(true)\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  isWellFormedStringModel(base, args, reflected, result, iid) {\n    if (_taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base)) {\n      const taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n      let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'String:isWellFormed', base, argsArray, iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the lastIndexOf function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.lastIndexOf(searchValue, [fromIndex])\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"Hello world\").lastIndexOf(\"world\")\n   * -> TAINTED(6)\n   * \n   * TYPE-2:\n   * \"Hello world\".lastIndexOf(TAINTED(\"world\"))\n   * -> 6\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  lastIndexOfStringModel(base, args, reflected, result, iid) {\n    if (_taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base)) {\n      const taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n      let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'String:lastIndexOf', base, argsArray, iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the localeCompare function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED or FIRST_ARG_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.localeCompare(compareString, locales, options)\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"a\").localeCompare(\"b\")\n   * -> TAINTED(-1)\n   * \n   * TYPE-2:\n   * \"a\".localeCompare(TAINTED(\"b\"))\n   * -> TAINTED(-1)\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  localeCompareStringModel(base, args, reflected, result, iid) {\n    let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base) || _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(argsArray[0]);\n\n    if (taintInfo) {\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'String:localeCompare', base, argsArray, iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the match function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED or FIRST_ARG_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.match(regexp)\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"hello world\").match(/world/)\n   * -> TAINTED([\"world\"])\n   * \n   * TYPE-2:\n   * \"hello world\".match(TAINTED(/world/))\n   * -> TAINTED([\"world\"])\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  matchStringModel(base, args, reflected, result, iid) {\n    let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base) || _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(argsArray[0]);\n\n    if (taintInfo) {\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'String:match', base, argsArray, iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the matchAll function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED or FIRST_ARG_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.matchAll(regexp)\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"hello world\").matchAll(/world/)\n   * -> TAINTED([\"world\"])\n   * \n   * TYPE-2:\n   * \"hello world\".matchAll(TAINTED(/world/))\n   * -> TAINTED([\"world\"])\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  matchAllStringModel(base, args, reflected, result, iid) {\n    let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base) || _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(argsArray[0]);\n\n    if (taintInfo) {\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'String:matchAll', base, argsArray, iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the normalize function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.normalize([form])\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"Hello world\").normalize()\n   * -> TAINTED(\"Hello world\")\n   * \n   * TYPE-2:\n   * \"Hello world\".normalize()\n   * -> \"Hello world\"\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  normalizeStringModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n\n    if (taintInfo) {\n      let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'String:normalize', base, argsArray, iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the padEnd function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.padEnd(targetLength, [padString])\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"abc\").padEnd(6)\n   * -> TAINTED(\"abc   \")\n   * \n   * TYPE-2:\n   * \"abc\".padEnd(6, TAINTED(\" \"))\n   * -> \"abc   \"\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  padEndStringModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n\n    if (taintInfo) {\n      let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'String:padEnd', base, argsArray, iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the padStart function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.padStart(targetLength, [padString])\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"abc\").padStart(6)\n   * -> TAINTED(\"   abc\")\n   * \n   * TYPE-2:\n   * \"abc\".padStart(6, TAINTED(\" \"))\n   * -> \"   abc\"\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  padStartStringModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n\n    if (taintInfo) {\n      let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'String:padStart', base, argsArray, iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the repeat function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.repeat(count)\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"abc\").repeat(2)\n   * -> TAINTED(\"abcabc\")\n   * \n   * TYPE-2:\n   * \"abc\".repeat(TAINTED(2))\n   * -> \"abcabc\"\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  repeatStringModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n\n    if (taintInfo) {\n      let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'String:repeat', base, argsArray, iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the replace function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED or ANY_ARGS_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.replace(regexp|substr, newSubstr|function)\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"Hello world\").replace(\"world\", \"universe\")\n   * -> TAINTED(\"Hello universe\")\n   * \n   * TYPE-2:\n   * \"Hello world\".replace(TAINTED(\"world\"), \"universe\")\n   * -> TAINTED(\"Hello universe\")\n   * \n   * TYPE-3:\n   * \"Hello world\".replace(\"world\", TAINTED(\"universe\"))\n   * -> TAINTED(\"Hello universe\")\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  replaceStringModel(base, args, reflected, result, iid) {\n    let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base) || _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(argsArray);\n\n    if (taintInfo) {\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'String:replace', base, argsArray, iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the replaceAll function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED or ANY_ARGS_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.replaceAll(regexp|substr, newSubstr|function)\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"Hello world world\").replaceAll(\"world\", \"universe\")\n   * -> TAINTED(\"Hello universe universe\")\n   * \n   * TYPE-2:\n   * \"Hello world world\".replaceAll(TAINTED(\"world\"), \"universe\")\n   * -> TAINTED(\"Hello universe universe\")\n   * \n   * TYPE-3:\n   * \"Hello world world\".replaceAll(\"world\", TAINTED(\"universe\"))\n   * -> TAINTED(\"Hello universe universe\")\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  replaceAllStringModel(base, args, reflected, result, iid) {\n    let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base) || _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(argsArray);\n\n    if (taintInfo) {\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'String:replaceAll', base, argsArray, iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the search function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.search(regexp)\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"Hello world\").search(/world/)\n   * -> TAINTED(6)\n   * \n   * TYPE-2:\n   * \"Hello world\".search(TAINTED(/world/))\n   * -> 6\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  searchStringModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n\n    if (taintInfo) {\n      let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'String:search', base, argsArray, iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the slice function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.slice(beginIndex, [endIndex])\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"Hello world\").slice(0, 5)\n   * -> TAINTED(\"Hello\")\n   * \n   * TYPE-2:\n   * \"Hello world\".slice(TAINTED(0), 5)\n   * -> \"Hello\"\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  sliceStringModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n\n    if (taintInfo) {\n      let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'String:slice', base, argsArray, iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the slice function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * substr(start)\n   * substr(start, length)\n   * \n   * @example\n   * --------------------------------\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  substrStringModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.getTaintInfo(base);\n\n    if (taintInfo) {\n      let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'String:substr', base, argsArray, iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    return result;\n  }\n\n\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the slice function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * substring(start)\n   * substring(start, length)\n   * \n   * @example\n   * --------------------------------\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  substringStringModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.getTaintInfo(base);\n\n    if (taintInfo) {\n      let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'String:substring', base, argsArray, iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    return result;\n  }\n  \n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the split function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.split([separator], [limit])\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"Hello world\").split(\" \")\n   * -> TAINTED([\"Hello\", \"world\"])\n   * \n   * TYPE-2:\n   * \"Hello world\".split(TAINTED(\" \"), 1)\n   * -> [\"Hello\"]\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  splitStringModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n\n    if (taintInfo) {\n      let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'String:split', base, argsArray, iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the startsWith function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.startsWith(searchString, [position])\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"Hello world\").startsWith(\"Hello\")\n   * -> TAINTED(true)\n   * \n   * TYPE-2:\n   * \"Hello world\".startsWith(TAINTED(\"Hello\"))\n   * -> true\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  startsWithStringModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n\n    if (taintInfo) {\n      let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'String:startsWith', base, argsArray, iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the toLocaleLowerCase function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.toLocaleLowerCase()\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"Hello World\").toLocaleLowerCase()\n   * -> TAINTED(\"hello world\")\n   * \n   * TYPE-2:\n   * \"Hello World\".toLocaleLowerCase()\n   * -> \"hello world\"\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  toLocaleLowerCaseStringModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n\n    if (taintInfo) {\n      let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'String:toLocaleLowerCase', base, argsArray, iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the toLocaleUpperCase function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.toLocaleUpperCase()\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"Hello World\").toLocaleUpperCase()\n   * -> TAINTED(\"HELLO WORLD\")\n   * \n   * TYPE-2:\n   * \"Hello World\".toLocaleUpperCase()\n   * -> \"HELLO WORLD\"\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  toLocaleUpperCaseStringModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n\n    if (taintInfo) {\n      let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'String:toLocaleUpperCase', base, argsArray, iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the toLowerCase function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.toLowerCase()\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"Hello World\").toLowerCase()\n   * -> TAINTED(\"hello world\")\n   * \n   * TYPE-2:\n   * \"Hello World\".toLowerCase()\n   * -> \"hello world\"\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  toLowerCaseStringModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n\n    if (taintInfo) {\n      let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'String:toLowerCase', base, argsArray, iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the toString function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.toString()\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"Hello World\").toString()\n   * -> TAINTED(\"Hello World\")\n   * \n   * TYPE-2:\n   * \"Hello World\".toString()\n   * -> \"Hello World\"\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  toStringStringModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n\n    if (taintInfo) {\n      let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'String:toString', base, argsArray, iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the toUpperCase function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.toUpperCase()\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"Hello World\").toUpperCase()\n   * -> TAINTED(\"HELLO WORLD\")\n   * \n   * TYPE-2:\n   * \"Hello World\".toUpperCase()\n   * -> \"HELLO WORLD\"\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  toUpperCaseStringModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n\n    if (taintInfo) {\n      let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'String:toUpperCase', base, argsArray, iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the toWellFormed function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.toWellFormed()\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"Hello World\").toWellFormed()\n   * -> TAINTED(\"Hello World\")\n   * \n   * TYPE-2:\n   * \"Hello World\".toWellFormed()\n   * -> \"Hello World\"\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  toWellFormedStringModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n\n    if (taintInfo) {\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'String:toWellFormed', base, [], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the trim function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.trim()\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"  Hello world  \").trim()\n   * -> TAINTED(\"Hello world\")\n   * \n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  trimStringModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n\n    if (taintInfo) {\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'String:trim', base, [], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the trimEnd function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.trimEnd()\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"  Hello world  \").trimEnd()\n   * -> TAINTED(\"  Hello world\")\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  trimEndStringModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n\n    if (taintInfo) {\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'String:trimEnd', base, [], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the trimStart function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.trimStart()\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"  Hello world  \").trimStart()\n   * -> TAINTED(\"Hello world  \")\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  trimStartStringModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n\n    if (taintInfo) {\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'String:trimStart', base, [], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the valueOf function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.valueOf()\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"Hello world\").valueOf()\n   * -> TAINTED(\"Hello world\")\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  valueOfStringModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n\n    if (taintInfo) {\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'String:valueOf', base, [], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n    return result;\n  }\n\n}\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/rules/js-builtins/string-builtins.js?");

/***/ }),

/***/ "./src/rules/js-builtins/symbol-builtins.js":
/*!**************************************************!*\
  !*** ./src/rules/js-builtins/symbol-builtins.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SymbolBuiltinsTaintPropRules: () => (/* binding */ SymbolBuiltinsTaintPropRules)\n/* harmony export */ });\n/* harmony import */ var _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../values/wrapped-values.js */ \"./src/values/wrapped-values.js\");\n/* harmony import */ var _values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../values/taint-info.js */ \"./src/values/taint-info.js\");\n/* harmony import */ var _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../rule-builder.js */ \"./src/rules/rule-builder.js\");\n/* harmony import */ var _rule_condition_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../rule-condition.js */ \"./src/rules/rule-condition.js\");\n/* harmony import */ var _rules_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../rules.js */ \"./src/rules/rules.js\");\n/* harmony import */ var _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../taint-helper.js */ \"./src/taint-helper.js\");\n/* harmony import */ var _utils_util_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utils/util.js */ \"./src/utils/util.js\");\n\n\n\n\n\n\n\n\nclass SymbolBuiltinsTaintPropRules {\n  constructor() {\n    this.ruleDict = [];\n    this.buildRules();\n\n    if (!_utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils) {\n      J$$.analysis.logger.error('Utils is not defined');\n    }\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * We support rules for the symbol builtins that follow:\n   * 1/ The return value needs to be tainted if the symbol itself is tainted.\n   * 2/ The return value is in type of String, not Boolean.\n   * \n   * Builtins that need to be handled:\n   * - Symbol.prototype.toString\n   * \n   * @TODO\n   * --------------------------------\n   * TODO: condition check function should also be added to the rules Dict\n   * E.g. condition: BASE_TAINTED, etc.\n   */\n  supportedSymbolBuiltins = {\n    'toString': [Symbol.prototype.toString, this.toStringSymbolModel, 'BASE_TAINTED'],\n  };\n\n  noneAffectBuiltins = {\n  };\n\n  buildRules() {\n    for (const [fName, fGroup] of Object.entries(this.supportedSymbolBuiltins)) {\n      const condition = _rule_condition_js__WEBPACK_IMPORTED_MODULE_3__.ConditionBuilder.makeCondition(fGroup[2]);\n      const rule = _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__.RuleBuilder.makeRule(fGroup[0], condition, fGroup[1]);\n      this.addRule(fGroup[0], rule);\n    }\n\n    for (const [fName, fGroup_0] of Object.entries(this.noneAffectBuiltins)) {\n      const rule = _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__.RuleBuilder.makeNoneRule(fGroup_0);\n      this.addRule(fGroup_0, rule);\n    }\n  }\n\n  addRule(func, rule) {\n    this.ruleDict.push({ func, rule });\n  }\n\n  getRule(func) {\n    const found = this.ruleDict.find(x => x.func === func);\n    return found ? found.rule : null;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the toString function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * Symbol.prototype.toString()\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * let sym = TAINTED(Symbol('desc'));\n   * sym.toString(); // Returns TAINTED(\"Symbol(desc)\")\n   * \n   * @param {Object} base - The symbol object.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  toStringSymbolModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.getTaintInfo(base);\n\n    if (taintInfo) { \n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.addTaintPropOperation(taintInfo, 'Symbol:toString', base, [], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n\n    return result;\n  }\n}\n\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/rules/js-builtins/symbol-builtins.js?");

/***/ }),

/***/ "./src/rules/operations/binary-ops.js":
/*!********************************************!*\
  !*** ./src/rules/operations/binary-ops.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BinaryOpsTaintPropRules: () => (/* binding */ BinaryOpsTaintPropRules)\n/* harmony export */ });\n/* harmony import */ var _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../values/wrapped-values.js */ \"./src/values/wrapped-values.js\");\n/* harmony import */ var _values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../values/taint-info.js */ \"./src/values/taint-info.js\");\n/* harmony import */ var _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../rule-builder.js */ \"./src/rules/rule-builder.js\");\n/* harmony import */ var _rules_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../rules.js */ \"./src/rules/rules.js\");\n/* harmony import */ var _taint_helper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../taint-helper.js */ \"./src/taint-helper.js\");\n\n\n\n\n\n\n/**\n * @description\n * --------------------------------\n * Class to manage taint propagation rules for binary operations.\n */\nclass BinaryOpsTaintPropRules {\n  constructor() {\n    this.ruleDict = [];\n    this.buildRules();\n    this.BinaryJumpTable = BinaryOpsTaintPropRules.BinaryJumpTable;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Build rules for each binary operator by iterating over BinaryJumpTable.\n   * Add the rule functions to the ruleDict.\n   */\n  buildRules() {\n    for (const operator in BinaryOpsTaintPropRules.BinaryJumpTable) {\n      const condition = (left, right) => _taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.isTainted(left) || _taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.isTainted(right);\n      const rule = _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__.RuleBuilder.makeRuleBinary(operator, condition, this.defaultBinaryModel);\n      this.addRule(operator, rule);\n    }\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Adds a rule to the rule dictionary.\n   * \n   * @param {string} operator - The binary operator.\n   * @param {Function} rule - The rule function to be added.\n   */\n  addRule(operator, rule) {\n    this.ruleDict.push({ operator, rule });\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Retrieves a rule for the specified binary operator.\n   * \n   * @param {string} operator - The binary operator.\n   * @returns {Function|null} The rule function if found, otherwise null.\n   */\n  getRule(operator) {\n    const found = this.ruleDict.find(x => x.operator === operator);\n    return found ? found.rule : null;\n  }\n\n\n  /**\n   * Table of binary operations and their corresponding functions.\n   */\n  static BinaryJumpTable = {\n    \"==\": function(left, right) { return left == right; },\n    \"===\": function(left, right) { return left === right; },\n    \"!=\": function(left, right) { return left != right; },\n    \"!==\": function(left, right) { return left !== right; },\n    \"<\": function(left, right) { return left < right; },\n    \">\": function(left, right) { return left > right; },\n    \"<=\": function(left, right) { return left <= right; },\n    \">=\": function(left, right) { return left >= right; },\n    \"+\": function(left, right) { return left + right; },\n    \"-\": function(left, right) { return left - right; },\n    \"*\": function(left, right) { return left * right; },\n    \"/\": function(left, right) { return left / right; },\n    \"%\": function(left, right) { return left % right; },\n    \">>\": function(left, right) { return left >> right; },\n    \"<<\": function(left, right) { return left << right; },\n    \">>>\": function(left, right) { return left >>> right; },\n    \"&\": function(left, right) { return left & right; },\n    \"&&\": function(left, right) { return left && right; },\n    \"|\": function(left, right) { return left | right; },\n    \"||\": function(left, right) { return left || right; },\n    \"^\": function(left, right) { return left ^ right; },\n    \"instanceof\": function(left, right) { return left instanceof right; },\n    \"in\": function(left, right) { return left in right; },\n    \"delete\": function(left, right) { return left[right] && delete left[right] }\n  };\n\n\n  /**\n   * @description\n   * --------------------------------\n   * Rule to propagate taint for binary operations.\n   * \n   * @TODO\n   * --------------------------------\n   * Need to handle the condition that both operands are taint value\n   * \n   * @param {*} base \n   * @param {*} offset \n   * @param {*} val \n   */\n  defaultBinaryModel(operator, left, right, result, iid) {\n    let taintInfo;\n\n    if ([\"===\", \"!==\", \"instanceof\", \"in\", \"!=\", \"==\", \"<\", \">\", \"<=\", \">=\", \"delete\"].includes(operator)) {\n      return result;\n    }\n\n    if (_taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.isTainted(left) || _taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.isTainted(right)) {\n      if (_taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.isTainted(left)) taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.getTaintInfo(left);\n      if (_taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.isTainted(right)) taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.getTaintInfo(right);\n    }\n    \n    if (taintInfo) {\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.addTaintPropOperation(taintInfo, `BinaryOps:${operator}`, null, [left, right], iid);\n      result = _taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n\n    return result;\n  }\n\n}\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/rules/operations/binary-ops.js?");

/***/ }),

/***/ "./src/rules/operations/get-field.js":
/*!*******************************************!*\
  !*** ./src/rules/operations/get-field.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GetFieldTaintPropRules: () => (/* binding */ GetFieldTaintPropRules)\n/* harmony export */ });\n/* harmony import */ var _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../values/wrapped-values.js */ \"./src/values/wrapped-values.js\");\n/* harmony import */ var _values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../values/taint-info.js */ \"./src/values/taint-info.js\");\n/* harmony import */ var _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../rule-builder.js */ \"./src/rules/rule-builder.js\");\n/* harmony import */ var _rules_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../rules.js */ \"./src/rules/rules.js\");\n/* harmony import */ var _taint_helper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../taint-helper.js */ \"./src/taint-helper.js\");\n\n\n\n\n\n\n\n/**\n * @description\n * --------------------------------\n * Class to manage taint propagation rules for property lookup operations.\n */\nclass GetFieldTaintPropRules {\n  constructor() {\n    this.ruleDict = [];\n    this.buildRules();\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Function to build rules for property lookup operations.\n   * \n   * Currently, we propagate all the property lookups all the from a TaintValue\n   * However, we can overwrite the rules afterwards\n   */\n  buildRules() {\n    const condition = (base, offset) => _taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.isTainted(base);\n    const rule = _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__.RuleBuilder.makeRuleGetField(condition, this.defaultGetFieldModel);\n    this.addRule('default', 'default', rule);\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Adds a rule to the rule dictionary.\n   * \n   * @param {string} operator - The unary operator.\n   * @param {Function} rule - The rule function to be added.\n   */\n  addRule(base, offset, rule) {\n    this.ruleDict.push({base, offset, rule});\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Retrieves a rule for the specified unary operator.\n   * \n   * Currently, we propagate all the property lookups all the from a TaintValue\n   * Therefore, we return the rule with the key ('all', 'all')\n   * \n   * @param {string} operator - The unary operator.\n   * @returns {Function|null} The rule function if found, otherwise null.\n   */\n  getRule(base, offset) {\n    const found = this.ruleDict.find(x => x.base === 'default');\n    return found ? found.rule : null;\n  }\n\n\n  /**\n   * @description\n   * --------------------------------\n   * Rule to propagate taint for property getting operations.\n   * \n   * @param {*} base \n   * @param {*} offset \n   * @param {*} val \n   */\n  defaultGetFieldModel(base, offset, val, iid) {\n    if (_taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.isTainted(base)) {\n      // TYPE-1\n      // If value itself is tainted, we don't need to create new taint value\n      if (_taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.isTainted(val)) {\n        let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.getTaintInfo(val);\n        // Don't add taint prop operation if the value is already tainted\n      }\n\n      // TYPE-2\n      // If the base object itself is tainted while the val is not\n      else {\n        let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.getTaintInfo(base);\n        let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.addTaintPropOperation(taintInfo, 'getField', base, [offset], iid);\n        val = _taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.createTaintValue(val, newTaintInfo)\n      }\n    }\n\n    return val;\n  }\n}\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/rules/operations/get-field.js?");

/***/ }),

/***/ "./src/rules/operations/put-field.js":
/*!*******************************************!*\
  !*** ./src/rules/operations/put-field.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PutFieldTaintPropRules: () => (/* binding */ PutFieldTaintPropRules)\n/* harmony export */ });\n/* harmony import */ var _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../values/wrapped-values.js */ \"./src/values/wrapped-values.js\");\n/* harmony import */ var _values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../values/taint-info.js */ \"./src/values/taint-info.js\");\n/* harmony import */ var _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../rule-builder.js */ \"./src/rules/rule-builder.js\");\n/* harmony import */ var _rules_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../rules.js */ \"./src/rules/rules.js\");\n/* harmony import */ var _taint_helper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../taint-helper.js */ \"./src/taint-helper.js\");\n/* harmony import */ var _utils_util_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utils/util.js */ \"./src/utils/util.js\");\n\n\n\n\n\n\n\n\n/**\n * @description\n * --------------------------------\n * Class to manage taint propagation rules for property lookup operations.\n */\nclass PutFieldTaintPropRules {\n  constructor() {\n    this.ruleDict = [];\n    this.buildRules();\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Function to build rules for property setting operations.\n   * \n   * Setting properties on DOM nodes should always strip the taint.\n   */\n  buildRules() {\n    const condition = (base, offset, val) => { return true; };\n    const defaultRule = _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__.RuleBuilder.makeRulePutField(condition, this.defaultPutFieldModel);\n    this.addRule('default', 'default', defaultRule);\n\n    const DOMNodesPutFieldRule = _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__.RuleBuilder.makeRulePutField(condition, this.DOMNodesPutFieldModel);\n    this.addRule('DOMNodes', 'default', DOMNodesPutFieldRule);\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Adds a rule to the rule dictionary.\n   * \n   * @param {string} operator - The unary operator.\n   * @param {Function} rule - The rule function to be added.\n   */\n  addRule(base, offset, rule) {\n    this.ruleDict.push({base, offset, rule});\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Retrieves a rule for the specified putField operator.\n   * \n   * Currently, we propagate all the property lookups all the from a TaintValue\n   * Therefore, we return the rule with the key ('all', 'all')\n   * \n   * @param {string} operator - The unary operator.\n   * @returns {Function|null} The rule function if found, otherwise null.\n   */\n  getRule(base, offset) {\n    if (_utils_util_js__WEBPACK_IMPORTED_MODULE_5__.Utils.isDOMNode(base)) {\n      return this.ruleDict.find(x => x.base === 'DOMNodes').rule;\n    }else{\n      return this.ruleDict.find(x => x.base === 'default').rule;\n    }\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Rule to propagate taint for property setting operations.\n   * Always strip the taint from the value.\n   * \n   * @param {*} base \n   * @param {*} offset \n   * @param {*} val \n   */\n  DOMNodesPutFieldModel(base, offset, val, iid) {\n    if (!base instanceof Element) {\n      throw new Error('DOMNodesPutFieldModel: base is not an Element');\n    }\n\n    val = _taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.concreteWrappedOnly(val);\n\n    let offset_c = _taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.concreteWrappedOnly(offset);\n    if (_taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.isTainted(base)) {\n      _taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.concreteWrappedOnly(base)[offset_c] = val;\n    }else{\n      base[offset_c] = val;\n    }\n\n    return val;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Rule to propagate taint for property setting operations.\n   * \n   * @param {*} base \n   * @param {*} offset \n   * @param {*} val \n   */\n  defaultPutFieldModel(base, offset, val, iid) {\n    let offset_c = _taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.concrete(offset)[0];\n    if (_taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.isTainted(base)) {\n      _taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.concrete(base)[0][offset_c] = val;\n    }else{\n      base[offset_c] = val;\n    }\n\n    return val;\n  }\n}\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/rules/operations/put-field.js?");

/***/ }),

/***/ "./src/rules/operations/unary-ops.js":
/*!*******************************************!*\
  !*** ./src/rules/operations/unary-ops.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UnaryOpsTaintPropRules: () => (/* binding */ UnaryOpsTaintPropRules)\n/* harmony export */ });\n/* harmony import */ var _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../values/wrapped-values.js */ \"./src/values/wrapped-values.js\");\n/* harmony import */ var _values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../values/taint-info.js */ \"./src/values/taint-info.js\");\n/* harmony import */ var _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../rule-builder.js */ \"./src/rules/rule-builder.js\");\n/* harmony import */ var _rules_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../rules.js */ \"./src/rules/rules.js\");\n/* harmony import */ var _taint_helper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../taint-helper.js */ \"./src/taint-helper.js\");\n\n\n\n\n\n\n/**\n * @description\n * --------------------------------\n * Class to manage taint propagation rules for unary operations.\n */\nclass UnaryOpsTaintPropRules {\n  constructor() {\n    this.ruleDict = [];\n    this.buildRules();\n    this.UnaryJumpTable = UnaryOpsTaintPropRules.UnaryJumpTable;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Build rules for each unary operator by iterating over UnaryJumpTable.\n   * Add the rule functions to the ruleDict.\n   */\n  buildRules() {\n    for (const operator in UnaryOpsTaintPropRules.UnaryJumpTable) {\n      const condition = (left) => _taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.isTainted(left);\n      const rule = _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__.RuleBuilder.makeRuleUnary(operator, condition, this.defaultUnaryModel);\n      this.addRule(operator, rule);\n    }\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Adds a rule to the rule dictionary.\n   * \n   * @param {string} operator - The unary operator.\n   * @param {Function} rule - The rule function to be added.\n   */\n  addRule(operator, rule) {\n    this.ruleDict.push({operator, rule});\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Retrieves a rule for the specified unary operator.\n   * \n   * @param {string} operator - The unary operator.\n   * @returns {Function|null} The rule function if found, otherwise null.\n   */\n  getRule(operator) {\n    const found = this.ruleDict.find(x => x.operator === operator);\n    return found ? found.rule : null;\n  }\n\n  static UnaryJumpTable = {\n    \"!\": function(v) { return !v; },\n    \"~\": function(v) { return ~v; },\n    \"-\": function(v) { return -v; },\n    \"+\": function(v) { return +v; },\n    \"typeof\": function(v) { return typeof v; },\n    \"void\": function(v) { return void v; },\n  };\n\n  // TODO: need to handle typeof and void separately\n  // typeof and void that has been applied on a tainted value should return a normal value\n\n  /**\n   * @description\n   * --------------------------------\n   * Rule to propagate taint for binary operations.\n   * \n   * @TODO\n   * --------------------------------\n   * Need to handle the condition that both operands are taint value\n   * \n   * @param {*} base \n   * @param {*} offset \n   * @param {*} val \n   */\n  defaultUnaryModel(operator, left, result, iid) {\n    let taintInfo;\n\n    if (_taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.isTainted(left)) {\n      taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.getTaintInfo(left);\n    }\n    \n    if (taintInfo) {\n      let newTaintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.addTaintPropOperation(taintInfo, `UnaryOps:${operator}`, null, [left], iid);\n      result = _taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.createTaintValue(result, newTaintInfo);\n    }\n\n    return result;\n  }\n}\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/rules/operations/unary-ops.js?");

/***/ }),

/***/ "./src/rules/rule-builder.js":
/*!***********************************!*\
  !*** ./src/rules/rule-builder.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RuleBuilder: () => (/* binding */ RuleBuilder)\n/* harmony export */ });\n/* harmony import */ var _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../values/wrapped-values.js */ \"./src/values/wrapped-values.js\");\n/* harmony import */ var _values_dehydrated_taint_info_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../values/dehydrated-taint-info.js */ \"./src/values/dehydrated-taint-info.js\");\n/* harmony import */ var _values_taint_info_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../values/taint-info.js */ \"./src/values/taint-info.js\");\n/* harmony import */ var _operations_binary_ops_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./operations/binary-ops.js */ \"./src/rules/operations/binary-ops.js\");\n/* harmony import */ var _operations_unary_ops_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./operations/unary-ops.js */ \"./src/rules/operations/unary-ops.js\");\n/* harmony import */ var _rule_builtin_dict_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./rule-builtin-dict.js */ \"./src/rules/rule-builtin-dict.js\");\n/* harmony import */ var _rule_prechecker_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./rule-prechecker.js */ \"./src/rules/rule-prechecker.js\");\n/* harmony import */ var _utils_util_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/util.js */ \"./src/utils/util.js\");\n/**\n * RuleBuilder class\n * \n * @description\n * --------------------------------\n * A helper class for building rules for concolic execution.\n * \n * What is a rule?\n * --------------------------------\n * Rule is a function that is used to introduce/update/delete the symbolic information\n * associated with the arguments and results of operation (e.g., function call, binary operation, etc.), \n * based on the given context conditions.\n * \n * Therefore, a rule consists of the following components:\n * 1/ Built-in function or Operator, \n * 2/ Condition check function (verifies context conditions),\n * 3/ Modeling function\n * \n * All the rules should be built from the RuleBuilder class, while the modeling function\n * are coming from the corresponding rule classes.\n *\n */\n\n\n\n\n\n\n\n\n\n\n/**\n * @description\n * --------------------------------\n * The RuleFunctionPrototype constructor.\n * \n * All the rule functions should inherit this prototype for type checking.\n * That said, all the rule function's prototype should be the prototype of \n * RuleFunctionPrototype function.\n */\nfunction RuleFunctionPrototype() {\n  this.type = 'RuleFunction';\n}\n\nclass RuleBuilder {\n\n  /**\n   * @description\n   * --------------------------------\n   * Given the unary operator name, condition check function\n   * makeRule returns a function (rule) that intake the operand (left),\n   * and applies the rule to the function call.\n   * \n   * Currently, we generally adopt the following rule:\n   * If the left operator is TaintValue, we wrap the result with the TaintValue\n   * \n   * @param {string} operator - The unary operator.\n   * @param {Function} condition - The condition check function.\n   * @param {boolean} [concretize=true] - Whether to concretize the operand.\n   * @param {boolean} [featureDisabled=false] - Whether the feature is disabled.\n   * @returns {Function} The rule function.\n   */\n  static makeRuleUnary(operator, condition, modelF, concretize = true, featureDisabled = false) {\n    let newRule = (left, iid) => {\n      \n      // Before calling the original function,\n      // We prepare the arguments for runOriginFunc to make it won't call the user-defined function and surprise us\n      // We handle all the implicit bind operations here\n      // If operand is object and has user-defined toString or valueOf function\n      // See whether the unary operation will call the user-defined function\n      // If so, we call the function and replace the left with the result\n      // Only valueOf is considered for unary operations\n      left = _rule_prechecker_js__WEBPACK_IMPORTED_MODULE_6__.BindValueChecker.handleUserDefinedValueOf(left, operator);\n\n      function unaryOpsOrigin(operator, left_c) {\n        return _operations_unary_ops_js__WEBPACK_IMPORTED_MODULE_4__.UnaryOpsTaintPropRules.UnaryJumpTable[operator](left_c);\n      }\n\n      let result, thrown, _, tmp;\n      [result, thrown, _, tmp] = this.runOriginFunc(unaryOpsOrigin, null, [operator, left], true);\n      [operator, left] = tmp;\n\n      if (!featureDisabled && condition(left)) {\n        result = modelF(operator, left, result, iid);\n      }\n\n      return result;\n    };\n\n    Object.setPrototypeOf(newRule, new RuleFunctionPrototype());\n    return newRule;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Given the binary operator name, condition check function\n   * makeRule returns a function (rule) that takes the operands (left, right),\n   * and applies the rule to the function call.\n   * \n   * Currently, we generally adopt the following rule:\n   * If either operand is a TaintValue, we wrap the result with the TaintValue\n   * \n   * @param {string} operator - The binary operator.\n   * @param {Function} condition - The condition check function.\n   * @param {boolean} [concretize=true] - Whether to concretize the operands.\n   * @param {boolean} [featureDisabled=false] - Whether the feature is disabled.\n   * @returns {Function} The rule function.\n   */\n  static makeRuleBinary(operator, condition, modelF, concretize = true, featureDisabled = false) {\n    let newRule = (left, right, iid) => {\n\n      [left, right] = _rule_prechecker_js__WEBPACK_IMPORTED_MODULE_6__.BindValueChecker.handleUserDefinedFunctionsForBinaryOps(left, right, operator);\n\n      function binaryOpsOrigin(operator, left_c, right_c) {\n        return _operations_binary_ops_js__WEBPACK_IMPORTED_MODULE_3__.BinaryOpsTaintPropRules.BinaryJumpTable[operator](left_c, right_c);\n      }\n\n      let result, thrown, _, tmp;\n      [result, thrown, _, tmp] = this.runOriginFunc(binaryOpsOrigin, null, [operator, left, right], true);\n      [operator, left, right] = tmp;\n\n      if (!featureDisabled && condition(left, right)) {\n        result = modelF(operator, left, right, result, iid);\n      }\n\n      return result;\n    };\n\n    Object.setPrototypeOf(newRule, new RuleFunctionPrototype());\n    return newRule;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Creates a new rule.\n   * \n   * GetField operation is handle based on the base object type.\n   * \n   * The offset should always get concretized.\n   * Regarding the base object,\n   * 1/ If the base object is tainted and is primitive type (wrapped), \n   *    we concretize the base object and do the taint propagation.\n   * 2/ If the base object is tainted and is not primitive type (object, array, etc.),\n   *    we don't need to concretize the base object,\n   *    but it is also fine to concretize it in one layer.\n   * \n   * @TODO\n   * --------------------------------\n   * Currently, we don't do the taint propagation. No model function will be applied here\n   * \n   * @param {Function} f - The function to apply the rule to.\n   * @param {Function} condition - The condition check function.\n   * @param {Function} model - The modeling function.\n   * @returns {Object} The rule object.\n   */\n  static makeRuleGetField(condition, modelF, concretize = true, featureDisabled = false) {\n    let newRule = (base, offset, iid) => {\n\n      function getFieldOriginal(base, offset) {\n        return base[offset];\n      }\n\n      let result, thrown, _, tmp;\n      [result, thrown, _, tmp] = this.runOriginFunc(getFieldOriginal, null, [base, offset], true);\n      [base, offset] = tmp;\n\n      if (!featureDisabled && condition(base) && !(result instanceof Function)) {\n        result = modelF(base, offset, result, iid);\n      }\n\n      return result;\n    };\n\n    Object.setPrototypeOf(newRule, new RuleFunctionPrototype());\n    return newRule;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Creates a new rule.\n   * \n   * The makeRule function for the putField operation is *different* from the other operations.\n   * Because, for other operations, in the makeRule stage, we handle the behavior of the concrete field.\n   * But for the putField operation, the concrete field is handled in the modeling function.\n   * Because, it depends on whether the base object is a DOM Node or not.\n   * \n   * @param {Function} f - The function to apply the rule to.\n   * @param {Function} condition - The condition check function.\n   * @param {Function} model - The modeling function.\n   * @returns {Object} The rule object.\n   */\n  static makeRulePutField(condition, modelF, concretize = true, featureDisabled = false) {\n    let newRule = (base, offset, val, iid) => {\n\n      function putFieldOriginal(base, offset, val) {\n        base[offset] = val;\n      }\n      \n      let result, thrown, _, tmp;\n      [result, thrown, _, tmp] = this.runOriginFunc(putFieldOriginal, null, [base, offset, val], concretize);\n      [base, offset, val] = tmp;\n\n      if (!featureDisabled && condition(val)) {\n        val = modelF(base, offset, val);\n      }\n\n      return val;\n    };\n\n    Object.setPrototypeOf(newRule, new RuleFunctionPrototype());\n    return newRule;\n  }\n\n\n\n  /**\n   * @description\n   * --------------------------------\n   * Creates a new rule.\n   * \n   * Given the function, condition check function, and modeling function,\n   * makeRule returns a function (rule) that intake the base object and arguments of the function call,\n   * and applies the rule to the function call.\n   * \n   * For the invokeFun rule, it has additional parameter `reflected` which indicates whether the function is reflected.\n   * This is because during the makeRule stage, we pass `f` as the real function, e.g. `String.fromCharCode`.\n   * However, in the program, when the rule has been called, it might used the reflected function, e.g. `String.fromCharCode.call`.\n   * The arguments of the reflected function are different from the real function, that the first argument is the base object.\n   * \n   * You should only create rule using the this function when you are sure that the function will not clobber the base or arguments.\n   * This is because, the runOriginFunc with concretize=true will dehydrate the taint information of the base and arguments\n   * If the base or args has changed, the moisturizeTaint will fail in general. However, in the most case, we can still restore the taint\n   * information even if base or args has changed if we only dehydrate the taint information with depth=1. This is because the base or args\n   * 's outmost layer will not be changed.\n   * \n   * @param {Function} f - The function to apply the rule to.\n   * @param {Function} condition - The condition check function.\n   * @param {Function} model - The modeling function.\n   * @returns {Object} The rule object.\n   */\n  static makeRule(f, condition, modelF, concretize = true, featureDisabled = false) {\n    let newRule = (base, args, iid, reflected) => {\n      let result, thrown;\n      [base, args] = _rule_prechecker_js__WEBPACK_IMPORTED_MODULE_6__.BindValueChecker.handleUserDefinedFunctionsForBuiltins(f, base, args);\n\n      [result, thrown, base, args] = this.runOriginFunc(f, base, args, concretize, reflected);\n\n      if (!featureDisabled && condition(base, args, reflected)) {\n        result = modelF(base, args, reflected, result, iid);\n      }\n\n      if (thrown) {\n          throw thrown;\n      }\n\n      return result;\n    };\n    Object.setPrototypeOf(newRule, new RuleFunctionPrototype());\n    return newRule;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Creates a new none-affect rule.\n   * \n   * The none-affect rule is rule that will not do anything but run the original function.\n   * This means, even the arguments are tainted or the return value is tainted,\n   * we don't do anything but call the original function without even concretization.\n   * \n   * There are builtins that you want to use this rule:\n   * 1/ The function that will clobber the base or arguments, e.g. `Array.prototype.push`.\n   *    Making NoneRule for these functions will not be a problem bacause \n   *    1) it only changes the existing base or arguments and will not generate new values that need to be tainted\n   *    2) all of them are object/array/set/etc. builtins, and run the builtins with taint will not cause the error \n   *       as taint is added by __TAINT__ property, not wrapped value.\n   *    Even if the function will clobber the base or arguments, in most case, using makeRule and hydrate with depth=1 will be fine,\n   *    e.g. Object.assign(obj1, obj2), after the builtin call, we can still restore the taint information of obj1 and obj2.\n   * \n   * \n   * 2/ The function that you don't want to propagate the taint to the return value.\n   * \n   * @param {Function} f - The function to apply the rule to.\n   */\n  static makeNoneRule(f) {\n    let newrule = (base, args, iid, reflected) => {\n      let result, thrown;\n      [base, args] = _rule_prechecker_js__WEBPACK_IMPORTED_MODULE_6__.BindValueChecker.handleUserDefinedFunctionsForBuiltins(f, base, args);\n\n      [result, thrown, base, args] = this.runOriginFunc(f, base, args, false, reflected);\n\n      if (thrown) {\n        throw thrown;\n      }\n\n      return result;\n    };\n    Object.setPrototypeOf(newrule, new RuleFunctionPrototype());\n    return newrule;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Creates a new rule for the constructor.\n   * \n   * @param {Function} f - f is the constructor should be invoked through new keyword.\n  */\n  static makeRuleForConstructor(constructor, condition, modelF, concretize = true, featureDisabled = false) {\n    let newRule = (base, args, iid, reflected) => {\n      let result, thrown;\n      [base, args] = _rule_prechecker_js__WEBPACK_IMPORTED_MODULE_6__.BindValueChecker.handleUserDefinedFunctionsForBuiltins(constructor, base, args);\n\n      [result, thrown, args] = this.runOriginFuncAsConstructor(constructor, args, concretize);\n\n      if (!featureDisabled && condition(base, args, reflected)) {\n        result = modelF(base, args, reflected, result, iid);\n      }\n\n      if (thrown) {\n          throw thrown;\n      }\n\n      return result;\n    };\n    Object.setPrototypeOf(newRule, new RuleFunctionPrototype());\n    return newRule;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Creates a new rule for the constructor.\n   * \n   * @param {Function} f - f is the constructor should be invoked through new keyword.\n  */\n  static makeNoneRuleForConstructor(constructor, condition, modelF, concretize = true, featureDisabled = false) {\n    let newRule = (base, args, iid, reflected) => {\n      let result, thrown;\n      [base, args] = _rule_prechecker_js__WEBPACK_IMPORTED_MODULE_6__.BindValueChecker.handleUserDefinedFunctionsForBuiltins(constructor, base, args);\n\n      [result, thrown, args] = this.runOriginFuncAsConstructor(constructor, args, concretize=false);\n\n      if (thrown) {\n          throw thrown;\n      }\n\n      return result;\n    };\n    Object.setPrototypeOf(newRule, new RuleFunctionPrototype());\n    return newRule;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Executes a function with the provided base and arguments, optionally concretizing them.\n   * \n   * The runOriginFunc will make sure that\n   * 1/ The function will be invoked with the concretized base and arguments if concretize=true.\n   * 2/ The taint information of base and arguments will be restored after the function invocation.\n   * \n   * @notes\n   * --------------------------------\n   * You should only call the function with concretize=true when you are sure that the function will not clobber the base or arguments.\n   * We cannot handle the case whether operation will clobber the base or args itself and execute the function with taint will cause the error.\n   * For these kind of case, we need to use concretizeHard (I don't see any case so far, reason see MakeNoRule comments).\n   * \n   * @param {Function} f - The function to execute.\n   * @param {Object} base - The base object for the function call.\n   * @param {Arguments} args - The arguments for the function call.\n   * @param {boolean} [concretize=true] - Whether to concretize the base and arguments.\n   * @returns {Array} An array containing the result of the function and any thrown error.\n   */\n  static runOriginFunc(f, base, args, concretize=true, reflected) {\n    let result, thrown;\n    let dehydratedBase, dehydratedArgs;\n  \n    try {\n      if (concretize) {\n        // Only when we are sure that f will not change base and args\n        // we can dehydrate the taint information with depth > 1\n        if (f === JSON.stringify) {\n          dehydratedBase = new _values_dehydrated_taint_info_js__WEBPACK_IMPORTED_MODULE_1__.DehydratedTaintValue(base);\n          dehydratedArgs = Array.from(args).map(arg => new _values_dehydrated_taint_info_js__WEBPACK_IMPORTED_MODULE_1__.DehydratedTaintValue(arg, Infinity));\n        } else if (f === Array.prototype.join) {\n          dehydratedBase = new _values_dehydrated_taint_info_js__WEBPACK_IMPORTED_MODULE_1__.DehydratedTaintValue(base, 5);\n          dehydratedArgs = Array.from(args).map(arg => new _values_dehydrated_taint_info_js__WEBPACK_IMPORTED_MODULE_1__.DehydratedTaintValue(arg));\n        } else {\n          dehydratedBase = new _values_dehydrated_taint_info_js__WEBPACK_IMPORTED_MODULE_1__.DehydratedTaintValue(base);\n          dehydratedArgs = Array.from(args).map(arg => new _values_dehydrated_taint_info_js__WEBPACK_IMPORTED_MODULE_1__.DehydratedTaintValue(arg));  \n        }\n\n        const concreteBase = dehydratedBase.concrete;\n        const concreteArgs = dehydratedArgs.map(dt => dt.concrete);\n\n        result = RuleBuilder.callOriginFunc(f, concreteBase, concreteArgs, reflected);\n      } else {\n        result = RuleBuilder.callOriginFunc(f, base, args, reflected);\n      }  \n    } catch (e) {\n      thrown = e;\n    } finally {\n      // Restore taint information\n      if (concretize) {\n        if (dehydratedBase) {\n          base = dehydratedBase.moisturizeTaint(dehydratedBase.concrete, dehydratedBase.DehydratedTaintInfo);\n        }\n        Array.from(args).forEach((item, index) => {\n          if (dehydratedArgs[index]) {\n            args[index] = dehydratedArgs[index].moisturizeTaint(dehydratedArgs[index].concrete, dehydratedArgs[index].DehydratedTaintInfo);\n          }\n        });\n      }\n    }\n  \n    return [result, thrown, base, args];\n  }\n\n  static runOriginFuncAsConstructor(constructor, args, concretize=true) {\n    let result, thrown;\n    let dehydratedBase, dehydratedArgs;\n  \n    try {\n      if (concretize) {\n        dehydratedArgs = Array.from(args).map(arg => new _values_dehydrated_taint_info_js__WEBPACK_IMPORTED_MODULE_1__.DehydratedTaintValue(arg));  \n        const concreteArgs = dehydratedArgs.map(dt => dt.concrete);\n        result = RuleBuilder.callOriginFuncAsConstructor(constructor, concreteArgs);\n      } else {\n        result = RuleBuilder.callOriginFuncAsConstructor(constructor, args);\n      }  \n    } catch (e) {\n      thrown = e;\n    } finally {\n      // Restore taint information\n      if (concretize) {\n        Array.from(args).forEach((item, index) => {\n          if (dehydratedArgs[index]) {\n            args[index] = dehydratedArgs[index].moisturizeTaint(dehydratedArgs[index].concrete, dehydratedArgs[index].DehydratedTaintInfo);\n          }\n        });\n      }\n    }\n  \n    return [result, thrown, args];\n  }\n\n  /**\n   * We assume the c_base and c_args are already concretized\n   * \n   * @param {*} f \n   * @param {*} c_base \n   * @param {*} c_args \n   * @param {*} reflected \n   */\n  static callOriginFunc(f, c_base, c_args, reflected) {\n    let result;\n    if (reflected === \"apply\") {\n      result = Function.prototype.apply.call(f.apply, c_base, c_args);\n    } else if (reflected === \"call\") {\n      result = Function.prototype.apply.call(f.call, c_base, c_args);\n    } else {\n      result = Function.prototype.apply.call(f, c_base, c_args);\n    }\n    return result;\n  }\n\n\n  static callOriginFuncAsConstructor(constructor, args) {\n    const argsArray = Array.from(args);\n    return new constructor(...argsArray);\n  }\n}\n\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/rules/rule-builder.js?");

/***/ }),

/***/ "./src/rules/rule-builtin-dict.js":
/*!****************************************!*\
  !*** ./src/rules/rule-builtin-dict.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArgumentsClobberableBuiltins: () => (/* binding */ ArgumentsClobberableBuiltins),\n/* harmony export */   BaseClobberableBuiltins: () => (/* binding */ BaseClobberableBuiltins)\n/* harmony export */ });\n/**\n * This class contains the list of functions that are known will change the base object\n * \n * Note that, function in the list doesn't means that we can only create NoneRule for it.\n * In the most case, runOriginalFunc will depth=1 will be fine.\n */\nclass BaseClobberableBuiltins {\n  static baseClobberableList = [\n    // Array\n    Array.prototype.push,\n    Array.prototype.pop,\n    Array.prototype.shift,\n    Array.prototype.unshift,\n    Array.prototype.reverse,\n    Array.prototype.sort,\n    Array.prototype.splice,\n    Array.prototype.fill,\n\n    // Set\n    Set.prototype.add,\n    Set.prototype.delete,\n    Set.prototype.clear,\n\n    // Map\n    Map.prototype.set,\n    Map.prototype.delete,\n    Map.prototype.clear,\n\n    // WeakMap\n    WeakMap.prototype.set,\n    WeakMap.prototype.delete,\n\n    // WeakSet\n    WeakSet.prototype.add,\n    WeakSet.prototype.delete,\n\n    // Object\n    Object.assign,\n    Object.defineProperty,\n    Object.defineProperties,\n    Object.setPrototypeOf,\n  ];\n\n  // Method to check if a given function is in the concretized list\n  static isKnownBaseClobberable(func) {\n    return BaseClobberableBuiltins.baseClobberableList.includes(func);\n  }\n}\n\n\n/**\n * This class contains the list of functions that are known will change the arguments object\n */\nclass ArgumentsClobberableBuiltins {\n  static argumentsClobberableList = [\n    // None specifically identified based on typical ECMAScript operations\n  ];\n\n  // Method to check if a given function is in the concretized list\n  static isKnownArgsClobberable(func) {\n    return ArgumentsClobberableBuiltins.argumentsClobberableList.includes(func);\n  }\n}\n\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/rules/rule-builtin-dict.js?");

/***/ }),

/***/ "./src/rules/rule-concretize.js":
/*!**************************************!*\
  !*** ./src/rules/rule-concretize.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefinedConcretizeBuiltinHelper: () => (/* binding */ DefinedConcretizeBuiltinHelper)\n/* harmony export */ });\n/* harmony import */ var _taint_helper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../taint-helper.js */ \"./src/taint-helper.js\");\n\n\n/**\n * This class contains the list of functions that we know how to concretize its base and args\n * \n * - We don't want to blindly concretize all the base and args for all the unsupported functions \n *   as it will cause performance issues and lead to taint loss.\n * - However, we also don't want to pass TaintValue to the unsupported functions as it will raise an \n *   exception and break the program.\n * - Therefore, we need to concretize the base and args for the unsupported functions based on the \n *   defined instructions. By default, we will concretize the base and args by one level, but for specific\n *   fucntions, we will concretize the base or args in a fine grain manner.\n */\nclass DefinedConcretizeBuiltinHelper {\n  constructor() {\n    this.prepare();\n  }\n\n  /**\n   * Known functions that are explicitly handled for concretization.\n   */\n  knownConcretizedList = [\n    // Array Object\n    Array.isArray,\n    Array.prototype.indexOf,\n    Array.prototype.some,\n    Array.prototype.includes,\n    Array.prototype.find,\n    Array.prototype.lastIndexOf,\n    Array.prototype.at,\n\n    // Object Object\n    Object.hasOwnProperty,\n    Object.freeze,\n    Object.isFrozen,\n    Object.isSealed,\n    Object.isExtensible,\n    Object.getOwnPropertyNames,\n    Object.getOwnPropertySymbols,\n    Object.getPrototypeOf,\n    Object.is,\n    Object.hasOwn,\n    Object.create,\n\n    // DOM APIs\n    document.appendChild,\n    document.createElement,\n    document.removeChild,\n    document.getElementsByTagName\n  ];\n\n  concretizedDict = {\n    // Browser APIs with specific concretization strategies\n    \"FinalizationRegistry.prototype.register\": [FinalizationRegistry.prototype.register, \"NONE\"],\n  };\n\n  prepare() {\n    // Check if PresentationRequest is defined\n    if (typeof PresentationRequest !== 'undefined') {\n      this.concretizedDict[\"PresentationRequest\"] = [PresentationRequest, \"ARG0_ARRAY_ONE_LEVEL\"];\n    }\n  }    \n\n  // Method to check if a given function is in the concretized list\n  isKnown(func) {\n    return this.knownConcretizedList.includes(func);\n  }\n\n  /**\n   * Validates a concretization strategy string.\n   * @param {string} strategyString - The strategy string to validate.\n   */\n  validateStrategyString(strategyString) {\n    const validStrategies = [\n      'NONE', 'ARGS_SELF', 'BASE_SELF', 'ARG0_ARRAY_ONE_LEVEL', 'BASE_AND_ARGS_SELF'\n    ];\n    const strategyTokens = strategyString.split(/\\s*(&&|\\|\\|)\\s*/);\n    for (const token of strategyTokens) {\n      if (!validStrategies.includes(token.trim()) && !['&&', '||'].includes(token.trim())) {\n        throw new Error(`Invalid concretization strategy: ${token}`);\n      }\n    }\n  }\n\n  /**\n   * Generates a function that applies the concretization strategy.\n   * @param {string} strategyString - The strategy string defining the concretization actions.\n   * @returns {Function} A function that applies the concretization strategy.\n   */\n  makeStrategy(strategyString) {\n    this.validateStrategyString(strategyString);\n\n    const strategies = {\n      'NONE': (base, args) => {\n        return [base, args];\n      },\n      'ARGS_SELF': (base, args) => {\n        args = Array.from(args).map(arg => _taint_helper_js__WEBPACK_IMPORTED_MODULE_0__.TaintHelper.concreteHard(arg));\n        return [base, args];\n      },\n      'BASE_SELF': (base, args) => {\n        base = _taint_helper_js__WEBPACK_IMPORTED_MODULE_0__.TaintHelper.concreteHard(base);\n        return [base, args];\n      },\n      'ARG0_ARRAY_ONE_LEVEL': (base, args) => {\n        if (Array.isArray(args[0])) {\n          args[0] = args[0].map(item => _taint_helper_js__WEBPACK_IMPORTED_MODULE_0__.TaintHelper.concreteHard(item));\n        }else {\n          args = Array.from(args).map(arg => _taint_helper_js__WEBPACK_IMPORTED_MODULE_0__.TaintHelper.concreteHard(arg));\n        }\n        return [base, args];\n      },\n      'BASE_AND_ARGS_SELF': (base, args) => {\n        base = _taint_helper_js__WEBPACK_IMPORTED_MODULE_0__.TaintHelper.concreteHard(base);\n        args = Array.from(args).map(arg => _taint_helper_js__WEBPACK_IMPORTED_MODULE_0__.TaintHelper.concreteHard(arg));\n        return [base, args];\n      }\n    };\n\n    let modifiedStrategyString = strategyString;\n\n    Object.keys(strategies).forEach(key => {\n      const regex = new RegExp(`\\\\b${key}\\\\b`, 'g');\n      modifiedStrategyString = modifiedStrategyString.replace(regex, `strategies.${key}`);\n    });\n\n    const strategyFunction = new Function('strategies', 'base', 'args', `\n      return ${modifiedStrategyString}(base, args);\n    `);\n\n    return strategyFunction.bind(null, strategies);\n  }\n\n  /**\n   * Concretizes the base and args based on a specific strategy.\n   * @param {Function} f - The function being concretized.\n   * @param {*} base - The base object for the function.\n   * @param {Arguments} args - The arguments passed to the function.\n   * @returns {{ base: any, args: any[] }} The concretized base and arguments.\n   */\n  concrete(f, base, args) {\n    let concretizationStrategy = \"ARGS_SELF\";\n\n    // Determine the concretization strategy for the function\n    for (const [key, value] of Object.entries(this.concretizedDict)) {\n      if (value[0] === f) {\n        concretizationStrategy = value[1];\n        break;\n      }\n    }\n\n    const strategyFunction = this.makeStrategy(concretizationStrategy);\n    const [base_c, args_c] = strategyFunction(base, args);\n\n    return [base_c, args_c];\n  }\n}\n\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/rules/rule-concretize.js?");

/***/ }),

/***/ "./src/rules/rule-condition.js":
/*!*************************************!*\
  !*** ./src/rules/rule-condition.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConditionBuilder: () => (/* binding */ ConditionBuilder)\n/* harmony export */ });\n/* harmony import */ var _taint_helper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../taint-helper.js */ \"./src/taint-helper.js\");\n/* harmony import */ var _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../values/wrapped-values.js */ \"./src/values/wrapped-values.js\");\n/* harmony import */ var _values_taint_info_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../values/taint-info.js */ \"./src/values/taint-info.js\");\n\n\n\n\n/**\n * Condition Barrier Class\n * \n * @description\n * --------------------------------\n * This class generates the condition barrier for the taint propagation rules.\n * \n * Each condition barrier is a function that takes the base, arguments, and reflected object\n * and returns a boolean value to indicate whether the taint propagation rule should be applied.\n * \n * Currently, we support the following condition barriers:\n * - BASE_TAINTED: The base object is tainted.\n * - ANY_ARGS_TAINTED: Any of the arguments is tainted.\n * - FIRST_ARG_TAINTED: The first argument is tainted.\n * - SECOND_ARG_TAINTED: The second argument is tainted.\n * - LAST_ARG_TAINTED: The last argument is tainted.\n */\nclass ConditionBuilder {\n  static BASE_TAINTED_RECURSIVE(base, args, reflected) {\n    return _taint_helper_js__WEBPACK_IMPORTED_MODULE_0__.TaintHelper.risTainted(base);\n  }\n\n  static BASE_TAINTED(base, args, reflected) {\n    return _taint_helper_js__WEBPACK_IMPORTED_MODULE_0__.TaintHelper.isTainted(base);\n  }\n\n  static ANY_ARGS_TAINTED(base, args, reflected) {\n    return _taint_helper_js__WEBPACK_IMPORTED_MODULE_0__.TaintHelper.isAnyArgumentsTainted(args, reflected);\n  }\n\n  static ANY_ARGS_TAINTED_RECURSIVE(base, args, reflected) {\n    return _taint_helper_js__WEBPACK_IMPORTED_MODULE_0__.TaintHelper.rgetTaintInfoisAnyArgumentsTainted(args, reflected);\n  }\n\n  static FIRST_ARG_TAINTED(base, args, reflected) {\n    return args.length > 0 && _taint_helper_js__WEBPACK_IMPORTED_MODULE_0__.TaintHelper.isTainted(args[0]);\n  }\n\n  static FIRST_ARG_TAINTED_RECURSIVE(base, args, reflected) {\n    return args.length > 0 && _taint_helper_js__WEBPACK_IMPORTED_MODULE_0__.TaintHelper.risTainted(args[0]);\n  }\n\n  static SECOND_ARG_TAINTED(base, args, reflected) {\n    return args.length > 1 && _taint_helper_js__WEBPACK_IMPORTED_MODULE_0__.TaintHelper.isTainted(args[0]);\n  }\n\n  static SECOND_ARG_TAINTED_RECURSIVE(base, args, reflected) {\n    return args.length > 1 && _taint_helper_js__WEBPACK_IMPORTED_MODULE_0__.TaintHelper.risTainted(args[1]);\n  }\n\n  static LAST_ARG_TAINTED(base, args, reflected) {\n    return args.length > 0 && _taint_helper_js__WEBPACK_IMPORTED_MODULE_0__.TaintHelper.risTainted(args[args.length - 1]);\n  }\n\n  static LAST_ARG_TAINTED_RECURSIVE(base, args, reflected) {\n    return args.length > 0 && _taint_helper_js__WEBPACK_IMPORTED_MODULE_0__.TaintHelper.isTainted(args[args.length - 1]);\n  }\n\n  static NONE(base, args, reflected) {\n    return false;\n  }\n\n  static ALL(base, args, reflected) {\n    return true;\n  }\n\n  static validateConditionString(conditionString) {\n    const validConditions = ['BASE_TAINTED', 'ANY_ARGS_TAINTED', 'FIRST_ARG_TAINTED', 'SECOND_ARG_TAINTED', 'LAST_ARG_TAINTED',\n                             'BASE_TAINTED_RECURSIVE', 'ANY_ARGS_TAINTED_RECURSIVE', 'FIRST_ARG_TAINTED_RECURSIVE', 'SECOND_ARG_TAINTED_RECURSIVE',\n                             'LAST_ARG_TAINTED_RECURSIVE','NONE', 'ALL'];\n    const conditionTokens = conditionString.split(/\\s*(&&|\\|\\|)\\s*/);\n    for (const token of conditionTokens) {\n      if (!validConditions.includes(token.trim()) && !['&&', '||'].includes(token.trim())) {\n        throw new Error(`Invalid condition: ${token}`);\n      }\n    }\n  }\n  \n  static makeCondition(conditionString) {\n    ConditionBuilder.validateConditionString(conditionString);\n  \n    const conditions = {\n      'BASE_TAINTED_RECURSIVE': this.BASE_TAINTED_RECURSIVE,\n      'ANY_ARGS_TAINTED_RECURSIVE': this.ANY_ARGS_TAINTED_RECURSIVE,\n      'FIRST_ARG_TAINTED_RECURSIVE': this.FIRST_ARG_TAINTED_RECURSIVE,\n      'SECOND_ARG_TAINTED_RECURSIVE': this.SECOND_ARG_TAINTED_RECURSIVE,\n      'LAST_ARG_TAINTED_RECURSIVE': this.LAST_ARG_TAINTED_RECURSIVE,\n      'BASE_TAINTED': this.BASE_TAINTED,\n      'ANY_ARGS_TAINTED': this.ANY_ARGS_TAINTED,\n      'FIRST_ARG_TAINTED': this.FIRST_ARG_TAINTED,\n      'SECOND_ARG_TAINTED': this.SECOND_ARG_TAINTED,\n      'LAST_ARG_TAINTED': this.LAST_ARG_TAINTED,\n      'NONE': this.NONE,\n      'ALL': this.ALL,\n    };\n  \n    let modifiedConditionString = conditionString;\n  \n    Object.keys(conditions).forEach(key => {\n      const regex = new RegExp(`\\\\b${key}\\\\b`, 'g');\n      modifiedConditionString = modifiedConditionString.replace(regex, `conditions.${key}(base, args, reflected)`);\n    });\n  \n    const conditionFunction = new Function('conditions', 'base', 'args', 'reflected', `\n      return ${modifiedConditionString};\n    `);\n  \n    return conditionFunction.bind(null, conditions);\n  }\n}\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/rules/rule-condition.js?");

/***/ }),

/***/ "./src/rules/rule-prechecker.js":
/*!**************************************!*\
  !*** ./src/rules/rule-prechecker.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BindValueChecker: () => (/* binding */ BindValueChecker)\n/* harmony export */ });\n/* harmony import */ var _utils_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/util.js */ \"./src/utils/util.js\");\n/* harmony import */ var _taint_helper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../taint-helper.js */ \"./src/taint-helper.js\");\n\n\n/**\n * @description\n * --------------------------------\n * Performing precheck for user-defined bind functions for each rule.\n * \n * When executing the original operation (e.g., built-in functions or a binary/unary/get/set operation) on stripped values (the first step),\n * it might implicitly call a user-defined function (e.g., toString, getter, or setter).\n * This can lead to several issues if the bind function returns a tainted value:\n * 1/ it might directly apply to the original operation without stripping, making the value taint-aware, or\n * 2/ it could alter the program logic. The following two cases illustrate these problems.\n * For more details, see the documentation: https://github.com/jackfromeast/TheHulk/wiki/Concolic-Execution-Bind-User-Functions\n * \n * Perchecker will handle these user-defined functions and ensure the runOriginalFun won't arrive at any user-defined functions.\n */\nclass BindValueChecker {\n\n  static handleUserDefinedValueOf(left, operator) {\n    if (left && _utils_util_js__WEBPACK_IMPORTED_MODULE_0__.Utils.realTypeOf(left) === 'object') {\n      if (_utils_util_js__WEBPACK_IMPORTED_MODULE_0__.Utils.isUserDefinedFunction(left[\"valueOf\"]) && [\"+\", \"-\", \"~\", \"!\"].includes(operator)) {\n        left = left.valueOf();\n      }\n    }\n    return left;\n  }\n  \n  static handleUserDefinedToString(left, operator) {\n    if (left && _utils_util_js__WEBPACK_IMPORTED_MODULE_0__.Utils.realTypeOf(left) === 'object') {\n      if (_utils_util_js__WEBPACK_IMPORTED_MODULE_0__.Utils.isUserDefinedFunction(left[\"toString\"]) && operator === \"+\") {\n        left = left.toString();\n      }\n    }\n    return left;\n  }\n  \n  static handleUserDefinedFunctionsForBinaryOps(left, right, operator) {\n    left = BindValueChecker.handleUserDefinedValueOf(left, operator);\n    left = BindValueChecker.handleUserDefinedToString(left, operator);\n  \n    right = BindValueChecker.handleUserDefinedValueOf(right, operator);\n    right = BindValueChecker.handleUserDefinedToString(right, operator);\n  \n    return [left, right];\n  }\n\n  static handleUserDefinedFunctionsForBuiltins(f, base, args) {\n    // Before calling the original function,\n    // We prepare the arguments for runOriginFunc to make it won't call the user-defined function and surprise us\n    // We handle all the implicit bind operations here\n    // For the array.filter, we need to make sure the return value of the first f needs to be concretized\n    if (f === Array.prototype.filter) {\n      const original_f = args[0];\n      function wrapped_f (element) {\n        return _taint_helper_js__WEBPACK_IMPORTED_MODULE_1__.TaintHelper.concreteWrappedOnly(original_f.call(this, element));\n      }\n      args[0] = wrapped_f;\n    }\n    else if (f === String.prototype.replace && typeof args[1] === 'function') {\n      const original_f = args[1];\n      function wrapped_f (...wrappedArgs) {\n        return _taint_helper_js__WEBPACK_IMPORTED_MODULE_1__.TaintHelper.concreteWrappedOnly(original_f.call(this, ...wrappedArgs));\n      }\n      args[1] = wrapped_f;\n    }\n    return [base, args];\n  }\n\n}\n\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/rules/rule-prechecker.js?");

/***/ }),

/***/ "./src/rules/rules.js":
/*!****************************!*\
  !*** ./src/rules/rules.js ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TaintPropRules: () => (/* binding */ TaintPropRules),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _operations_binary_ops_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./operations/binary-ops.js */ \"./src/rules/operations/binary-ops.js\");\n/* harmony import */ var _operations_unary_ops_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./operations/unary-ops.js */ \"./src/rules/operations/unary-ops.js\");\n/* harmony import */ var _operations_get_field_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./operations/get-field.js */ \"./src/rules/operations/get-field.js\");\n/* harmony import */ var _operations_put_field_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./operations/put-field.js */ \"./src/rules/operations/put-field.js\");\n/* harmony import */ var _js_builtins_string_builtins_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./js-builtins/string-builtins.js */ \"./src/rules/js-builtins/string-builtins.js\");\n/* harmony import */ var _js_builtins_array_builtins_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./js-builtins/array-builtins.js */ \"./src/rules/js-builtins/array-builtins.js\");\n/* harmony import */ var _js_builtins_json_builtins_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./js-builtins/json-builtins.js */ \"./src/rules/js-builtins/json-builtins.js\");\n/* harmony import */ var _js_builtins_regexp_builtins_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./js-builtins/regexp-builtins.js */ \"./src/rules/js-builtins/regexp-builtins.js\");\n/* harmony import */ var _js_builtins_object_builtins_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./js-builtins/object-builtins.js */ \"./src/rules/js-builtins/object-builtins.js\");\n/* harmony import */ var _js_builtins_reflect_builtins_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./js-builtins/reflect-builtins.js */ \"./src/rules/js-builtins/reflect-builtins.js\");\n/* harmony import */ var _js_builtins_proxy_builtins_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./js-builtins/proxy-builtins.js */ \"./src/rules/js-builtins/proxy-builtins.js\");\n/* harmony import */ var _js_builtins_symbol_builtins_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./js-builtins/symbol-builtins.js */ \"./src/rules/js-builtins/symbol-builtins.js\");\n/* harmony import */ var _js_builtins_boolean_builtins_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./js-builtins/boolean-builtins.js */ \"./src/rules/js-builtins/boolean-builtins.js\");\n/* harmony import */ var _js_builtins_number_builtins_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./js-builtins/number-builtins.js */ \"./src/rules/js-builtins/number-builtins.js\");\n// import StringBuiltinTaintPropRules from './string.js'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass TaintPropRules {\n  constructor() {\n    this.putFieldRules = new _operations_put_field_js__WEBPACK_IMPORTED_MODULE_3__.PutFieldTaintPropRules()\n    this.getFieldRules = new _operations_get_field_js__WEBPACK_IMPORTED_MODULE_2__.GetFieldTaintPropRules();\n    this.binaryRules = new _operations_binary_ops_js__WEBPACK_IMPORTED_MODULE_0__.BinaryOpsTaintPropRules();\n    this.unaryRules = new _operations_unary_ops_js__WEBPACK_IMPORTED_MODULE_1__.UnaryOpsTaintPropRules();\n\n    this.stringBuiltinsRules = new _js_builtins_string_builtins_js__WEBPACK_IMPORTED_MODULE_4__.StringBuiltinsTaintPropRules();\n    this.arrayBuiltinsRules = new _js_builtins_array_builtins_js__WEBPACK_IMPORTED_MODULE_5__.ArrayBuiltinsTaintPropRules();\n    this.jsonBuiltinsRules = new _js_builtins_json_builtins_js__WEBPACK_IMPORTED_MODULE_6__.JSONBuiltinsRules();\n    this.regexpBuiltinsRules = new _js_builtins_regexp_builtins_js__WEBPACK_IMPORTED_MODULE_7__.RegExpBuiltinsRules();\n    this.objectBuiltinsRules = new _js_builtins_object_builtins_js__WEBPACK_IMPORTED_MODULE_8__.ObjectBuiltinsTaintPropRules();\n    this.reflectBuiltinsRules = new _js_builtins_reflect_builtins_js__WEBPACK_IMPORTED_MODULE_9__.ReflectBuiltinsTaintPropRules();\n    this.proxyBuiltinsRules = new _js_builtins_proxy_builtins_js__WEBPACK_IMPORTED_MODULE_10__.ProxyBuiltinsTaintPropRules();\n    this.symbolBuiltinsRules = new _js_builtins_symbol_builtins_js__WEBPACK_IMPORTED_MODULE_11__.SymbolBuiltinsTaintPropRules();\n    this.booleanBuiltinsRules = new _js_builtins_boolean_builtins_js__WEBPACK_IMPORTED_MODULE_12__.BooleanBuiltinsTaintPropRules();\n    this.numberBuiltinsRules = new _js_builtins_number_builtins_js__WEBPACK_IMPORTED_MODULE_13__.NumberBuiltinsTaintPropRules();\n\n\n    this.invokeFunRules = this.aggregateRules([\n      this.stringBuiltinsRules.ruleDict,\n      this.arrayBuiltinsRules.ruleDict,\n      this.jsonBuiltinsRules.ruleDict,\n      this.regexpBuiltinsRules.ruleDict,\n      this.objectBuiltinsRules.ruleDict,\n      this.reflectBuiltinsRules.ruleDict,\n      this.proxyBuiltinsRules.ruleDict,\n      this.symbolBuiltinsRules.ruleDict,\n      this.booleanBuiltinsRules.ruleDict,\n      this.numberBuiltinsRules.ruleDict,\n    ]);\n  }\n\n   /**\n   * Aggregates rules from the provided rule dictionaries.\n   * \n   * @param {Array} ruleDicts - An array of rule dictionaries to aggregate.\n   * @returns {Array} - The aggregated array of rules.\n   */\n   aggregateRules(ruleDicts) {\n    const rules = ruleDicts.flat();\n    \n    return {\n      rules,\n      getRule(fn) {\n        const found = rules.find(x => x.func === fn);\n        return found ? found.rule : null;\n      }\n    };\n  }\n\n  /**\n   * Adds a rule to the rule dictionary.\n   * \n   * @param {Function} fn - The function to which the rule applies.\n   * @param {Function} rule - The rule to be applied.\n   */\n  addRule(fn, rule) {\n    this.ruleDict.push({ fn, rule });\n  }\n\n  /**\n   * Retrieves a rule for the specified function.\n   * \n   * @param {Function} fn - The function for which the rule is retrieved.\n   * @returns {Function|null} The rule if found, otherwise null.\n   */\n  getRule(fn) {\n    const found = this.ruleDict.find(x => x.fn === fn);\n    return found ? found.rule : null;\n  }\n}\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TaintPropRules);\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/rules/rules.js?");

/***/ }),

/***/ "./src/taint-expose.js":
/*!*****************************!*\
  !*** ./src/taint-expose.js ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _values_taint_info_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./values/taint-info.js */ \"./src/values/taint-info.js\");\n/* harmony import */ var _taint_helper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./taint-helper.js */ \"./src/taint-helper.js\");\n\n\n\nJ$$.wrapTaintWithIID = function (val, iid) {\n  let taintInfo = new _values_taint_info_js__WEBPACK_IMPORTED_MODULE_0__.TaintInfo(iid, \"ManuallyAdded\", new _values_taint_info_js__WEBPACK_IMPORTED_MODULE_0__.TaintPropOperation(\"ManuallyAdded\", null, [], iid));\n  return _taint_helper_js__WEBPACK_IMPORTED_MODULE_1__.TaintHelper.createTaintValue(val, taintInfo);\n}\n\nJ$$.wrapTaint = function (val, iid) {\n  let taintInfo = new _values_taint_info_js__WEBPACK_IMPORTED_MODULE_0__.TaintInfo(-1, \"ManuallyAdded\", new _values_taint_info_js__WEBPACK_IMPORTED_MODULE_0__.TaintPropOperation(\"ManuallyAdded\", null, [], -1));\n  return _taint_helper_js__WEBPACK_IMPORTED_MODULE_1__.TaintHelper.createTaintValue(val, taintInfo);\n}\n\nJ$$.isTainted = function (val) {\n  return _taint_helper_js__WEBPACK_IMPORTED_MODULE_1__.TaintHelper.isTainted(val);\n}\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/taint-expose.js?");

/***/ }),

/***/ "./src/taint-helper.js":
/*!*****************************!*\
  !*** ./src/taint-helper.js ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TaintHelper: () => (/* binding */ TaintHelper)\n/* harmony export */ });\n/* harmony import */ var _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./values/wrapped-values.js */ \"./src/values/wrapped-values.js\");\n/* harmony import */ var _values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./values/taint-info.js */ \"./src/values/taint-info.js\");\n/* harmony import */ var _utils_util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/util.js */ \"./src/utils/util.js\");\n\n\n\n\n/**\n * @description\n * --------------------------------\n * This class defines the taint-related helper functions\n * This class help you check, add, merge, and remove taint information\n * \n * @notes\n * --------------------------------\n * All the operation on the value that can be redefined by the user (e.g. get, set, in, ...)\n * should use the functions provided by the utils to avoid recursive call \n */\nclass TaintHelper {\n  \n  /**\n   * Create a new taint value\n   * @param {*} value \n   * @param {TaintInfo} taintInfo\n   */\n  static createTaintValue(value, taintInfo) {\n    if (value === undefined || value === null) {\n      return value;\n    }\n\n    // Check if value is tainted already\n    if (TaintHelper.isTainted(value)) {\n      // TODO: If it is already tainted, we need to merge the taint info\n      // Currently, we just return the value itself\n      return value;\n    }\n\n    if (_utils_util_js__WEBPACK_IMPORTED_MODULE_2__.Utils.isPrimitive(value)) {\n      J$$.analysis.logger.reportTaintInstall(value);\n      return new _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__.TaintValue(value, taintInfo);\n    }\n    else {\n      try {\n        if (!Object.isExtensible(value)) {\n          J$$.analysis.logger.debug(\"Cannot install taint to non-extensible object\", value);\n          return value;\n        } else if (TaintHelper.isInTaintBlacklist(value)) {\n          return value;\n        }\n\n        J$$.analysis.logger.reportTaintInstall(value);\n\n        Object.defineProperty(value, _values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__.TaintPropName, {\n          value: taintInfo,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        });\n\n        if (J$$.analysis.DCHECK) {\n          // Add a shadow property to store the actual taint value\n          Object.defineProperty(value, _values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__.TaintPropNameForDebug, {\n            value: taintInfo,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          });\n  \n          // Add a proxy property with a getter and setter\n          Object.defineProperty(value, _values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__.TaintPropName, {\n            get() {\n              return this[_values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__.TaintPropNameForDebug];\n            },\n            set(newValue) {\n              if (!(newValue instanceof _values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__.TaintInfo)) {\n                debugger; // Trigger debugger if the value is not of type TaintInfo\n              }\n              this[_values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__.TaintPropNameForDebug] = newValue;\n            },\n            enumerable: false,\n            configurable: true\n          });\n        }\n\n        return value;\n      }\n      catch (e) {\n        J$$.analysis.logger.debug(\"Failed to install taint to\", value, \" because \", e);\n        return value;\n      }\n    }\n  }\n\n  static isInTaintBlacklist(value) {\n    // Don't taint history, localStorage, sessionStorage, and indexedDB\n    if (value === window.history ||\n        value === window.localStorage ||\n        value === window.sessionStorage ||\n        value === window.indexedDB ||\n        value instanceof DOMStringMap) {\n      return true;\n    }\n  }\n\n  /**\n   * Concrete the value and return the concrete value and taint info\n   * \n   * This function will concrete the value by one level guarranteed\n   * This function will be used in the rule functions to get the concrete value\n   * and apply the original operation/function call\n   * \n   * However, note that, the caller is responsible for reinstalling the taint info\n   * if the value is object type and the taint info is installed in the property __TAINT__\n   * \n   * @param {*} value \n   * @returns {Array} [concreteValue, taintInfo]\n   */\n  static concrete(value) {\n    if (TaintHelper.isTainted(value)) {\n      if (value instanceof _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__.TaintValue) {\n        return [value.getConcrete(), value.getTaintInfo()];\n      } else {\n        // If the value is not wrapped in TaintValue, but has taint info\n        // We return the value itself with __TAINT__ stripped\n        // Then, we need to mually reinstall the taint info back if the original value is needed\n        let taintInfo = value[_values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__.TaintPropName];\n        delete value[_values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__.TaintPropName];\n        return [value, taintInfo];\n      }\n    }\n    return [value, null];\n  }\n\n  /**\n   * Concrete the warapped value \n   * This function will not delete the taint info from the value if the taint\n   * info is installed in the property __TAINT__\n   * Therefore, it is working for the wrapped value only\n   * \n   * By using this function, you don't need to worry about installing the taint info back\n   * could be problematic for the rule functions as it will run the original function/operation\n   * on the concrete value which is not *really* the concrete value without taint info\n   * \n   * Most of the time, you don't need to strip the __TAINT__ property of a taint object\n   * \n   * @param {*} value \n   * @returns \n   */\n  static concreteWrappedOnly(value) {\n    if (TaintHelper.isTainted(value)) {\n      if (value instanceof _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__.TaintValue) {\n        return value.getConcrete();\n      } else {\n        // If the value is not wrapped in TaintValue, but has taint info\n        // We return the value itself without __TAINT__ stripped\n        return value;\n      }\n    }\n    return value;\n  }\n\n  /**\n   * Concrete the value hard\n   * \n   * Note that this will strip the taint info from the value\n   * And you will lose the taint information forever if the taint info\n   * is installed in the property __TAINT__\n   * \n   * @param {*} value \n   * @returns {*} concreteValue\n   */\n  static concreteHard(value) {\n    if (_utils_util_js__WEBPACK_IMPORTED_MODULE_2__.Utils.isDOMNode(value)) { return value; }\n\n    if (TaintHelper.isTainted(value)) {\n      if (value instanceof _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__.TaintValue) {\n        return value.getConcrete();\n      } else {\n        // If the value is not wrapped in TaintValue, but has taint info\n        // We return the value itself with __TAINT__ stripped\n        delete value[_values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__.TaintPropName];\n        return value;\n      }\n    }\n    return value;\n  }\n  \n  /**\n   * Concrete the value if it is tainted recursively up to a specified depth.\n   * \n   * Note that at most time, we don't need to concrete the value recursively.\n   * This function will strip the taint info in very level of the value and\n   * you will lose the taint information forever.\n   * \n   * - For the primitive types, we can just concrete them in one level.\n   * - For the object types, we don't need to strip the taint as it \n   *   shouldn't affect the execution at most time.\n   * \n   * @param {*} value \n   * @param {number} depth - The depth to which the concreting should be performed.\n   * @returns {*} concreteValue\n   */\n  static rconcreteHard(value, depth=Infinity) {\n    if (depth < 0) {\n      return value;\n    }\n\n    if (_utils_util_js__WEBPACK_IMPORTED_MODULE_2__.Utils.isDOMNode(value)) { return value; }\n\n    if (TaintHelper.isTainted(value)) {\n      return TaintHelper.concreteHard(value);\n    } else if (Array.isArray(value)) {\n      return value.map(item => TaintHelper.rconcreteHard(item, depth - 1));\n    } else if (value && typeof value === 'object' && value.constructor === Object) {\n      return Object.keys(value).reduce((acc, key) => {\n        let [item, isSafeLookup] = _utils_util_js__WEBPACK_IMPORTED_MODULE_2__.Utils.safeLookup(value, key, true);\n        if (isSafeLookup) {\n          acc[key] = TaintHelper.rconcreteHard(item, depth - 1);\n        }\n\n        return acc;\n      }, {});\n    }\n\n    return value;\n  }\n\n\n\n  /**\n   * This function is used to reinstall the taint info for the object\n   * Sometimes, we will strip the taint info from the object and \n   * perform some operations on the object and then we reinstall the taint info\n   * \n   * @param {*} value \n   * @param {TaintInfo|null} taintInfo \n   */\n  static reinstall(value, taintInfo) {\n    if (value === undefined || value === null) {\n      return value;\n    }\n\n    if (!taintInfo) {\n      return value;\n    }\n\n    try {\n      if (_utils_util_js__WEBPACK_IMPORTED_MODULE_2__.Utils.isPrimitive(value)) {\n        return new _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__.TaintValue(value, taintInfo);\n      }else{\n        if (!Object.isExtensible(value)) {\n          J$$.analysis.logger.debug(\"Cannot reinstall taint to non-extensible object\", value);\n          return value;\n        }\n  \n        Object.defineProperty(value, _values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__.TaintPropName, {\n          value: taintInfo,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        });\n        return value;\n      }\n    }\n    catch (e) {\n      J$$.analysis.logger.debug(\"Failed to reinstall taint to\", value, \" because \", e);\n      return value;\n    }\n  }\n\n\n  static risTainted(value, depth = 0) {\n    if (depth > J$$.analysis.MAX_DEPTH_FOR_TAINT_CHECK) {\n      return false; // Do not trace beyond MAX_DEPTH_FOR_TAINT_CHECK layers\n    }\n    if (TaintHelper.isTainted(value)) {\n      return true;\n    } else if (Array.isArray(value)) {\n      try{\n        return value.some(item => TaintHelper.risTainted(item, depth + 1));\n      } catch (e) {\n        if (e instanceof DOMException) { return false; }\n        J$$.analysis.logger.debug(\"Cannot check if the value is tainted because \", e);\n        return false;\n      }\n    } else if (value && typeof value === 'object') {\n      // Don't traverse the DOM Node's properties\n      if (_utils_util_js__WEBPACK_IMPORTED_MODULE_2__.Utils.isDOMNode(value)) { return false; }\n      return Object.keys(value).some(key => {\n        try{\n          let [item, isSafeLookup] = _utils_util_js__WEBPACK_IMPORTED_MODULE_2__.Utils.safeLookup(value, key);\n          if (isSafeLookup) { return TaintHelper.risTainted(item, depth + 1); }\n          return false;\n        } catch (e) {\n          if (e instanceof DOMException) { return false; }\n          J$$.analysis.logger.debug(\"Cannot check if the value is tainted because \", e);\n          return false;\n        }\n      });\n    }\n    return false;\n  }\n\n  /**\n   * Check if the value is tainted in one level\n   * @param {*} value \n   * @returns {boolean}\n   */\n  static isTainted(value) {\n    try {\n      // Check if value is an instance of TaintValue\n      if (value instanceof _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__.TaintValue) {\n        return true;\n      }\n\n      // Check if the value is primitive\n      if (_utils_util_js__WEBPACK_IMPORTED_MODULE_2__.Utils.isPrimitive(value)) {\n        return false;\n      }\n\n      // Avoid using the lookup which might trigger getter unexpectedly\n      return _utils_util_js__WEBPACK_IMPORTED_MODULE_2__.Utils.hasOwnKey(value, _values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__.TaintPropName);\n    } catch (e) {\n      if (e instanceof DOMException) { return false; }\n      J$$.analysis.logger.debug(\"Cannot check if the value is tainted because \", e);\n      return false;\n    }\n  }\n\n  /**\n   * Create a new taintInfo object\n   * Given the newly added taintPropOperation and existing taintInfo\n   * \n   * This function can be seen a wrapper of taintInfo.addTaintPropOperation()\n   * which will handle the clone part automatically\n   * \n   * @param {TaintInfo} oldTaintInfo\n   * @param {String} operationName\n   * @param {*} base\n   * @param {Array[*]|Argruments} args\n   * @param {Number} iid\n   */\n  static addTaintPropOperation(oldTaintInfo, operationName, base, args, iid) {\n    if (!structuredClone) {\n      throw new Error(\"structuredClone is not defined\");\n    }\n    \n    // A workaround to clone the object with the same prototype\n    // The following line will be slow\n    let newTaintInfo = Object.create(Object.getPrototypeOf(oldTaintInfo));\n    Object.assign(newTaintInfo, structuredClone(Object.assign({}, oldTaintInfo)));\n\n    let clonedBase;\n    try {\n      if (base instanceof _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__.WrappedValue) {\n        clonedBase = base.toStringInternal();\n      } else {\n        clonedBase = _utils_util_js__WEBPACK_IMPORTED_MODULE_2__.Utils.safeToString(base);\n        // The following line will be slow, and will trigger getter unexpectedly\n        // clonedBase = structuredClone(base);\n      }\n    } catch (e) {\n      clonedBase = base;\n    }\n    \n    if (_utils_util_js__WEBPACK_IMPORTED_MODULE_2__.Utils.isArguments(args)) { args = Array.from(args); }\n    let clonedArgs = args.map(arg => {\n      try {\n        if (arg instanceof _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__.WrappedValue) {\n          return arg.toStringInternal();\n        }\n        // return structuredClone(arg);\n        return _utils_util_js__WEBPACK_IMPORTED_MODULE_2__.Utils.safeToString(arg);\n      } catch (e) {\n        return arg;\n      }\n    });\n\n    newTaintInfo.addTaintPropOperation(operationName, clonedBase, clonedArgs, iid);\n\n    return newTaintInfo;\n  }\n\n  static getTaintInfo(value) {\n    if (TaintHelper.isTainted(value)) {\n      if (value instanceof _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__.TaintValue) {\n        return value.getTaintInfo();\n      } else{\n        return value[_values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__.TaintPropName];\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Recursively check and get nested arrays and objects for taint information.\n   * \n   * @TODO\n   * --------------------------------\n   * Now, we don't merge the taint information from different elements in the array.\n   * Or we should return multiple taint info if there are multiple taints and let the caller \n   * to merge them\n   * \n   * Now, we only support array and primitive types\n   * \n   * @param {Array|Object|*} value - The item to check for taint.\n   * @returns {TaintInfo|null} - The taint information if found, otherwise null.\n   */\n  static rgetTaintInfo(value) {\n    \n    if (TaintHelper.isTainted(value)) {\n      return TaintHelper.getTaintInfo(value);\n    }\n\n    if (Array.isArray(value)) {\n      for (let element of value) {\n        let taintInfo = TaintHelper.rgetTaintInfo(element);\n        if (taintInfo) return taintInfo;\n      }\n    } else if (typeof value === 'object' && value !== null) {\n      for (let key in value) {\n        if (value.hasOwnProperty(key)) {\n          let [item, isSafeLookup] = _utils_util_js__WEBPACK_IMPORTED_MODULE_2__.Utils.safeLookup(value, key);\n          if (!isSafeLookup) { continue; }\n\n          let taintInfo = TaintHelper.rgetTaintInfo(item);\n          if (taintInfo) return taintInfo;\n        }\n      }\n    }\n\n    return null;\n  }\n    \n  /**\n   * Check if any of the arguments are tainted\n   * If function has been called in this way: f.apply(this, args),\n   * We need to unwrap the args, because it is [arg1, arg2, ...]\n   * \n   * @param {Argruments} args \n   * @param {String} reflected \n   * @returns \n   */\n  static risAnyArgumentsTainted(args, reflected) {\n    if (args.length === 0) { return false; }\n\n    let argsArray = args;\n    if (_utils_util_js__WEBPACK_IMPORTED_MODULE_2__.Utils.isArguments(args)) {\n      argsArray = Array.from(args);\n    }\n    \n    if (reflected === 'apply') {\n      // For f.apply(this, args)\n      // If there is only one argument, it is the arg itself\n      // If there is more than one argument, it is [arg1, arg2, ...] (in Array type)\n\n      // If argsArray[1] is not in type of array, we need to check if it is tainted\n      if (!_utils_util_js__WEBPACK_IMPORTED_MODULE_2__.Utils.isArray(argsArray[1])) {\n        return TaintHelper.risTainted(argsArray[1]);\n      }else{\n        // If argsArray[1] is in type of array, it can be [arg1, arg2, ...] or arg1 is an array\n        return TaintHelper.risTainted(argsArray[1]) ||\n               (argsArray[1].length > 0 &&\n               argsArray[1].some(arg => TaintHelper.risTainted(arg)));\n      }\n    }\n\n    return argsArray.some(arg => TaintHelper.risTainted(arg));\n  }\n\n  static isAnyArgumentsTainted(args, reflected) {\n    if (args.length === 0) { return false; }\n\n    let argsArray = args;\n    if (_utils_util_js__WEBPACK_IMPORTED_MODULE_2__.Utils.isArguments(args)) {\n      argsArray = Array.from(args);\n    }\n    \n    if (reflected === 'apply') {\n      // For f.apply(this, args)\n      // If there is only one argument, it is the arg itself\n      // If there is more than one argument, it is [arg1, arg2, ...]\n\n      // If argsArray[1] is not in type of array, we need to check if it is tainted\n      if (!_utils_util_js__WEBPACK_IMPORTED_MODULE_2__.Utils.isArray(argsArray[1])) {\n        return TaintHelper.isTainted(argsArray[1]);\n      }else{\n        // If argsArray[1] is in type of array, it can be [arg1, arg2, ...] or arg1 is an array\n        return TaintHelper.isTainted(argsArray[1]) ||\n                (argsArray[1].length > 0 &&\n                argsArray[1].some(arg => TaintHelper.isTainted(arg)));\n      }\n    }\n\n    return argsArray.some(arg => TaintHelper.isTainted(arg));\n  }\n}\n\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/taint-helper.js?");

/***/ }),

/***/ "./src/taint-sinks.js":
/*!****************************!*\
  !*** ./src/taint-sinks.js ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TaintSinkRules: () => (/* binding */ TaintSinkRules)\n/* harmony export */ });\n/* harmony import */ var _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./values/wrapped-values.js */ \"./src/values/wrapped-values.js\");\n/* harmony import */ var _values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./values/taint-info.js */ \"./src/values/taint-info.js\");\n/* harmony import */ var _utils_util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/util.js */ \"./src/utils/util.js\");\n\n\n\n\n\nclass TaintSinkRules {\n\n  /**\n   * @description\n   * --------------------------------\n   * This class defines the taint sink policy.\n   * This function will be invoked during the putField operation hook.\n   * \n   * SINK-TYPE-1-0:\n   * - SINK-TO-SCRIPT-SRC\n   * - Tainted value flows to the script.src property.\n   * - E.g. script.src = taintedValue\n   * - Conditions:\n   *   - `base` is a script element\n   *   - `offset` is 'src'\n   * \n   * SINK-TYPE-1-1:\n   * - SINK-TO-DOM-ELEMENT-INNERHTML\n   * - Tainted value flows to the innerHTML property of a DOM element.\n   * - E.g. element.innerHTML = taintedValue\n   * - Conditions:\n   *   - `base` is a DOM element\n   *   - `offset` is 'innerHTML'\n   * \n   * SINK-TYPE-1-2:\n   * - SINK-TO-DOM-ELEMENT-OUTERHTML\n   * - Tainted value flows to the outerHTML property of a DOM element.\n   * - E.g. element.outerHTML = taintedValue\n   * - Conditions:\n   *   - `base` is a DOM element\n   *   - `offset` is 'outerHTML'\n   * \n   * SINK-TYPE-1-3:\n   * - SINK-TO-DOM-ELEMENT-SRCDOC\n   * - Tainted value flows to the srcdoc property of an iframe element.\n   * - E.g. iframe.srcdoc = taintedValue\n   * - Conditions:\n   *   - `base` is an iframe element\n   *   - `offset` is 'srcdoc'\n   * \n   * SINK-TYPE-1-4:\n   * - SINK-TO-LINK-HREF\n   * - Tainted value flows to the srcdoc property of an iframe element.\n   * - E.g. link.rel = 'script'; link.href = taintedValue\n   * - Conditions:\n   *   - `base` is an link element\n   *   - `offset` is 'href'\n   *   - (`base.rel` is 'script') \n   *     sometimes rel attribute is defined after href attribute\n   * \n   * SINK-TYPE-2:\n   * - SINK-TO-WINDOW-LOCATION\n   * - Tainted value flows to the window.location property.\n   * - E.g. window.location = taintedValue\n   * - Conditions:\n   *   - `base` is the window object\n   *   - `offset` is 'location'\n   * \n   * SINK-TYPE-3:\n   * - SINK-TO-LOCATION-HREF\n   * - Tainted value flows to the href property of the window.location object.\n   * - E.g. window.location.href = taintedValue\n   * - Conditions:\n   *   - `base` is the window.location object\n   *   - `offset` is 'href'\n   * \n   * SINK-TYPE-4:\n   * - SINK-TO-DOCUMENT-COOKIE\n   * - Tainted value flows to the cookie property of the document object.\n   * - E.g. document.cookie = taintedValue\n   * - Conditions:\n   *   - `base` is the document object\n   *   - `offset` is 'cookie'\n   * \n   * SINK-TYPE-5:\n   * - SINK-TO-DOCUMENT-DOMAIN\n   * - Tainted value flows to the domain property of the document object.\n   * - E.g. document.domain = taintedValue\n   * - Conditions:\n   *   - `base` is the document object\n   *   - `offset` is 'domain'\n   * \n   * @param {*} base - The base object of the getField operation (which should not be a WrappedValue).\n   * @param {*} offset - The offset (property name) of the getField operation.\n   * @param {*} val - The value being assigned in the getField operation.\n   * @param {number} iid - The instruction id.\n   */\n  checkTaintAtSinkPutField(base, offset, val) {\n\n    if (!this.isTainted(val)) { return false; }\n    if (base instanceof _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__.WrappedValue) { base = base.getConcrete(); }\n\n    if (base instanceof Element) {\n      try {\n        if (base.tagName && base.tagName.toUpperCase() === 'SCRIPT' && offset === 'src') {\n          return \"SINK-TO-SCRIPT-SRC\";\n        } else if (offset === 'innerHTML' || offset === 'outerHTML') {\n          return `SINK-TO-DOM-ELEMENT-${offset.toUpperCase()}`;\n        } else if (offset === 'srcdoc') {\n          return \"SINK-TO-DOM-ELEMENT-SRCDOC\";\n        } else if (base.tagName && base.tagName.toUpperCase() === 'LINK' && offset === 'href') {\n          return \"SINK-TO-LINK-HREF\";\n        }\n      } catch (e) {\n        // Have seen exceptions where base.tagName will cause Illegal invocation error\n      }\n    }\n\n    if (base === window && offset === 'location') {\n      return \"SINK-TO-WINDOW-LOCATION\";\n    }\n\n    if (base === window.location && offset === 'href') {\n      return \"SINK-TO-LOCATION-HREF\";\n    }\n\n    if (base === document && offset === 'cookie') {\n      return \"SINK-TO-DOCUMENT-COOKIE\";\n    }\n\n    if (base === document && offset === 'domain') {\n      return \"SINK-TO-DOCUMENT-DOMAIN\";\n    }\n\n    return false;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * This function will be invoked during the call operation hook\n   * \n   * @param {Function} f - The function that is being called.\n   * @param {*} base - The base object of the function call.\n   * @param {Array} args - The arguments to the function.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   */\n  checkTaintAtSinkInvokeFun(f, base, args) {\n\n    if (f.name === 'eval') {\n      if (args.length && this.isTainted(args[0])) {\n        return [\"SINK-TO-EVAL\", args[0]];\n      }\n    }\n\n    if (f.name === 'Function') {\n      if (args.length && Array.from(args).some(arg => this.isTainted(arg))) {\n        for (let arg of Array.from(args)) {\n          if (this.isTainted(arg)) {\n            return [\"SINK-TO-FUNCTION\", arg];\n          }\n        }\n      }\n    }\n\n    if (f.name === 'setTimeout' || f.name === 'setInterval') {\n      if (args.length && this.isTainted(args[0])) {\n        return [`SINK-TO-${f.name.toUpperCase()}`, args[0]];\n      }\n    }\n\n    if (base === document) {\n      if (f.name === 'write' || f.name === 'writeln') {\n        if (args.length && this.isTainted(args[0])) {\n          return [`SINK-TO-DOCUMENT-${f.name.toUpperCase()}`, args[0]];\n        }\n      }\n    }\n\n    if (f.name === 'insertAdjacentHTML' && this.isDOMElement(base)) {\n      if (args.length >= 2 && this.isTainted(args[1])) {\n        return [\"SINK-TO-INSERTADJACENTHTML\", args[1]];\n      }\n    }\n\n    if (f.name === 'setAttribute' && base && base.tagName && base.tagName.toUpperCase() === 'SCRIPT') {\n      if (args.length >= 2 && this.isTainted(args[1])) {\n        return [\"SINK-TO-SETATTRIBUTE-SCRIPT-SRC\", args[1]];\n      }\n    }\n\n    if (f.name === 'fetch') {\n      if (args.length && this.isTainted(args[0])) {\n        return [\"SINK-TO-FETCH\", args[0]];\n      }\n    }\n\n    // Assume the base's toString shouldn't be overwritten\n    // If it is overwritten, we will get recursive function call\n    if (_utils_util_js__WEBPACK_IMPORTED_MODULE_2__.Utils.safeToString(base) === '[object XMLHttpRequest]' && f.name === 'open') {\n      if (args.length && this.isTainted(args[1])) {\n        return [\"SINK-TO-XMLHTTPREQUEST-OPEN\", args[1]];\n      }\n    }\n\n    if (this.isLocationObject(base) && (f.name === 'replace' || f.name === 'assign')) {\n      if (args.length && this.isTainted(args[0])) {\n        return [`SINK-TO-LOCATION-${f.name.toUpperCase()}`, args[0]];\n      }\n    }\n\n    if (base === JSON && f.name === 'parse') {\n      if (args.length && this.isTainted(args[0])) {\n        return [\"SINK-TO-JSON-PARSE\", args[0]];\n      }\n    }\n\n    if ((base === window.localStorage || base === window.sessionStorage) && f.name === 'setItem') {\n      if (args.length && this.isTainted(args[1])) {\n        return [`SINK-TO-${base === window.localStorage ? 'LOCALSTORAGE' : 'SESSIONSTORAGE'}-SETITEM`, args[1]];\n      }\n    }\n\n    return [false, null];\n  }\n\n  isTainted(value) {\n    return value instanceof _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__.TaintValue;\n  }\n\n  isDOMElement(element) {\n    return element instanceof Element;\n  }\n\n  isLocationObject(obj) {\n    return obj === window.location || obj === location;\n  }\n\n}\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/taint-sinks.js?");

/***/ }),

/***/ "./src/taint-sources.js":
/*!******************************!*\
  !*** ./src/taint-sources.js ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TaintSourceRules: () => (/* binding */ TaintSourceRules)\n/* harmony export */ });\n/* harmony import */ var _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./values/wrapped-values.js */ \"./src/values/wrapped-values.js\");\n/* harmony import */ var _values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./values/taint-info.js */ \"./src/values/taint-info.js\");\n\n\n\n/**\n * @description\n * --------------------------------\n * This class defines the taint source policy\n * The taint source listed below is *over-approximated*, \n * that we assume we can control the DOM elements (through DOM Clobbering & DOM APIs).\n * \n */\nclass TaintSourceRules {\n  /**\n   * @description\n   * --------------------------------\n   * This function will be invoked during the getField operation hook\n   * \n   * SOURCE-TYPE-1: \n   * - SOURCE-FROM-DOM-ELEMENT\n   * - Value flows from the DOM Elements as taint sources\n   * - E.g. image.src, script.src, iframe.src, etc.\n   * \n   * SOURCE-TYPE-2: \n   * - SOURCE-FROM-DOCUMENT\n   * - Value flows from the document object as taint sources\n   * - E.g. document.cookie, document.domain, document.doctype, and etc.\n   * \n   * SOURCE-TYPE-3:\n   * - SOURCE-FROM-WINDOW\n   * - Value flows from the window object as taint sources\n   * - This is potentially clobberable if there is:\n   *   !window.MathJax && window.MathJax = ...\n   *   Tracing a defined value might be a good idea\n   * - E.g. window.MathJax\n   * \n   * @param {*} base - The base object of the getField operation. (which not be a WrappedValue)\n   * @param {*} offset - The offset of the getField operation.\n   * @param {*} val - The value of the getField operation.\n   * @param {number} iid - The instruction id.\n   */\n  shouldTaintSourceAtGetField(base, offset, val, iid) {\n    // SOURCE-TYPE-1:\n    // Check if the base is a DOM element\n    if (this.isDOMElement(base) && \n        !this.isFunction(val)) {\n      return \"SOURCE-FROM-DOM-ELEMENT\";\n    }\n\n    // SOURCE-TYPE-2:\n    // Check if the base is the document object\n    if (this.isDocumentObject(base) &&\n        !this.isFunction(val)) {\n      return \"SOURCE-FROM-DOCUMENT\";\n    }\n\n    // SOURCE-TYPE-3:\n    // Check if the base is the window object\n    if (this.isWindowObject(base) &&\n        !this.isFunction(val)) {\n      return \"SOURCE-FROM-WINDOW\";\n    }\n\n    return false;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * This function will be invoked during the invokeFun operation hook\n   * \n   * SOURCE-TYPE-3:\n   * - SOURCE-FROM-BROWSER-API\n   * - Value flows from the browser APIs as taint sources\n   * - E.g. exampleAttr = div1.getAttribute(\"id\");\n   * - Conditions:\n   *   - `base` is a DOM Element or the document object\n   *   - `f`is a built-in function\n   *   - `result` is not a function (we don't taint functions)\n   *   - `f.name` is not in the blacklistForBrowserAPIs\n   * \n   * @param {Function} f - The function being invoked.\n   * @param {*} base - The base object of the getField operation. (which should not be a WrappedValue)\n   * @param {Array} args - The arguments passed to the function.\n   * @param {*} result - The result of the getField operation.\n   * @param {number} iid - The instruction id.\n   */\n  shouldTaintSourceAtInvokeFun(f, base, args, result, iid) {\n    if (this.isBuiltInFunction(f) && \n       (this.isDOMElement(base) || this.isDocumentObject(base)) &&\n       !this.isBuiltInFunction(result) &&\n       !this.blacklistForBrowserAPIs.includes(f.name)) {\n        return \"SOURCE-FROM-BROWSER-API\";\n    }\n\n    return false;\n  }\n\n  isDOMElement(element) {\n    return element instanceof Element;\n  }\n\n  isDocumentObject(obj) {\n    return obj === document;\n  }\n\n  isWindowObject(obj) {\n    return obj === window;\n  }\n\n  isBuiltInFunction(f) {\n    return typeof f === 'function' && (f === Object.prototype.toString.call(f).indexOf('[native code]') !== -1);\n  }\n\n  isFunction(f) {\n    return typeof f === 'function';\n  }\n\n  blacklistForBrowserAPIs = [\n    'createElement',\n    'appendChild',\n    'insertBefore',\n    'insertAdjacentElement',\n    'insertAdjacentHTML',\n    'insertAdjacentText',\n    'insertAdjacentElement',\n  ];\n}\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/taint-sources.js?");

/***/ }),

/***/ "./src/taint-stack-helper.js":
/*!***********************************!*\
  !*** ./src/taint-stack-helper.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TaintStackHelper: () => (/* binding */ TaintStackHelper)\n/* harmony export */ });\n/**\n * @description\n * --------------------------------\n * This class is used to help maintaining the internal analysis stack\n * Specifically, the TaintTracking.stackFrames and TaintTracking.taintTransparency fields\n * \n * Usually, the function call should starts from the user instrumented code to Jalangi2 runtime and then \n * pass to the analysis code. However, the analysis code may necessarily call the user function again.\n * For example, the user passed value has custom toString() method, which will be implicitly called during\n * binary operation like '+'. \n * \n * Therefore, we need to maintain the stackFrames and monitor the recursive function calls due to the analysis code\n */\nclass TaintStackHelper {\n  constructor() {\n    this.stackFrames = [];\n    this.shouldConcretizeReturn = false;\n    const MAX_STACK_SIZE = 100;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * This function is used to push the current stack frame into the stackFrames\n   * \n   * @param {String} functionName \n   * @param {String} location \n   */\n  pushStackFrame(f, iid) {\n    const stackFrame = {\n      function: f,\n      location: iid\n    };\n\n    this.stackFrames.push(stackFrame);\n\n    if (f === Array.prototype.filter) {\n      this.shouldConcretizeReturn = true;\n    }\n\n    if (this.stackFrames.length > this.MAX_STACK_SIZE) {\n      throw new Error(\"Maximum stack size reached caused by the analysis code.\");\n    }\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * This function is used to pop the current stack frame from the stackFrames\n   */\n  popStackFrame() {\n    let frame = this.stackFrames.pop();\n\n    if (frame.function === Array.prototype.filter) {\n      this.shouldConcretizeReturn = false;\n    }\n\n    return frame;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * This function is used to get the current stack frame\n   */\n  peakStackFrame() {\n    return this.stackFrames[this.stackFrames.length - 1];\n  }\n}\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/taint-stack-helper.js?");

/***/ }),

/***/ "./src/taint-tracking.js":
/*!*******************************!*\
  !*** ./src/taint-tracking.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TaintTracking: () => (/* binding */ TaintTracking)\n/* harmony export */ });\n/* harmony import */ var _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/logger.js */ \"./src/utils/logger.js\");\n/* harmony import */ var _coverage_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./coverage.js */ \"./src/coverage.js\");\n/* harmony import */ var _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./values/wrapped-values.js */ \"./src/values/wrapped-values.js\");\n/* harmony import */ var _values_taint_info_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./values/taint-info.js */ \"./src/values/taint-info.js\");\n/* harmony import */ var _rules_rules_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rules/rules.js */ \"./src/rules/rules.js\");\n/* harmony import */ var _taint_sources_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./taint-sources.js */ \"./src/taint-sources.js\");\n/* harmony import */ var _taint_sinks_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./taint-sinks.js */ \"./src/taint-sinks.js\");\n/* harmony import */ var _taint_helper_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./taint-helper.js */ \"./src/taint-helper.js\");\n/* harmony import */ var _utils_util_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/util.js */ \"./src/utils/util.js\");\n/* harmony import */ var _rules_rule_concretize_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./rules/rule-concretize.js */ \"./src/rules/rule-concretize.js\");\n/* harmony import */ var _taint_stack_helper_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./taint-stack-helper.js */ \"./src/taint-stack-helper.js\");\n// JALANGI DO NOT INSTRUMENT\n/**\n * @description\n * --------------------------------\n * This script holds the concolic execution behaviors which will be invoked by the jalangi2 runtime.\n * This script will load and execute in the browser environment.\n * \n * @notes\n * --------------------------------\n * Ideally, the analysis class should not directly manipulate TaintValues; this should be managed by\n * sources, sinks, and taint propagation rules. \n * The analysis should simply apply the appropriate rules for each operation hook.\n * \n * @usage \n * --------------------------------\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass TaintTracking {\n  constructor(sandbox) {\n    this.taintID = 0;\n    this.sandbox = sandbox;\n    this.coverage = new _coverage_js__WEBPACK_IMPORTED_MODULE_1__.Coverage(sandbox);\n    this.logger = new _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Logger({\n      level: 'info',\n      name: 'TheHulk',\n      logUnsupportBuiltin: false,\n      logTaintInstall: false\n    });\n\n    this.taintPropRules = new _rules_rules_js__WEBPACK_IMPORTED_MODULE_4__.TaintPropRules();\n    this.taintSourceRules = new _taint_sources_js__WEBPACK_IMPORTED_MODULE_5__.TaintSourceRules();\n    this.taintSinkRules = new _taint_sinks_js__WEBPACK_IMPORTED_MODULE_6__.TaintSinkRules();\n\n    this.dangerousFlows = [];\n\n    this.DCHECK = true;\n    this.taintStackHelper = new _taint_stack_helper_js__WEBPACK_IMPORTED_MODULE_10__.TaintStackHelper();\n    this.builtinConcretizeHelper = new _rules_rule_concretize_js__WEBPACK_IMPORTED_MODULE_9__.DefinedConcretizeBuiltinHelper();\n    this.MAX_DEPTH_FOR_TAINT_CHECK = 3;\n  }\n\n  /**\n   * This callback is called before a binary operation. Binary operations include  +, -, *, /, %, &, |, ^,\n   * <<, >>, >>>, <, >, <=, >=, ==, !=, ===, !==, instanceof, delete, in.  No callback for <code>delete x</code>\n   * because this operation cannot be performed reflectively.\n   *  \n   * @notes\n   * We always skip the original binary operation and let binary handle the operation.\n   * \n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {string} op - Operation to be performed\n   * @param {*} left - Left operand\n   * @param {*} right - Right operand\n   * @param {boolean} isOpAssign - True if the binary operation is part of an expression of the form\n   * <code>x op= e</code>\n   * @param {boolean} isSwitchCaseComparison - True if the binary operation is part of comparing the discriminant\n   * with a consequent in a switch statement.\n   * @param {boolean} isComputed - True if the operation is of the form <code>delete x[p]</code>, and false\n   * otherwise (even if the operation if of the form <code>delete x.p</code>)\n   * @returns {{op: string, left: *, right: *, skip: boolean}|undefined} - If an object is returned and the\n   * <tt>skip</tt> property is true, then the binary operation is skipped.  Original <tt>op</tt>, <tt>left</tt>,\n   * and <tt>right</tt> are replaced with that from the returned object if an object is returned.\n   */\n  binaryPre (iid, op, left, right, isOpAssign, isSwitchCaseComparison, isComputed) {\n    return {op: op, left: left, right: right, skip: true};\n  };\n\n  /**\n   * This callback is called after a binary operation. Binary operations include  +, -, *, /, %, &, |, ^,\n   * <<, >>, >>>, <, >, <=, >=, ==, !=, ===, !==, instanceof, delete, in.\n   *\n   * @steps\n   * 1/ Apply the taint propagation rules for the binary operation if one of the operands is tainted.\n   * \n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {string} op - Operation to be performed\n   * @param {*} left - Left operand\n   * @param {*} right - Right operand\n   * @param {undefined} result - Always undefined, as we skip the original binary operation\n   * @param {boolean} isOpAssign - True if the binary operation is part of an expression of the form\n   * <code>x op= e</code>\n   * @param {boolean} isSwitchCaseComparison - True if the binary operation is part of comparing the discriminant\n   * with a consequent in a switch statement.\n   * @param {boolean} isComputed - True if the operation is of the form <code>delete x[p]</code>, and false\n   * otherwise (even if the operation if of the form <code>delete x.p</code>)\n   * @returns {{result: *}|undefined} - If an object is returned, the result of the binary operation is\n   * replaced with the value stored in the <tt>result</tt> property of the object.\n   */\n  binary (iid, op, left, right, result, isOpAssign, isSwitchCaseComparison, isComputed) {\n    try{\n      let rule = this.taintPropRules.binaryRules.getRule(op);\n      if (rule) {\n        result = rule(left, right, iid);\n      } else {\n        result = this.taintPropRules.binaryRules.BinaryJumpTable[op](left, right);\n      }\n\n      return {result: result};\n    } catch (e) {\n      // Avoid the error swallow by user program\n      J$$.analysis.logger.warn(\"(Can be ignored)\", e);\n      throw e;\n    }\n  };\n\n  /**\n   * This callback is called before a unary operation. Unary operations include  +, -, ~, !, typeof, void.\n   *  \n   * @notes\n   * We always skip the original unary operation and let unary handle the operation.\n   * \n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {string} op - Operation to be performed\n   * @param {*} left - Left operand\n   * @returns {{op: *, left: *, skip: boolean} | undefined} If an object is returned and the\n   * <tt>skip</tt> property is true, then the unary operation is skipped.  Original <tt>op</tt> and <tt>left</tt>\n   * are replaced with that from the returned object if an object is returned.\n   */\n  unaryPre (iid, op, left) {\n      return {op: op, left: left, skip: true};\n  };\n\n  /**\n   * This callback is called after a unary operation. Unary operations include  +, -, ~, !, typeof, void.\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {string} op - Operation to be performed\n   * @param {*} left - Left operand\n   * @param {*} result - The result of the unary operation\n   * @returns {{result: *}|undefined} - If an object is returned, the result of the unary operation is\n   * replaced with the value stored in the <tt>result</tt> property of the object.\n   *\n   */\n  unary (iid, op, left, result) {\n    try { \n      let rule = this.taintPropRules.unaryRules.getRule(op);\n      if (rule) {\n        result = rule(left, iid);\n      } else {\n        let left_c = _taint_helper_js__WEBPACK_IMPORTED_MODULE_7__.TaintHelper.concreteWrappedOnly(left);\n        result = this.taintPropRules.unaryRules.UnaryJumpTable[op](left_c);\n      }\n\n      return {result: result};\n    } catch (e) {\n      // Avoid the error swallow by user program\n      J$$.analysis.logger.warn(\"(Can be ignored)\", e);\n      throw e;\n    }\n  };\n\n\n  /**\n   * This callback is called after a condition check before branching. Branching can happen in various statements\n   * including if-then-else, switch-case, while, for, ||, &&, ?:.\n   *\n   * @steps\n   * 1/ We always concretize the taint value before the conditional expression.\n   * \n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {*} result - The value of the conditional expression\n   * @returns {{result: *}|undefined} - If an object is returned, the result of the conditional expression is\n   * replaced with the value stored in the <tt>result</tt> property of the object.\n   */\n  conditional (iid, result) {\n    return {result: _taint_helper_js__WEBPACK_IMPORTED_MODULE_7__.TaintHelper.concreteWrappedOnly(result)};\n  };\n\n  /**\n   * This callback is called before a string passed as an argument to eval or Function is instrumented.\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {*} code - Code that is going to get instrumented\n   * @param {boolean} isDirect - true if this is a direct call to eval\n   * @returns {{code: *, skip: boolean}} - If an object is returned and the\n   * <tt>skip</tt> property is true, then the instrumentation of <tt>code</tt> is skipped.\n   * Original <tt>code</tt> is replaced with that from the returned object if an object is returned.\n   */\n  instrumentCodePre (iid, code, isDirect) {\n    return {code: code, skip: false};\n  };\n\n  /**\n   * This callback is called after a string passed as an argument to eval or Function is instrumented.\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {*} newCode - Instrumented code\n   * @param {Object} newAst - The AST of the instrumented code\n   * @param {boolean} isDirect - true if this is a direct call to eval\n   * @returns {{result: *}|undefined} - If an object is returned, the instrumented code is\n   * replaced with the value stored in the <tt>result</tt> property of the object.\n   */\n  instrumentCode (iid, newCode, newAst, isDirect) {\n      return {result: newCode};\n  };\n\n\n  /**\n   * This callback is called before a function, method, or constructor invocation.\n   * \n   * @example\n   * y.f(a, b, c)\n   * --------------------------------\n   * var skip = false;\n   * var aret = analysis.invokeFunPre(113, f, y, [a, b, c], false, true);\n   * if (aret) {\n   *     f = aret.f;\n   *     y = aret.y;\n   *     args = aret.args;\n   *     skip = aret.skip\n   * }\n   * if (!skip) {\n   *     f.apply(y, args);\n   * }\n   * \n   * @steps\n   * 1/ Check the taint value at the sink function call.\n   * 2/ If a taint value is passed, check whether the function is a built-in function\n   *    and has the taint propagation rules.\n   * 3/ If the function is a built-in function and has the taint propagation rules,\n   *    we update the taint information on the return value.\n   * 4/ If the function is a built-in function and has no taint propagation rules,\n   *    we concretize the taint value and apply the original function. Concretization\n   *    will be logged.\n   * 5/ Log the coverage information for the analysis.\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {function} f - The function object that going to be invoked\n   * @param {object} base - The receiver object for the function <tt>f</tt>\n   * @param {Arguments} args - The array of arguments passed to <tt>f</tt>\n   * @param {boolean} isConstructor - True if <tt>f</tt> is invoked as a constructor\n   * @param {boolean} isMethod - True if <tt>f</tt> is invoked as a method\n   * @param {number} functionIid - The iid (i.e. the unique instruction identifier) where the function was created\n   * @param {number} functionSid - The sid (i.e. the unique script identifier) where the function was created\n   * {@link MyAnalysis#functionEnter} when the function <tt>f</tt> is executed.  The <tt>functionIid</tt> can be\n   * treated as the static identifier of the function <tt>f</tt>.  Note that a given function code block can\n   * create several function objects, but each such object has a common <tt>functionIid</tt>, which is the iid\n   * that is passed to {@link MyAnalysis#functionEnter} when the function executes.\n   * @returns {{f: function, base: Object, args: Arguments, skip: boolean}|undefined} - If an object is returned and\n   * the <tt>skip</tt> property of the object is true, then the invocation operation is skipped.\n   * Original <tt>f</tt>, <tt>base</tt>, and <tt>args</tt> are replaced with that from the returned object if\n   * an object is returned. The args should has Arguments type as it will passed to the InvokeFun operation.\n   */\n  invokeFunPre (iid, f, base, args, isConstructor, isMethod, functionIid, functionSid) {\n    try {\n      let [reason, taintedArg] = this.taintSinkRules.checkTaintAtSinkInvokeFun(f, base, args);\n      if (reason) {\n        taintedArg.getTaintInfo().addtaintSink(iid, reason, new _values_taint_info_js__WEBPACK_IMPORTED_MODULE_3__.TaintPropOperation(`invokeFun:${f.name}`, base, Array.from(args), iid));\n        // TODO: Handle multiple tainted arguments here\n        _utils_util_js__WEBPACK_IMPORTED_MODULE_8__.Utils.reportDangerousFlow(\n          taintedArg.getTaintInfo().getTaintSource().reason,\n          taintedArg.getTaintInfo().getTaintSource().location,\n          reason,\n          iid,\n          taintedArg,\n          iid\n        )\n      }\n\n      // Check if the function is a built-in function\n      // Functions can be called in different ways, \n      // e.g. y.f(arg1, arg2, ...), y.f.call(this, arg1, arg2), y.f.apply(this, args)\n      // - y.f(arg1, arg2, ...) => base = y, f = y.f, args = [arg1, arg2, ...]\n      // - y.f.call(this, arg1, arg2) => base = f, f = f.apply, args = [this, arg1, arg2]\n      // - y.f.apply(this, args) => base = f, f = f.apply, args = [this, ...args]\n      // This will affect how we check the taint args and the base object\n      let fTobeCheck = f;\n      let reflected = \"\";\n      if (typeof(base) === \"function\" && (f === Function.prototype.apply || f === Function.prototype.call)) {\n        fTobeCheck = base;\n        reflected = f === Function.prototype.apply ? \"apply\" : \"call\";\n      }\n\n      let base_c = _taint_helper_js__WEBPACK_IMPORTED_MODULE_7__.TaintHelper.concreteWrappedOnly(base);\n      let f_c = _taint_helper_js__WEBPACK_IMPORTED_MODULE_7__.TaintHelper.concreteWrappedOnly(f);\n\n      if (f_c !== f) {\n        // We don't taint the function object\n        throw new Error(\"[TheHulk] Function object is tainted!\");\n      }\n\n      if (_utils_util_js__WEBPACK_IMPORTED_MODULE_8__.Utils.isNativeFunction(fTobeCheck)) {\n        let rule = this.taintPropRules.invokeFunRules.getRule(fTobeCheck);\n        if (rule) {\n          // Push the function to the stack\n          // this.taintStackHelper.pushStackFrame(rule, iid);\n          return {f: rule, base: base, args: args, skip: false, reflected: reflected, isConstructor: false};\n        }\n        else {\n          // f is a built-in function but no rule found\n          // We concretize the taint value and apply the original function\n          if (!this.builtinConcretizeHelper.isKnown(f)){\n            J$$.analysis.logger.reportUnsupportedBuiltin(f, base);\n          }\n\n          // Using rconcreteHard could be very dangerous, as\n          // - performace: if item is really big, like window, will the program run forever\n          // - functionality: we will lost all the taint information on global object like item\n          // However, it may break the program if we don't concretize the value for some built-in functions\n          // So, we maintain a known concretized list for the built-in functions for sepecial cases\n          // By default, we only concretize one level of the object\n          [base_c, args] = this.builtinConcretizeHelper.concrete(f, base, args);\n\n          // Push the function to the stack\n          // this.taintStackHelper.pushStackFrame(f_c, iid);\n          return {f: f_c, base: base_c, args: args, skip: false, reflected:\"\"};\n        }\n      }\n    \n      // f is not a built-in function or it is a constructor\n      // this.taintStackHelper.pushStackFrame(f_c, iid);\n      return {f: f_c, base: base, args: args, skip: false, reflected:\"\"};\n\n    } catch (e) {\n      // Avoid the error swallow by user program\n      J$$.analysis.logger.warn(\"(Can be ignored)\", e);\n      throw e;\n    }\n  };\n\n  /**\n   * This callback is called after a function, method, or constructor invocation.\n   *\n   * @example\n   * x = y.f(a, b, c)\n   * --------------------------------\n   * var skip = false;\n   * var aret = analysis.invokeFunPre(113, f, y, [a, b, c], false, true);\n   * if (aret) {\n   *     f = aret.f;\n   *     y = aret.y;\n   *     args = aret.args;\n   *     skip = aret.skip\n   * }\n   * if (!skip) {\n   *     result =f.apply(y, args);\n   * }\n   * aret = analysis.invokeFun(117, f, y, args, result, false, true);\n   * if (aret) {\n   *     x = aret.result\n   * } else {\n   *     x = result;\n   * }\n   * \n   * @steps\n   * 1/ Taint the return value if the function api is a taint source.\n   * 2/ Log the coverage information for the analysis.\n   * \n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {function} f - The function object that was invoked\n   * @param {*} base - The receiver object for the function <tt>f</tt>\n   * @param {Array} args - The array of arguments passed to <tt>f</tt>\n   * @param {*} result - The value returned by the invocation\n   * @param {boolean} isConstructor - True if <tt>f</tt> is invoked as a constructor\n   * @param {boolean} isMethod - True if <tt>f</tt> is invoked as a method\n   * @param {number} functionIid - The iid (i.e. the unique instruction identifier) where the function was created\n   * @param {number} functionSid - The sid (i.e. the unique script identifier) where the function was created\n   * {@link MyAnalysis#functionEnter} when the function f is executed.  <tt>functionIid</tt> can be treated as the\n   * static identifier of the function <tt>f</tt>.  Note that a given function code block can create several function\n   * objects, but each such object has a common <tt>functionIid</tt>, which is the iid that is passed to\n   * {@link MyAnalysis#functionEnter} when the function executes.\n   * @returns {{result: *}| undefined} - If an object is returned, the return value of the invoked function is\n   * replaced with the value stored in the <tt>result</tt> property of the object.  This enables one to change the\n   * value that is returned by the actual function invocation.\n   *\n   */\n  invokeFun (iid, f, base, args, result, isConstructor, isMethod, functionIid, functionSid) {\n    try {\n      let reason = this.taintSourceRules.shouldTaintSourceAtInvokeFun(f, base, args, result);\n      if (reason && !_taint_helper_js__WEBPACK_IMPORTED_MODULE_7__.TaintHelper.isTainted(result)) {\n        // TODO: We need to clone the variable or only save the taint information and not the value\n        let taintInfo = new _values_taint_info_js__WEBPACK_IMPORTED_MODULE_3__.TaintInfo(iid, reason, new _values_taint_info_js__WEBPACK_IMPORTED_MODULE_3__.TaintPropOperation(`invokeFun:${f.name}`, base, Array.from(args), iid));\n        result = _taint_helper_js__WEBPACK_IMPORTED_MODULE_7__.TaintHelper.createTaintValue(result, taintInfo);\n      }\n\n      // Pop the function from the stack\n      // let frame = this.taintStackHelper.peakStackFrame();\n      // if (frame.function !== f) {\n      //   throw new Error(\"[TheHulk] Function object is not the same!\");\n      // } else{\n      //   this.taintStackHelper.popStackFrame();\n      // }\n      \n      return {result: result};\n    } catch (e) {\n      // Avoid the error swallow by user program\n      J$$.analysis.logger.warn(\"(Can be ignored)\", e);\n      throw e;\n    }\n  };\n\n  /**\n   * This callback is called after the creation of a literal.  A literal can be a function literal, an object literal,\n   * an array literal, a number, a string, a boolean, a regular expression, null, NaN, Infinity, or undefined.\n   *\n   * @example\n   * x = \"Hello\"\n   * --------------------------------\n   * var result = \"Hello\";\n   * var aret = analysis.literal(201, result, false);\n   * if (aret) {\n   *     result = aret.result;\n   * }\n   * x = result;\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {*} val - The literal value\n   * @param {boolean} hasGetterSetter - True if the literal is an object and the object defines getters and setters\n   * @returns {{result: *} | undefined} - If the function returns an object, then the original literal value is\n   * replaced with the value stored in the <tt>result</tt> property of the object.\n   *\n   */\n  literal(iid, val, _hasGetterSetter) {\n\t\treturn {result: val};\n\t};\n\n  /**\n  * This callback is called when a for-in loop is used to iterate the properties of an object.\n  *\n  * @example\n  * for (x in y) { }\n  * --------------------------------\n  * var aret = analysis.forinObject(iid, y);\n  * if (aret) {\n  *     y = aret.result;\n  * }\n  * for (x in y) {}\n  *\n  * @param {number} iid - Static unique instruction identifier of this callback\n  * @param {*} val - Objects whose properties are iterated in a for-in loop.\n  * @returns {{result: *} | undefined} - If the function returns an object, then the original object whose\n  * properties are being iterated is replaced with the value stored in the <tt>result</tt> property of the\n  * returned object.\n  *\n  */\n  forinObject (iid, val) {\n    return {result: val};\n  };\n\n\n  /**\n   * This callback is triggered at the beginning of a scope for every local variable declared in the scope, for\n   * every formal parameter, for every function defined using a function statement, for <tt>arguments</tt>\n   * variable, and for the formal parameter passed in a catch statement.\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {string} name - Name of the variable that is declared\n   * @param {*} val - Initial value of the variable that is declared.  Variables can be local variables, function\n   * parameters, catch parameters, <tt>arguments</tt>, or functions defined using function statements.  Variables\n   * declared with <tt>var</tt> have <tt>undefined</tt> as initial values and cannot be changed by returning a\n   * different value from this callback.  On the beginning of an execution of a function, a <tt>declare</tt>\n   * callback is called on the <tt>arguments</tt> variable.\n   * @param {boolean} isArgument - True if the variable is <tt>arguments</tt> or a formal parameter.\n   * @param {number} argumentIndex - Index of the argument in the function call.  Indices start from 0.  If the\n   * variable is not a formal parameter, then <tt>argumentIndex</tt> is -1.\n   * @param {boolean} isCatchParam - True if the variable is a parameter of a catch statement.\n   * @returns {{result: *} | undefined} - If the function returns an object, then the original initial value is\n   * replaced with the value stored in the <tt>result</tt> property of the object.  This does not apply to local\n   * variables declared with <tt>var</tt>.\n   *\n   */\n  declare (iid, name, val, isArgument, argumentIndex, isCatchParam) {\n    return {result: val};\n  };\n\n\n  /**\n   * This callback is called before a property of an object is accessed.\n   * \n   * @steps\n   * 1/ We always skip the original getField operation and let getField handle the operation.\n   * \n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {*} base - Base object\n   * @param {string|*} offset - Property\n   * @param {boolean} isComputed - True if property is accessed using square brackets.  For example,\n   * <tt>isComputed</tt> is <tt>true</tt> if the get field operation is <tt>o[p]</tt>, and <tt>false</tt>\n   * if the get field operation is <tt>o.p</tt>\n   * @param {boolean} isOpAssign - True if the operation is of the form <code>o.p op= e</code>\n   * @param {boolean} isMethodCall - True if the get field operation is part of a method call (e.g. <tt>o.p()</tt>)\n   * @returns {{base: *, offset: *, skip: boolean} | undefined} - If an object is returned and the <tt>skip</tt>\n   * property of the object is true, then the get field operation is skipped.  Original <tt>base</tt> and\n   * <tt>offset</tt> are replaced with that from the returned object if an object is returned.\n   *\n   */\n  getFieldPre (iid, base, offset, isComputed, isOpAssign, isMethodCall) {\n    return {base: base, offset: offset, skip: true};\n  };\n\n\n  /**\n   * This callback is called after a property of an object is accessed.\n   * \n   * @steps\n   * 1/ Apply the taint propagation rules for the get field operation if the property should be tainted.\n   * 2/ Introduced a new taint value if the property is a taint source.\n   * 3/ Log the coverage information for the analysis.\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {*} base - Base object\n   * @param {string|*} offset - Property\n   * @param {*} val - Value of <code>base[offset]</code>\n   * @param {boolean} isComputed - True if property is accessed using square brackets.  For example,\n   * <tt>isComputed</tt> is <tt>true</tt> if the get field operation is <tt>o[p]</tt>, and <tt>false</tt>\n   * if the get field operation is <tt>o.p</tt>\n   * @param {boolean} isOpAssign - True if the operation is of the form <code>o.p op= e</code>\n   * @param {boolean} isMethodCall - True if the get field operation is part of a method call (e.g. <tt>o.p()</tt>)\n   * @returns {{result: *} | undefined} - If an object is returned, the value of the get field operation  is\n   * replaced with the value stored in the <tt>result</tt> property of the object.\n   */\n  getField (iid, base, offset, val, isComputed, isOpAssign, isMethodCall) {\n    try {\n      val = this.taintPropRules.getFieldRules.getRule(base, offset)(base, offset, iid)\n      \n      let reason = this.taintSourceRules.shouldTaintSourceAtGetField(base, offset, val);\n      if (!_taint_helper_js__WEBPACK_IMPORTED_MODULE_7__.TaintHelper.isTainted(val) && reason) {\n        // The taint introduced from taintSourceRules has more priority\n        if (val instanceof _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_2__.WrappedValue) {\n          val = val.getConcrete();\n        }\n        let taintInfo = new _values_taint_info_js__WEBPACK_IMPORTED_MODULE_3__.TaintInfo(iid, reason, new _values_taint_info_js__WEBPACK_IMPORTED_MODULE_3__.TaintPropOperation(\"getField\", base, [offset], iid));\n        val = _taint_helper_js__WEBPACK_IMPORTED_MODULE_7__.TaintHelper.createTaintValue(val, taintInfo);\n      }\n\n      return {result: val};\n    } catch (e) {\n      // Avoid the error swallow by user program\n      J$$.analysis.logger.warn(\"(Can be ignored)\", e);\n      throw e;\n    }\n  };\n\n\n  /**\n   * This callback is called before a property of an object is written.\n   * \n   * @steps\n   * 1/ We always skip the original putFieldPre operation and let putField handle the operation.\n   * \n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {*} base - Base object\n   * @param {*} offset - Property\n   * @param {*} val - Value to be stored in <code>base[offset]</code>\n   * @param {boolean} isComputed - True if property is accessed using square brackets.  For example,\n   * <tt>isComputed</tt> is <tt>true</tt> if the get field operation is <tt>o[p]</tt>, and <tt>false</tt>\n   * if the get field operation is <tt>o.p</tt>\n   * @param {boolean} isOpAssign - True if the operation is of the form <code>o.p op= e</code>\n   * @returns {{base: *, offset: *, val: *, skip: boolean} | undefined} -  If an object is returned and the <tt>skip</tt>\n   * property is true, then the put field operation is skipped.  Original <tt>base</tt>, <tt>offset</tt>, and\n   * <tt>val</tt> are replaced with that from the returned object if an object is returned.\n   */\n  putFieldPre (iid, base, offset, val, isComputed, isOpAssign) {\n    return {base: base, offset: offset, val: val, skip: true};\n  };\n\n\n  /**\n   * This callback is called after a property of an object is written.\n   * \n   * @steps\n   * 1/ Check whether a taint value has been set to the sink property (e.g. .innerHTML)\n   * 2/ Apply the taint propagation rules for the put field operation\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {*} base - Base object\n   * @param {*} offset - Property\n   * @param {*} val - Value to be stored in <code>base[offset]</code>\n   * @param {boolean} isComputed - True if property is accessed using square brackets.  For example,\n   * <tt>isComputed</tt> is <tt>true</tt> if the get field operation is <tt>o[p]</tt>, and <tt>false</tt>\n   * if the get field operation is <tt>o.p</tt>\n   * @param {boolean} isOpAssign - True if the operation is of the form <code>o.p op= e</code>\n   * @returns {{result: *} | undefined} -   If an object is returned, the result of the put field operation is\n   * replaced with the value stored in the <tt>result</tt> property of the object.\n   */\n  putField (iid, base, offset, val, isComputed, isOpAssign) {\n    try {\n      if (J$$.analysis.DCHECK) {\n        if (offset === \"__TAINT__\") {\n          debugger;\n        }\n      }\n\n      let reason = this.taintSinkRules.checkTaintAtSinkPutField(base, offset, val);\n      if (reason) {\n        val.getTaintInfo().addtaintSink(iid, reason, new _values_taint_info_js__WEBPACK_IMPORTED_MODULE_3__.TaintPropOperation(\"putField\", base, [offset], iid));\n        _utils_util_js__WEBPACK_IMPORTED_MODULE_8__.Utils.reportDangerousFlow(\n          val.taintInfo.getTaintSourceReason(),\n          val.taintInfo.getTaintSourceLocation(),\n          reason,\n          iid,\n          val,\n          iid\n        )\n      }\n\n      val = this.taintPropRules.putFieldRules.getRule(base, offset)(base, offset, val, iid)\n      return {result: val};\n    } catch (e) {\n      // Avoid the error swallow by user program\n      J$$.analysis.logger.warn(\"(Can be ignored)\", e);\n      throw e;\n    }\n  };\n\n\n  /**\n   * This callback is called after a variable is read.\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {string} name - Name of the variable being read\n   * @param {*} val - Value read from the variable\n   * @param {boolean} isGlobal - True if the variable is not declared using <tt>var</tt> (e.g. <tt>console</tt>)\n   * @param {boolean} isScriptLocal - True if the variable is declared in the global scope using <tt>var</tt>\n   * @returns {{result: *} | undefined} - If an object is returned, the result of the read operation is\n   * replaced with the value stored in the <tt>result</tt> property of the object.\n   */\n  read (iid, name, val, isGlobal, isScriptLocal) {\n    return {result: val};\n  };\n\n  /**\n   * This callback is called before a variable is written.\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {string} name - Name of the variable being read\n   * @param {*} val - Value to be written to the variable\n   * @param {*} lhs - Value stored in the variable before the write operation\n   * @param {boolean} isGlobal - True if the variable is not declared using <tt>var</tt> (e.g. <tt>console</tt>)\n   * @param {boolean} isScriptLocal - True if the variable is declared in the global scope using <tt>var</tt>\n   * @returns {{result: *} | undefined} - If an object is returned, the result of the write operation is\n   * replaced with the value stored in the <tt>result</tt> property of the object.\n   */\n  write (iid, name, val, lhs, isGlobal, isScriptLocal) {\n      return {result: val};\n  };\n\n  /**\n   * This callback is called before a value is returned from a function using the <tt>return</tt> keyword.\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {*} val - Value to be returned\n   * @returns {{result: *} | undefined} - If an object is returned, the value to be returned is\n   * replaced with the value stored in the <tt>result</tt> property of the object.\n   */\n  _return (iid, val) {\n    // if (this.taintStackHelper.shouldConcretizeReturn) {\n    //   val = TaintHelper.concreteWrappedOnly(val);\n    // }\n    return {result: val};\n  };\n\n  /**\n   * This callback is called before a value is thrown using the <tt>throw</tt> keyword.\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {*} val - Value to be thrown\n   * @returns {{result: *} | undefined} - If an object is returned, the value to be thrown is\n   * replaced with the value stored in the <tt>result</tt> property of the object.\n   */\n  _throw (iid, val) {\n      return {result: val};\n  };\n\n  /**\n   * This callback is called when a <tt>with</tt> statement is executed\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {*} val - Value used as an argument to <tt>with</tt>\n   * @returns {{result: *} | undefined} - If an object is returned, the value to be used in <tt>with</tt> is\n   * replaced with the value stored in the <tt>result</tt> property of the object.\n   */\n  _with (iid, val) {\n      return {result: val};\n  };\n\n\n  /**\n   * This callback is called before the execution of a function body starts.\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {function} f - The function object whose body is about to get executed\n   * @param {*} dis - The value of the <tt>this</tt> variable in the function body\n   * @param {Array} args - List of the arguments with which the function is called\n   * @returns {undefined} - Any return value is ignored\n   */\n  functionEnter (iid, f, dis, args) {};\n  \n  /**\n   * This callback is called when the execution of a function body completes\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {*} returnVal - The value returned by the function\n   * @param {{exception:*} | undefined} wrappedExceptionVal - If this parameter is an object, the function\n   * execution has thrown an uncaught exception and the exception is being stored in the <tt>exception</tt>\n   * property of the parameter\n   * @returns {{returnVal: *, wrappedExceptionVal: *, isBacktrack: boolean}}  If an object is returned, then the\n   * actual <tt>returnVal</tt> and <tt>wrappedExceptionVal.exception</tt> are replaced with that from the\n   * returned object. If an object is returned and the property <tt>isBacktrack</tt> is set, then the control-flow\n   * returns to the beginning of the function body instead of returning to the caller.  The property\n   * <tt>isBacktrack</tt> can be set to <tt>true</tt> to repeatedly execute the function body as in MultiSE\n   * symbolic execution.\n   */\n  functionExit (iid, returnVal, wrappedExceptionVal) {\n      return {returnVal: returnVal, wrappedExceptionVal: wrappedExceptionVal, isBacktrack: false};\n  };\n\n\n  /**\n   * This callback is called before the execution of a JavaScript file\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {string} instrumentedFileName - Name of the instrumented script file\n   * @param {string} originalFileName - Name of the original script file\n   */\n  scriptEnter (iid, instrumentedFileName, originalFileName) {};\n  \n\n  /**\n   * This callback is called when the execution of a JavaScript file completes\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {{exception:*} | undefined} wrappedExceptionVal - If this parameter is an object, the script\n   * execution has thrown an uncaught exception and the exception is being stored in the <tt>exception</tt>\n   * property of the parameter\n   * @returns {{wrappedExceptionVal: *, isBacktrack: boolean}} - If an object is returned, then the\n   * actual <tt>wrappedExceptionVal.exception</tt> is replaced with that from the\n   * returned object. If an object is returned and the property <tt>isBacktrack</tt> is set, then the control-flow\n   * returns to the beginning of the script body.  The property\n   * <tt>isBacktrack</tt> can be set to <tt>true</tt> to repeatedly execute the script body as in MultiSE\n   * symbolic execution.\n   */\n  scriptExit (iid, wrappedExceptionVal) {\n      return {wrappedExceptionVal: wrappedExceptionVal, isBacktrack: false};\n  };\n}\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/taint-tracking.js?");

/***/ }),

/***/ "./src/utils/iidToLocation.js":
/*!************************************!*\
  !*** ./src/utils/iidToLocation.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* Copyright (c) Royal Holloway, University of London | Contact Blake Loring (blake@parsed.uk), Duncan Mitchell (Duncan.Mitchell.2015@rhul.ac.uk), or Johannes Kinder (johannes.kinder@rhul.ac.uk) for details or support | LICENSE.md for license details */\n// JALANGI DO NOT INSTRUMENT\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(sandbox, sid, iid) {\n  const iid_string = sandbox.iidToLocation(sid, iid);\n\n  if (!iid_string) {\n      return undefined;\n  }\n\n  return iid_string.substr(1, iid_string.length - 2).split(\":\").slice(1); //Comes in the form (Filename:1:2:3:4)   \n}\n\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/utils/iidToLocation.js?");

/***/ }),

/***/ "./src/utils/logger.js":
/*!*****************************!*\
  !*** ./src/utils/logger.js ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Logger: () => (/* binding */ Logger)\n/* harmony export */ });\n// JALANGI DO NOT INSTRUMENT\n/**\n * @description:\n * --------------------------------\n * This class implements a logger to replace the log4js module which\n * is not compatible with webpack bundle.\n */\nclass Logger {\n  constructor(config={level: 'info', name: 'TheHulk'}) {\n    this.name = config.name;\n    this.level = config.level;\n    this.logUnsupportBuiltin = config.logUnsupportBuiltin;\n    this.logTaintInstall = config.logTaintInstall;\n\n    this.levels = ['debug', 'info', 'warn', 'error'];\n    this.levelIndex = this.levels.indexOf(this.level);\n  }\n\n  log(level, message) {\n    const levelIndex = this.levels.indexOf(level);\n    if (levelIndex >= this.levelIndex) {\n      const logMessage = `[${new Date().toISOString()}]-[${this.name}]-[${level.toUpperCase()}]-${message}`;\n      switch (level) {\n        case 'debug':\n          console.log(logMessage);\n          break;\n        case 'info':\n          console.log(`\\x1b[32m%s\\x1b[0m`, logMessage);\n          break;\n        case 'warn':\n          console.log(`\\x1b[33m%s\\x1b[0m`, logMessage);\n          break;\n        case 'error':\n          console.log(`\\x1b[31m%s\\x1b[0m`, logMessage);\n          break;\n      }\n    }\n  }\n\n  debug(...args) {\n    this.log('debug', args.map(Logger.safeToString).join(' '));\n  }\n\n  info(...args) {\n    this.log('info', args.map(Logger.safeToString).join(' '));\n  }\n\n  warn(...args) {\n    this.log('warn', args.map(Logger.safeToString).join(' '));\n  }\n\n  error(...args) {\n    this.log('error', args.map(Logger.safeToString).join(' '));\n  }\n\n  reportVulnFlow(sourceReason, sinkReason, taintedValue) {\n    console.log(\"%c[TheHulk] Found a dangerous flow from %s to %s: \\n%o\",\n                'background: #222; color: #bada55',            \n                sourceReason, sinkReason, taintedValue);\n  }\n\n  /**\n   * We assume the f has been checked to be a native function already\n   * @param {Function} f \n   * @param {*} base \n   */\n  reportUnsupportedBuiltin(f, base) {\n    if (!this.logUnsupportBuiltin) {\n      return;\n    }\n\n    let fullName = \"unknown\";\n\n    // If base is a object, e.g. \"hello\"\n    if (base && base.constructor && base.constructor.name) {\n      fullName = `${base.constructor.name}.${f.name}`;\n    }\n    // If base is a function, e.g. String()\n    if (base && typeof base === \"function\") {\n      fullName = `${base.name}.${f.name}`;\n    }\n\n    this.debug(`Unsupported builtin ${fullName}`);\n  }\n\n  reportTaintInstall(value) {\n    if (!this.logTaintInstall) {\n      return;\n    }\n\n    this.debug(\"Taint installed to:\", value);\n  }\n\n  static safeToString(value) {\n    try {\n      return value != null? value.toString() : 'null';\n    } catch (e) {\n      return '[Unable to convert to string]';\n    }\n  }\n}\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/utils/logger.js?");

/***/ }),

/***/ "./src/utils/util.js":
/*!***************************!*\
  !*** ./src/utils/util.js ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Utils: () => (/* binding */ Utils)\n/* harmony export */ });\n/* harmony import */ var _taint_helper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../taint-helper.js */ \"./src/taint-helper.js\");\n\n\n/**\n * @description\n * --------------------------------\n * General utility functions that are used across the analysis\n * \n */\nclass Utils {\n  // Get a safe version of Object.prototype.toString and Function.prototype.toString\n  static safeObjectToString = Object.prototype.toString;\n  static safeFunctionToString = Function.prototype.toString;\n  static reHostCtor = /^\\[object .+?Constructor\\]$/;\n  static staticNativeFuncPattern = \"function toString() { [native code] }\"\n  static reNative = new RegExp(\"^\" + Utils.staticNativeFuncPattern\n                                    .replace(/[.*+?^${}()|[\\]\\/\\\\]/g, \"\\\\$&\")\n                                    .replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\");\n\n  static reportDangerousFlow(sourceReason, sourceLoc, sinkReason, sinkLoc, taintedValue, iid) {\n    J$$.analysis.logger.reportVulnFlow(sourceReason, sinkReason, taintedValue);\n    \n    try{\n      // TODO: Think of a better way to take the snapshot of the tainted value\n      // const clonedTaintedValue = structuredClone(taintedValue);\n      J$$.analysis.dangerousFlows.push({\n        sourceReason: sourceReason,\n        sourceLoc: sourceLoc,\n        sinkReason: sinkReason,\n        sinkLoc: sinkLoc,\n        taintedValue: taintedValue,\n        iid: iid\n      });\n    }\n    catch(e){\n      J$$.analysis.logger.debug(\"Failed to clone tainted value\", taintedValue, \" because \", e);\n    }\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Safe toString function that handles exceptions\n   * - The value might doesn't inherited from Object.prototype and don't have toString method\n   * - The value can have user-defined toString method, we need to check if it is native\n   * - The value may be proixied, and calling toString will trigger the getter\n   */\n  static safeToString(value) {\n    try {\n      if (value === null || value === undefined) {\n        return value + '';\n      }\n\n      if (Utils.isPrimitive(value)) {\n        return value.toString();\n      } else {\n        return Object.prototype.toString.call(value);\n      }\n      \n    } catch (e) {\n      return '[Unable to convert to string]';\n    }\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Safe toString function that handles exceptions and is user-defined function aware\n   * - The value might doesn't inherited from Object.prototype and don't have toString method\n   */\n  static safeToStringWithUserDefinedToString(value) {\n    try {\n      if (value === null || value === undefined) {\n        return value + '';\n      }\n\n      return value.toString();\n    } catch (e) {\n      return '[Unable to convert to string]';\n    }\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Safe lookup function is to access a property of an user-passed object\n   * \n   * @notes\n   * --------------------------------\n   * If obj[prop] is a getter, and when executing the getter, the function uses obj itself again,\n   * We will likely get a recursive function call, if we check taint or concretize of the argument recursively (as it will \n   * trigger the obj[prop] getter again)\n   * \n   * @param {*} obj \n   * @param {*} prop\n   * @returns {Array} [value, isSafe]\n   */\n  static safeLookup(obj, prop, skipGetter=false) {\n    if (skipGetter) {\n      const descriptor = Object.getOwnPropertyDescriptor(obj, prop);\n      if (descriptor && descriptor.get && Utils.isUserDefinedFunction(descriptor.get)) {\n        return [null, false];\n      }\n    }\n\n    try {\n      // Set receiver to obj to avoid getter recursion\n      // In case, the get function uses Reflect.get(obj, prop, receiver) in its body\n      return [Reflect.get(obj, prop, obj), true];\n    }\n    catch (e) {\n      // Have seen exceptions where base.tagName will cause Illegal invocation error\n      return [null, false];\n    }\n  }\n\n  /**\n   * This function helps to check if the object has the property and avoid triggering any getter\n   * As long as the proxy doesn't define the [[OwnPropertyKeys]] method\n   * \n   * @param {*} obj \n   * @param {*} prop \n   * @returns \n   */\n  static hasOwnKey(obj, prop) {\n    try{\n      // Quite slow, need proxy doesn't define [[OwnPropertyKeys]]\n      // return Reflect.ownKeys(obj).some(key => key === prop);\n      // Faster, need proxy doesn't define getOwnPropertyDescriptor \n      return Object.prototype.hasOwnProperty.call(obj, prop);\n    } catch(e){\n      return false;\n    }\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Safe toPrimitive function that handles exceptions\n   * \n   * @param {*} value \n   */\n  static safeToPrimitive(value) {\n    try {\n      return value.toString();\n    } catch (e) {\n      return null;\n    }\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Retrun the array like arguments\n   * \n   * @param {Argruments} args \n   * @param {String} reflected \n   * @returns \n   */\n  static getArrayLikeArguments(args, reflected) {\n    if (args.length === 0) { return []; }\n      \n    let argsArray = args;\n    if (Utils.isArguments(args)) {\n      argsArray = Array.from(args);\n    }\n    \n    if (reflected === 'apply') {\n      // For f.apply(this, args)\n      // If there is only one argument, it is the arg itself\n      // If there is more than one argument, it is [arg1, arg2, ...]\n      if (argsArray[1] instanceof Array) {\n        return argsArray[1];\n      } else {\n        return [argsArray[1]];\n      }\n    }\n\n    return argsArray;\n  }\n\n  /**\n   * isNativeFunction should free from any side effects\n   * \n   * The f and value should be any type of value even without prototype\n   * We should swallow any exceptions\n   * \n   * @TODO\n   * ------------------------------\n   * Now, this function is quite slow, we need to optimize it\n   * \n   * @param {*} f \n   * @returns \n   */\n  static isNativeFunction(f) {\n    function isNativeCore(value) {\n        if (!value.hasOwnProperty || value.hasOwnProperty('toString')) {\n          // isNativeFunction will not work on custom toString methods. \n          // We assume nobody would overwrite core method toStrings\n          return false;\n        }\n\n        if (typeof(value) === \"function\") {\n            return Utils.reNative.test(Utils.safeFunctionToString.call(value)) && value.name !== 'bound '; \n        } else if (typeof(value) === \"object\") {\n            return Utils.reHostCtor.test(Utils.safeObjectToString.call(value));\n        } else {\n            return false;\n        }\n    }\n\n    if (f === null || f === undefined) {\n        // isNativeFunction called on null or undefined;\n        return false;\n    }\n\n    if (typeof(f) === \"function\" || typeof(f) === \"object\") {\n        return isNativeCore(f);\n    } else {\n        // isNativeFunction called on non-function/non-object;\n        return false;\n    }\n  }\n\n  static isUserDefinedFunction(f) {\n    return typeof f === 'function' && !Utils.isNativeFunction(f);\n  }\n\n  static isAnyUserDefinedFunction(args) {\n    return Array.from(args).some(arg => typeof arg === 'function' && !Utils.isNativeFunction(arg));\n  }\n\n  /**\n   * Check the real type of the value no matter if it is tainted\n   * @param {*} value \n   */\n  static realTypeOf(value) {\n    if (_taint_helper_js__WEBPACK_IMPORTED_MODULE_0__.TaintHelper.isTainted(value)) {\n      return typeof _taint_helper_js__WEBPACK_IMPORTED_MODULE_0__.TaintHelper.concreteWrappedOnly(value);\n    }\n    return typeof value;\n  }\n\n  static isArguments(args) {\n    return Object.prototype.toString.call(args) === '[object Arguments]';\n  }\n\n  static isPrimitive(value) {\n    return value !== Object(value);\n  }\n\n  /**\n   * Check if the value is a string no matter if it is tainted\n   * @param {*} value \n   * @returns \n   */\n  static isString(value) {\n    return Utils.realTypeOf(value) === 'string' || _taint_helper_js__WEBPACK_IMPORTED_MODULE_0__.TaintHelper.concreteWrappedOnly(value) instanceof String;\n  }\n\n  /**\n   * https://developer.mozilla.org/en-US/docs/Web/API/Node\n   * @param {*} value \n   * @returns {Boolean}\n   */\n  static isDOMNode(value) {\n    try{\n      if (value instanceof Node || value.prototype instanceof Node) {\n        return true;\n      }\n    } catch(e){\n      return false;\n    }\n  }\n\n  /**\n   * Check if the value is an iterator from String.prototype.matchAll\n   * @param {*} value \n   * @returns {boolean}\n   */\n  static isRegExpStringIterator(value) {\n    const matchAllIteratorPrototype = Object.getPrototypeOf(''.matchAll(''));\n    return Object.getPrototypeOf(value) === matchAllIteratorPrototype;\n  }\n\n  static isArray(value) { \n    return Array.isArray(value);\n  }\n}\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/utils/util.js?");

/***/ }),

/***/ "./src/values/dehydrated-taint-info.js":
/*!*********************************************!*\
  !*** ./src/values/dehydrated-taint-info.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DehydratedTaintValue: () => (/* binding */ DehydratedTaintValue)\n/* harmony export */ });\n/* harmony import */ var _utils_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/util.js */ \"./src/utils/util.js\");\n/* harmony import */ var _taint_helper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../taint-helper.js */ \"./src/taint-helper.js\");\n\n\n\n/**\n * This class is used by the runOriginFunc function\n * to store the taint information of a value and then reinstall it back\n * \n * @notes\n * --------------------------------\n * This class is based on the fact that we cannot fully clone an object in javascript and keeping all its\n * type, properties and methods. So, we cannot get a identical copy of the object with taint information stripped for runOriginFunc and\n * use its original value for the model function afterwards.\n * \n * \n * And also, in the most case, we don't need to recursive dehydrate and moisturize the taint information.\n * E.g. \n *  - For [\"TAINTED\"].pop, we don't want to recursively dehydrate the taint information of the array and\n *    we will not be able to moisturize the taint information back. The best way is to leave the concretize=false when\n *    calling the runOriginFunc.\n * \n *  - For [\"TAINT\"].join, we need to recursively dehydrate the taint information of the array and moisturize the taint information back.\n *    otherwise, the taint's toString method will be called and ruin the original result.\n * \n * Therefore, you should only call DehydratedTaintValue.maxDepth>1 when you are sure that the value will not be clobbered by running\n * the runOriginFunc function and there is a reason for that (e.g. array.join). Otherwise, you should set maxDepth=1.\n * \n * \n * @param {Object} self - Taint information of the current object\n * @param {Object|Array} children - Taint information of nested objects/arrays\n */\nclass DehydratedTaintValue {\n  constructor(value, depth=1) {\n    this.concrete = value;\n    this.DehydratedTaintInfo = null;\n    // Usually, depth=1 means we are calling concrete and reinstall functions on the value\n    this.maxDepth = depth;\n    [this.concrete, this.DehydratedTaintInfo] = this.dehydrateTaint(value, 0);\n  }\n\n  /**\n   * Get the DehydratedTaintInfo from a value\n   * \n   * @param {*} value \n   * @param {number} depth - Current recursion depth\n   * @returns {Array} [concreteValue, DehydratedTaintInfo]\n   */\n  dehydrateTaint(value, depth) {\n    if (depth > this.maxDepth) {\n      return [value, null]; // No taint for primitives or beyond max depth\n    }\n\n    let taintInfo = null;\n    let concreteValue = value;\n    if (_taint_helper_js__WEBPACK_IMPORTED_MODULE_1__.TaintHelper.isTainted(value)) {\n      [concreteValue, taintInfo] = _taint_helper_js__WEBPACK_IMPORTED_MODULE_1__.TaintHelper.concrete(value);\n    }\n\n    if (this.maxDepth > 1) {\n      if (Array.isArray(concreteValue)) {\n        let taintInfoArray = [];\n        let concreteArray = concreteValue.map((item, index) => {\n          let [concreteItem, itemTaint] = this.dehydrateTaint(item, depth + 1);\n          taintInfoArray[index] = itemTaint;\n          return concreteItem;\n        });\n        return [concreteArray, { self: taintInfo, children: taintInfoArray }];\n      } else if (concreteValue !== null && typeof concreteValue === 'object') {\n        let taintInfoObj = {};\n        let concreteObj = {};\n        for (let key in concreteValue) {\n          let [concreteItem, itemTaint] = this.dehydrateTaint(concreteValue[key], depth + 1);\n          concreteObj[key] = concreteItem;\n          taintInfoObj[key] = itemTaint;\n        }\n        return [concreteObj, { self: taintInfo, children: taintInfoObj }];\n      }\n    }\n\n    if (taintInfo) {\n      return [concreteValue, { self: taintInfo }];\n    }\n\n    return [value, null];\n  }\n\n  /**\n   * Method to reinstall the taint information to a value from its DehydratedTaintInfo\n   * \n   * @param {*} value \n   * @param {Object} taintInfo - Taint information to be reinstalled\n   * @param {number} depth - Current recursion depth\n   * @returns {*} value with reinstalled taint\n   */\n  moisturizeTaint(value, taintInfo, depth = 0) {\n    if (depth > this.maxDepth || taintInfo == null) {\n      return value; // No taint for primitives, beyond max depth, or null taint info\n    }\n\n    if (J$$.analysis.DCHECK) {\n     // If the value and taintInfo are not consistent, throw an error     \n    }\n\n    value = _taint_helper_js__WEBPACK_IMPORTED_MODULE_1__.TaintHelper.reinstall(value, taintInfo.self);\n\n    if (this.maxDepth > 1) {\n      if (Array.isArray(value)) {\n        value.forEach((item, index) => {\n          if (taintInfo.children && taintInfo.children[index]) {\n            value[index] = this.moisturizeTaint(value[index], taintInfo.children[index], depth + 1);\n          }\n        });\n      } else if (typeof value === 'object') {\n        for (let key in value) {\n          if (taintInfo.children && taintInfo.children[key]) {\n            value[key] = this.moisturizeTaint(value[key], taintInfo.children[key], depth + 1);\n          }\n        }\n      }\n    }\n\n    return value;\n  }\n}\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/values/dehydrated-taint-info.js?");

/***/ }),

/***/ "./src/values/taint-info.js":
/*!**********************************!*\
  !*** ./src/values/taint-info.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TaintInfo: () => (/* binding */ TaintInfo),\n/* harmony export */   TaintPropName: () => (/* binding */ TaintPropName),\n/* harmony export */   TaintPropNameForDebug: () => (/* binding */ TaintPropNameForDebug),\n/* harmony export */   TaintPropOperation: () => (/* binding */ TaintPropOperation)\n/* harmony export */ });\n/* harmony import */ var _wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wrapped-values.js */ \"./src/values/wrapped-values.js\");\n/* harmony import */ var _utils_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/util.js */ \"./src/utils/util.js\");\n\n\n/**\n * @description\n * --------------------------------\n * Taint information for a value.\n * This class stores the following information about a taint:\n * 1/ Taint Identifier (ID)\n * 2/ Taint Source (Location) (i.e. where the taint originated from)\n * 3/ Taint propagation operations (i.e. how the taint is being propagated)\n * \n * The taint identifier is a unique identifier for the taint source. The derived\n * values will have the same taint identifier as value from which they are derived.\n * However, the taint propagation operations will differ.\n * \n * @example\n * --------------------------------\n * let b = a.replace(/[&<>n, 0=\\/]/g, \"\");\n * a.taintInfo = { \n *    taintID: 1,\n *    taintSource: {\n *      location: 1,\n *      sourceLocation: undefined,\n *      reason: \"DOM Clobberable Lookup\",\n *      operation: \"document.cookie\"\n *    },\n *    taintPropOperations: []\n * }\n * \n * b is derived from a, so we have\n * =>\n * b.taintInfo = a.taintInfo\n * b.taintInfo.addTaintPropOperation(\"replace\", [\"/[&<>n, 0=\\/]/g\", \"\"])\n */\nclass TaintInfo {\n  /**\n   * TaintInfo constructor\n   * @param {Smi} iid \n   * @param {String} reason: The reason why the taint was introduced\n   * @param {TaintPropOperation} operation: The operation that introduced the taint\n   */\n  constructor(iid, reason, operation) {\n    this.taintID = J$$.analysis.taintID++ || 0;\n    this.taintSource = {\n      location: iid,\n      // sourceLocation: undefined, // J$$.iidToLocation(iid)\n      reason: reason,\n      operation: operation\n    }\n    this.taintSink = {\n      location: undefined,\n      reason: undefined,\n      operation: operation\n    }\n\n    this.taintPropOperations = [];\n    if (operation) this.taintPropOperations = [operation];\n  }\n\n  getTaintID() {\n    return this.taintID;\n  }\n\n  getTaintSource() {\n    return this.taintSource;\n  }\n\n  getTaintSourceReason() {\n    return this.taintSource.reason;\n  }\n\n  getTaintSourceLocation() {\n    return this.taintSource.location;\n  }\n\n  getTaintPropOperations() {\n    return this.taintPropOperations;\n  }\n\n  addTaintPropOperation(operation, base, argument, location) {\n    this.taintPropOperations.push(\n      new TaintPropOperation(operation, base, argument, location));\n  }\n\n  addtaintSink(location, reason, operation) {\n    this.taintSink = {\n      location: location,\n      reason: reason,\n      operation: operation\n    }\n  }\n}\n\n/**\n * @description\n * --------------------------------\n * Taint propagation operation. This class stores the operation that is being\n * performed on the taint.\n * \n * @example\n * --------------------------------\n * TAINT.replace(/[&<>n, 0=\\/]/g, \"\");\n * =>\n * new TaintPropOperation(\"replace\", [\"/[&<>n, 0=\\/]/g\", \"\"]);\n * \n */\nclass TaintPropOperation {\n  /**\n   * TaintPropOperation constructor\n   * \n   * @TODO\n   * Concrete the arguments here, like toString, etc.\n   * \n   * @param {String} operation\n   * @param {*} base\n   * @param {Array<*>} argument\n   * @param {Number} location\n   */\n  constructor(operation, base, argument, location) {\n    this.operation = operation;\n    this.base = this.cloneableOne(base);\n    this.arguments = this.cloneable(argument);\n    this.location = location;\n  }\n\n  /**\n   * Here we need to make sure that the arguments are cloneable through structuredClone\n   * \n   * As far as I know, HTML elements are not cloneable\n   * Therefore, we store its string representation\n   * E.g. HTMLScriptElement is not cloneable and we store its HTMLScriptElement.toString()\n   * \n   * Save the snapshot of the arguments and base is too slow, especially for large objects like window\n   * Therefore, we only store the string representation of the base and arguments\n   */\n  cloneable(args) {\n    return args.map(arg => {\n      try {\n        // If the argument itself is a TaintValue\n        if (arg instanceof _wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__.WrappedValue) {\n          return _utils_util_js__WEBPACK_IMPORTED_MODULE_1__.Utils.safeToString(arg);\n        }\n\n        // This is very slow\n        // return structuredClone(arg);\n        return _utils_util_js__WEBPACK_IMPORTED_MODULE_1__.Utils.safeToString(arg);\n      } catch (e) {\n        if (arg.toString) {\n          return _utils_util_js__WEBPACK_IMPORTED_MODULE_1__.Utils.safeToString(arg);\n        }else {\n          return \"[Unable to clone and convert to string (no toString method)]\";\n        }\n      }\n    });\n  }\n\n  cloneableOne(base) {\n    try {\n      // If the argument itself is a TaintValue\n      if (base instanceof _wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__.WrappedValue) {\n        return _utils_util_js__WEBPACK_IMPORTED_MODULE_1__.Utils.safeToString(base);\n      }\n      \n      // This is very slow\n      // return structuredClone(base);\n      return _utils_util_js__WEBPACK_IMPORTED_MODULE_1__.Utils.safeToString(base);\n    } catch (e) {\n      if (base.toString) {\n        return _utils_util_js__WEBPACK_IMPORTED_MODULE_1__.Utils.safeToString(base);\n      }else {\n        return \"[Unable to clone and convert to string (no toString method)]\";\n      }\n    }\n  }\n\n  getOperation() {\n    return this.operation;\n  }\n\n  getArguments() {\n    return this.arguments;\n  }\n\n}\n\nconst TaintPropName = \"__TAINT__\";\nconst TaintPropNameForDebug = \"__TAINT_DEBUG__\";\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/values/taint-info.js?");

/***/ }),

/***/ "./src/values/wrapped-values.js":
/*!**************************************!*\
  !*** ./src/values/wrapped-values.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConcolicValue: () => (/* binding */ ConcolicValue),\n/* harmony export */   TaintValue: () => (/* binding */ TaintValue),\n/* harmony export */   WrappedValue: () => (/* binding */ WrappedValue)\n/* harmony export */ });\n/* harmony import */ var _utils_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/util.js */ \"./src/utils/util.js\");\n// JALANGI DO NOT INSTRUMENT\n\nclass WrappedValue {\n  /**\n   * \n   * @TODO\n   * Append the origin location & type of the wrapped value to the constructor\n   * \n   * @param {*} concrete \n   */\n  constructor(concrete) {\n    Object.defineProperty(this, 'concrete', {\n        value: concrete,\n        enumerable: false,\n        writable: true,\n        configurable: true\n    });\n  }\n\n  clone() {\n    return new WrappedValue(this.concrete);\n  }\n\n  toString() {\n    return _utils_util_js__WEBPACK_IMPORTED_MODULE_0__.Utils.safeToString(this.concrete);\n  }\n\n  toStringInternal() {\n    return \"Wrapped(\" + _utils_util_js__WEBPACK_IMPORTED_MODULE_0__.Utils.safeToString(this.concrete) + \", \" + (this.rider ? this.rider.toString() : \"\") + \")\";\n  }\n\n  valueOf() {\n    return this.concrete ? this.concrete.valueOf() : this.concrete;\n  }\n\n  getConcrete() {\n    return this.concrete;\n  }\n}\n\nclass ConcolicValue extends WrappedValue { \n  constructor(concrete, symbolic, arrayType = undefined) {\n      super(concrete);\n      this.__defineProperty('symbolic', symbolic);\n      this.__defineProperty('_arrayType', arrayType);\n  }\n\n  __defineProperty(name, value){\n    Object.defineProperty(this, name, {\n        value: value,\n        enumerable: false,\n        writable: true,\n        configurable: true\n    });\n  }\n\n  toString() {\n    return _utils_util_js__WEBPACK_IMPORTED_MODULE_0__.Utils.safeToString(this.concrete);\n  }\n\n  toStringInternal() {\n    return \"Concolic(\" + _utils_util_js__WEBPACK_IMPORTED_MODULE_0__.Utils.safeToString(this.concrete) + \", \" + this.symbolic + \")\";\n  }\n\n  clone() {\n      return new ConcolicValue(this.concrete, this.symbolic);\n  }\n\n  getConcrete() {\n      return this.concrete;\n  }\n\n  getSymbolic() {\n      return this.symbolic;\n  }\n\n  getArrayType() {\n      return this._arrayType;\n  }\n\n}\n\nConcolicValue.getSymbolic = function(val) {\n  return val instanceof ConcolicValue ? val.symbolic : undefined;\n};\n\nConcolicValue.setSymbolic = function(val, val_s) {\n  if (val instanceof ConcolicValue) {\n      val.symbolic = val_s;\n  }\n};\n\n\n/**\n * @description\n * --------------------------------\n * TaintValue is a wrapper class for values that are tainted\n * Similar to ConcolicValue class, but with the addition of taint information\n * Ideally, all the JavaScript values can be wrapped with TaintValue\n * \n */\nclass TaintValue extends WrappedValue {\n  /**\n   * TaintValue constructor\n   * \n   * @param {*} concrete \n   * @param {TaintInfo} taintInfo \n   */\n  constructor(concrete, taintInfo) {\n    super(concrete);\n    this.__defineProperty('taintInfo', taintInfo);\n  }\n\n  __defineProperty(name, value){\n    Object.defineProperty(this, name, {\n        value: value,\n        enumerable: false,\n        writable: true,\n        configurable: true\n    });\n  }\n\n  /**\n   * This function should only be called by the analysis engine but not the user program\n   * \n   * There is no way to make sure that the user program will not call this function, so we\n   * will return the concrete value to make sure it will not break the program\n   * \n   * @returns \n   */\n  toString() {\n    if (J$$.analysis.DCHECK) {\n      try {\n        const error = new Error();\n        const stack = error.stack.split('\\n');\n  \n        const topFrames = stack.slice(2, 6); // 2,3,4,5\n        const hasValidCallSite = topFrames.some(frame => frame.includes('addTaintPropOperation') ||\n                                                         frame.includes('checkTaintAtSinkInvokeFun') ||\n                                                         frame.includes('checkTaintAtSinkPutField') ||\n                                                         frame.includes('defaultPutFieldModel') ||\n                                                         frame.includes('CustomElementRegistry.value'));                                                 \n        if (!hasValidCallSite) {\n          // Although we will concretize the base and args before running runOriginFunc\n          // But there are cases where the tainted valued is not stored in base or args and will be processed by the callback function\n          // passed in the runOriginFunc\n          // J$$.analysis.logger.debug('Unkown caller of TaintValue.toString.');\n          // debugger;\n          return _utils_util_js__WEBPACK_IMPORTED_MODULE_0__.Utils.safeToString(this.concrete);\n        }\n      } catch (e) {\n        J$$.analysis.logger.debug('Error during DebugCheck in toString.');\n      }\n    }\n\n    return _utils_util_js__WEBPACK_IMPORTED_MODULE_0__.Utils.safeToString(this.concrete);\n    // return \"TaintValue(\" + Utils.safeToString(this.concrete) + \")\";\n  }\n\n  toStringInternal() {\n    return \"TaintValue(\" + _utils_util_js__WEBPACK_IMPORTED_MODULE_0__.Utils.safeToString(this.concrete) + \")\";\n  }\n\n  clone() {\n    return new TaintValue(this.concrete, this.taintInfo);\n  }\n\n  getConcrete() {\n    return this.concrete;\n  }\n\n  getTaintInfo() {\n    return this.taintInfo;\n  }\n}\n\n\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/values/wrapped-values.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/entry.js");
/******/ 	
/******/ })()
;