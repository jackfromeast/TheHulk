// JALANGI DO NOT INSTRUMENT
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/coverage.js":
/*!*************************!*\
  !*** ./src/coverage.js ***!
  \*************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Coverage: () => (/* binding */ Coverage)\n/* harmony export */ });\n/* harmony import */ var _utils_iidToLocation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/iidToLocation.js */ \"./src/utils/iidToLocation.js\");\n// JALANGI DO NOT INSTRUMENT\n/**\n * Description:\n * --------------------------------\n * This script records the coverage information for the analysis.\n * \n * Usage: \n * --------------------------------\n */\n\n\nconst LAST_IID = \"LAST_IID\";\n\n/**\n * Bits for coverage info propagation\n */\n\nconst IS_TOUCHED = 0x1;\nconst CONDITIONAL_TRUE = 0x2;\nconst CONDITIONAL_FALSE = 0x4;\n\nclass Coverage {\n\n\t/**\n   * Creates an instance of Coverage.\n   * @param {any} sandbox The Jalangi sandbox\n   * _branches is an array of coverages for a given sid where the sid is branches[sid+1]\n   * @memberOf Coverage\n   */\n\tconstructor(sandbox) {\n\t\tthis._sandbox = sandbox;\n\t\tthis._branches = [];\n\t\tthis._branchFilenameMap = [];\n\t\tthis._lastIid = 0; //Store the last IID touched for search strategizer\n\n\t\tthis.brachTrace = {};\n\t}\n\n\tend() {\n\t\tconst payload = {\n\t\t\tcode: {}\n\t\t};\n\n\t\tfor (let i = 0; i < this._branches.length; i++) {\n            \n\t\t\t//SID are indexed from 1 not 0\n\t\t\tconst localSid = i + 1;\n\n\t\t\tif (this._branches[i] !== undefined) {\n\n\t\t\t\t//Deep copy the smap\n\t\t\t\tconst map = JSON.parse(JSON.stringify(this._sandbox.smap[localSid]));\n\n\t\t\t\t//Strip away any non SID related entities\n\t\t\t\tfor (const localIid in map) {\n\t\t\t\t\tif (isNaN(parseInt(localIid))) {\n\t\t\t\t\t\tdelete map[localIid];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmap[localIid] = (0,_utils_iidToLocation_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this._sandbox, localSid, localIid);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpayload[\"code\"][this._branchFilenameMap[i]] = {\n\t\t\t\t\tsmap: map,\n\t\t\t\t\tbranches: this._branches[i]\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tpayload[\"path\"] = this.brachTrace;\n\t\tpayload[LAST_IID] =\t this._lastIid;\n\t\treturn payload;\n\t}\n\n\tgetBranchInfo() {\n\n\t\t//-1 from 1-indexed sid to start from 0\n\t\tconst localIndex = this._sandbox.sid - 1;\n\t\tlet branchInfo = this._branches[localIndex];\n\n\t\tif (!branchInfo) {\n\t\t\tbranchInfo = {};\n\t\t\tthis._branches[localIndex] = branchInfo;\n\t\t\tconst map = this._sandbox.smap[this._sandbox.sid];\n\t\t\tthis._branchFilenameMap[localIndex] = map ? map.originalCodeFileName : \"Broken Filename\";\n\t\t}\n\n\t\treturn branchInfo;\n\t}\n\n\ttouch(iid) {\n\t\tthis.getBranchInfo()[iid] |= IS_TOUCHED;\n\t\tthis._lastIid = iid;\n\t}\n\n\ttouch_cnd(iid, result) {\n\t\tthis.touch(iid);\n\t\tthis.getBranchInfo()[iid] |= (result ? CONDITIONAL_TRUE : CONDITIONAL_FALSE);\n\n\t\tthis.touchBranch(iid, result);\n\t}\n\n\tlast() {\n\t\treturn this._lastIid || 0;\n\t}\n\n\ttouchBranch(iid, result) {\n\t\tlet binResult = result ? 1 : 0;\n\t\tlet gid = this._sandbox.sid + \":\" + iid;\n\n\t\tif(Object.keys(this.brachTrace).includes(gid)){\n\t\t\tthis.brachTrace[gid].push(binResult);\n\t\t}else{\n\t\t\tthis.brachTrace[gid] = [binResult];\n\t\t}\n\t}\n}\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/coverage.js?");

/***/ }),

/***/ "./src/entry.js":
/*!**********************!*\
  !*** ./src/entry.js ***!
  \**********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _taint_tracking_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./taint-tracking.js */ \"./src/taint-tracking.js\");\n/* harmony import */ var _taint_expose_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./taint-expose.js */ \"./src/taint-expose.js\");\n// JALANGI DO NOT INSTRUMENT\n/**\n * @description\n * --------------------------------\n * This script is the entrypoint of the analysis script which will \n * 1/ read the config file and apply it\n * 2/ install the analysis class to the J$.analysis  \n * \n * @usage \n * --------------------------------\n */\n\n\n// import { CountMostFrequentlyUsedBuiltinsAnalysis } from './others/most-frequently-used-api.js'\n\nif (J$$) {\n  J$$.analysis = new _taint_tracking_js__WEBPACK_IMPORTED_MODULE_0__.TaintTracking(J$$);\n  // J$$.analysis = new CountMostFrequentlyUsedBuiltinsAnalysis(J$$);\n} else{\n  throw \"[TheHulk] Analysis module cannot be installed. J$$ not found.\"\n}\n\n\n\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/entry.js?");

/***/ }),

/***/ "./src/rules/js-builtins/array-builtins.js":
/*!*************************************************!*\
  !*** ./src/rules/js-builtins/array-builtins.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArrayBuiltinsTaintPropRules: () => (/* binding */ ArrayBuiltinsTaintPropRules)\n/* harmony export */ });\n/* harmony import */ var _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../values/wrapped-values.js */ \"./src/values/wrapped-values.js\");\n/* harmony import */ var _values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../values/taint-info.js */ \"./src/values/taint-info.js\");\n/* harmony import */ var _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../rule-builder.js */ \"./src/rules/rule-builder.js\");\n/* harmony import */ var _rule_condition_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../rule-condition.js */ \"./src/rules/rule-condition.js\");\n/* harmony import */ var _rules_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../rules.js */ \"./src/rules/rules.js\");\n/* harmony import */ var _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../taint-helper.js */ \"./src/taint-helper.js\");\n/* harmony import */ var _utils_util_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utils/util.js */ \"./src/utils/util.js\");\n\n\n\n\n\n\n\n\nclass ArrayBuiltinsTaintPropRules {\n  constructor() {\n    this.ruleDict = [];\n    this.buildRules();\n\n    if (!_utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils) {\n      console.log('Utils is not defined');\n    }\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * We support rules for the array builtins that follow:\n   * 1/ The return value need to be tainted if one of the elements in the array is tainted \n   *    and is not the return value itself.\n   * 2/ The return value is in type of String, not Boolean.\n   * \n   * We also need to handle the case where the element is tainted and will cause the builtins panic:\n   * - TODO:\n   * \n   * Builtins that don't need to be handled:\n   * - Array.prototype.entries\n   * - Array.prototype.keys\n   * - Array.prototype.values\n   * - Array.prototype.push\n   * - Array.prototype.pop\n   * - etc.\n   * \n   * @TODO\n   * --------------------------------\n   * TODO: condition check function should also be added to the rules Dict\n   * E.g. condition: ANY_ARGS_TAINTED OR BASE_TAINTED, FIRST_ARG_TAINTED, etc.\n   * from builtins should use the FIRST_ARG_TAINTED condition\n   * Now, all of them use the ANY_ARGS_TAINTED OR BASE_TAINTED condition\n   */\n  supportedArrayBuiltins = {\n    'from': [Array.from, this.fromArrayModel, 'BASE_TAINTED || ANY_ARGS_TAINTED'],\n    'join': [Array.prototype.join, this.joinArrayModel, 'BASE_TAINTED || FIRST_ARG_TAINTED'],\n    'toString': [Array.prototype.toString, this.toStringArrayModel, 'BASE_TAINTED'],\n    'toLocaleString': [Array.prototype.toLocaleString, this.toLocaleStringArrayModel, 'BASE_TAINTED'],\n  };\n\n  /**\n   * @description\n   * --------------------------------\n   * Here is a list of builtins that uses none affected taint propagation rules.\n   * \n   * This means, even the arguments are tainted or the return value is tainted,\n   * we don't do anything but call the original function.\n   * \n   * We need to maintain this list becuase if invokeFunPre function doesn't find the \n   * rule for the builtins, it will concreate all the base and arguments and return value.\n   * Therefore, we need to explicitly set an none-affect builtins list.\n   * \n   */\n  noneAffectBuiltins = {\n    'push': Array.prototype.push,\n    'pop': Array.prototype.pop,\n    'shift': Array.prototype.shift,\n    'unshift': Array.prototype.unshift,\n    'slice': Array.prototype.slice,\n    'reverse': Array.prototype.reverse,\n    'sort': Array.prototype.sort,\n    'splice': Array.prototype.splice,\n    'forEach': Array.prototype.forEach,\n    'map': Array.prototype.map,\n    'concat': Array.prototype.concat,\n    'splice': Array.prototype.splice,\n    'values': Array.prototype.values,\n    'includes': Array.prototype.includes,\n    'filter': Array.prototype.filter,\n    'reduce': Array.prototype.reduce,\n    'every': Array.prototype.every,\n    'flatMap': Array.prototype.flatMap,\n    'findIndex': Array.prototype.findIndex,\n    'reduceRight': Array.prototype.reduceRight,\n    'keys': Array.prototype.keys,\n    'fill': Array.prototype.fill\n  }\n\n  buildRules() {\n    for (const [fName, fGroup] of Object.entries(this.supportedArrayBuiltins)) {\n      const condition = _rule_condition_js__WEBPACK_IMPORTED_MODULE_3__.ConditionBuilder.makeCondition(fGroup[2]);\n      const rule = _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__.RuleBuilder.makeRule(fGroup[0], condition, fGroup[1]);\n      this.addRule(fGroup[0], rule);\n    }\n\n    for (const [fName, fGroup_0] of Object.entries(this.noneAffectBuiltins)) {\n      const rule = _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__.RuleBuilder.makeNoneRule(fGroup_0);\n      this.addRule(fGroup_0, rule);\n    }\n  }\n\n  addRule(func, rule) {\n    this.ruleDict.push({ func, rule });\n  }\n\n  getRule(func) {\n    const found = this.ruleDict.find(x => x.func === func);\n    return found ? found.rule : null;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the from function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: FIRST_ARG_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * Array.from(arrayLike)\n   * Array.from(arrayLike, mapFn)\n   * Array.from(arrayLike, mapFn, thisArg)\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * Array.from(\"abc\", x => x + x)\n   * TAINTED(\"abc\") -> [TAINTED(\"aa\"), TAINTED(\"bb\"), TAINTED(\"cc\")]\n   * \n   * TYPE-2:\n   * RegExpStringIterator is an array-like object usually comes from the matchAll function.\n   * E.g. TAINTED(\"abcabdadc\").matchAll(/a/g)\n   * Array.from(RegExpStringIterator)\n   * TAINTED(RegExpStringIterator) -> [[TAINTED(\"a\"), index=?], [TAINTED(\"a\"), index=?], [TAINTED(\"a\"), index=?]]\n   * \n   * TYPE-3:\n   * Array.from([TAINTED(\"a\"), \"b\", \"c\"])\n   * -> [TAINTED(\"a\"), \"b\", \"c\"]\n   * \n   * @param {Function} f - The array built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  fromArrayModel(base, args, reflected, result, iid) {\n    let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.getTaintInfo(argsArray[0]);\n\n    if (!taintInfo) { return result; }\n\n    // TYPE-1\n    if (_utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.isString(argsArray[0])) {\n      for (let i = 0; i < result.length; i++) {\n        result[i] = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result[i], taintInfo);\n      }\n    }\n\n    // TYPE-2\n    else if (_utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.isRegExpStringIterator(argsArray[0])) {\n      for (let i = 0; i < result.length; i++) {\n        result[i][0] = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result[i][0], taintInfo);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the join function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED or FIRST_ARG_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * Array.prototype.join(separator)\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED([\"a\", \"b\", \"c\"]).join(\", \")\n   * -> TAINTED(\"a, b, c\")\n   * \n   * TYPE-2:\n   * TAINTED([\"a\", \"b\", \"c\"]).join(TAINTED(\", \"))\n   * -> TAINTED(\"a, b, c\")\n   * \n   * TYPE-3:\n   * The join function will call 'toString' on each element in the array.\n   * [['a', 'b'], [TAINTED('c'), 'd']].join(TAINTED(\", \"))\n   * -> TAINTED(\"a,b,c,d\")\n   * \n   * @param {Function} f - The array built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  joinArrayModel(base, args, reflected, result, iid) {\n    let taintInfo = null;\n    let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n\n    // TYPE-1\n    if (base instanceof _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__.TaintValue) {\n      taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.getTaintInfo(base);\n    }\n\n    // TYPE-2\n    if (!taintInfo && argsArray.length > 0 && argsArray[0] instanceof _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__.TaintValue) {\n      taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.getTaintInfo(argsArray[0]);\n    }\n\n    // TYPE-3\n    if (!taintInfo) {\n      taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n    }\n\n    if (taintInfo) {\n      taintInfo.addTaintPropOperation('join', [base, argsArray], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, taintInfo);\n    }\n\n    return result;\n  }\n\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the toString function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * Array.prototype.toString()\n   * \n   * @example\n   * --------------------------------\n   * CASE ONE:\n   * [TAINTED(\"a\"), \"b\", \"c\"].toString()\n   * -> TAINTED(\"a,b,c\")\n   * \n   * @param {Function} f - The array built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  toStringArrayModel(base, args, reflected, result, iid) {\n    let taintInfo = null;\n    if (_utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.isArray(base)) {\n      for (let element of base) {\n        if (element instanceof _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__.TaintValue) {\n          taintInfo = element.getTaintInfo();\n          break;\n        }\n      }\n    }\n\n    if (taintInfo) {\n      taintInfo.addTaintPropOperation('toString', [base], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, taintInfo);\n    }\n    \n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the toLocaleString function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * Array.prototype.toLocaleString()\n   * \n   * @example\n   * --------------------------------\n   * CASE ONE:\n   * [TAINTED(\"a\"), \"b\", \"c\"].toLocaleString()\n   * -> TAINTED(\"a,b,c\")\n   * \n   * @param {Function} f - The array built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  toLocaleStringArrayModel(base, args, reflected, result, iid) {\n    let taintInfo = null;\n    if (_utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.isArray(base)) {\n      for (let element of base) {\n        if (element instanceof _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__.TaintValue) {\n          taintInfo = element.getTaintInfo();\n          break;\n        }\n      }\n    }\n\n    if (taintInfo) {\n      taintInfo.addTaintPropOperation('toLocaleString', [base], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, taintInfo);\n    }\n    \n    return result;\n  }\n}\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/rules/js-builtins/array-builtins.js?");

/***/ }),

/***/ "./src/rules/js-builtins/string-builtins.js":
/*!**************************************************!*\
  !*** ./src/rules/js-builtins/string-builtins.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StringBuiltinsTaintPropRules: () => (/* binding */ StringBuiltinsTaintPropRules)\n/* harmony export */ });\n/* harmony import */ var _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../values/wrapped-values.js */ \"./src/values/wrapped-values.js\");\n/* harmony import */ var _values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../values/taint-info.js */ \"./src/values/taint-info.js\");\n/* harmony import */ var _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../rule-builder.js */ \"./src/rules/rule-builder.js\");\n/* harmony import */ var _rule_condition_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../rule-condition.js */ \"./src/rules/rule-condition.js\");\n/* harmony import */ var _rules_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../rules.js */ \"./src/rules/rules.js\");\n/* harmony import */ var _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../taint-helper.js */ \"./src/taint-helper.js\");\n/* harmony import */ var _utils_util_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utils/util.js */ \"./src/utils/util.js\");\n\n\n\n\n\n\n\n\nclass StringBuiltinsTaintPropRules {\n  constructor() {\n    this.ruleDict = [];\n    this.buildRules();\n\n    if (!_utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils) {\n      console.log('Utils is not defined');\n    }\n  }\n\n  supportedStringBuiltins = {\n    // Base or any argument is tainted\n    'at': [String.prototype.at, this.atStringModel, 'BASE_TAINTED || ANY_ARGS_TAINTED'],\n    'charAt': [String.prototype.charAt, this.charAtStringModel, 'BASE_TAINTED || ANY_ARGS_TAINTED'],\n    'replace': [String.prototype.replace, this.replaceStringModel, 'BASE_TAINTED || ANY_ARGS_TAINTED'],\n    'replaceAll': [String.prototype.replaceAll, this.replaceAllStringModel, 'BASE_TAINTED || ANY_ARGS_TAINTED'],\n    'concat': [String.prototype.concat, this.concatStringModel, 'BASE_TAINTED || ANY_ARGS_TAINTED'],\n\n    // Only base must be tainted\n    'charCodeAt': [String.prototype.charCodeAt, this.charCodeAtStringModel, 'BASE_TAINTED'],\n    'codePointAt': [String.prototype.codePointAt, this.codePointAtStringModel, 'BASE_TAINTED'],\n    'localeCompare': [String.prototype.localeCompare, this.localeCompareStringModel, 'BASE_TAINTED'],\n    'match': [String.prototype.match, this.matchStringModel, 'BASE_TAINTED'],\n    'matchAll': [String.prototype.matchAll, this.matchAllStringModel, 'BASE_TAINTED'],\n    'replace': [String.prototype.replace, this.replaceStringModel, 'BASE_TAINTED'],\n    'replaceAll': [String.prototype.replaceAll, this.replaceAllStringModel, 'BASE_TAINTED'],\n    'search': [String.prototype.search, this.searchStringModel, 'BASE_TAINTED'],\n    'slice': [String.prototype.slice, this.sliceStringModel, 'BASE_TAINTED'],\n    'split': [String.prototype.split, this.splitStringModel, 'BASE_TAINTED'],\n    'startsWith': [String.prototype.startsWith, this.startsWithStringModel, 'BASE_TAINTED'],\n    'toLocaleLowerCase': [String.prototype.toLocaleLowerCase, this.toLocaleLowerCaseStringModel, 'BASE_TAINTED'],\n    'toLocaleUpperCase': [String.prototype.toLocaleUpperCase, this.toLocaleUpperCaseStringModel, 'BASE_TAINTED'],\n    'toLowerCase': [String.prototype.toLowerCase, this.toLowerCaseStringModel, 'BASE_TAINTED'],\n    'toString': [String.prototype.toString, this.toStringStringModel, 'BASE_TAINTED'],\n    'toUpperCase': [String.prototype.toUpperCase, this.toUpperCaseStringModel, 'BASE_TAINTED'],\n    'toWellFormed': [String.prototype.toWellFormed, this.toWellFormedStringModel, 'BASE_TAINTED'],\n    'endsWith': [String.prototype.endsWith, this.endsWithStringModel, 'BASE_TAINTED'],\n    'includes': [String.prototype.includes, this.includesStringModel, 'BASE_TAINTED'],\n    'indexOf': [String.prototype.indexOf, this.indexOfStringModel, 'BASE_TAINTED'],\n    'isWellFormed': [String.prototype.isWellFormed, this.isWellFormedStringModel, 'BASE_TAINTED'],\n    'lastIndexOf': [String.prototype.lastIndexOf, this.lastIndexOfStringModel, 'BASE_TAINTED'],\n    'trim': [String.prototype.trim, this.trimStringModel, 'BASE_TAINTED'],\n    'trimEnd': [String.prototype.trimEnd, this.trimEndStringModel, 'BASE_TAINTED'],\n    'trimStart': [String.prototype.trimStart, this.trimStartStringModel, 'BASE_TAINTED'],\n    'valueOf': [String.prototype.valueOf, this.valueOfStringModel, 'BASE_TAINTED'],\n    'normalize': [String.prototype.normalize, this.normalizeStringModel, 'BASE_TAINTED'],\n    'padEnd': [String.prototype.padEnd, this.padEndStringModel, 'BASE_TAINTED'],\n    'padStart': [String.prototype.padStart, this.padStartStringModel, 'BASE_TAINTED'],\n    'repeat': [String.prototype.repeat, this.repeatStringModel, 'BASE_TAINTED'],\n\n    // Arguments only\n    'raw': [String.raw, this.rawStringModel, 'ANY_ARGS_TAINTED'],\n    'fromCharCode': [String.fromCharCode, this.fromCharCodeStringModel, 'ANY_ARGS_TAINTED'],\n    'fromCodePoint': [String.fromCodePoint, this.fromCodePointStringModel, 'ANY_ARGS_TAINTED'],\n  };\n\n  /**\n   * @description\n   * --------------------------------\n   * Build rules for each String builtin functions.\n   * Add the rule functions to the ruleDict.\n   */\n  buildRules() {\n    for (const [fName, fGroup] of Object.entries(this.supportedStringBuiltins)) {\n      const condition = _rule_condition_js__WEBPACK_IMPORTED_MODULE_3__.ConditionBuilder.makeCondition(fGroup[2]);\n      const rule = _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__.RuleBuilder.makeRule(fGroup[0], condition, fGroup[1]);\n      this.addRule(fGroup[0], rule);\n    }\n  }\n\n\n  /**\n   * @description\n   * --------------------------------\n   * Adds a rule to the rule dictionary.\n   * \n   * @param {Function} function - The builtin function.\n   * @param {Function} rule - The rule function to be added.\n   */\n  addRule(func, rule) {\n    this.ruleDict.push({func, rule});\n  }\n\n\n  /**\n   * @description\n   * --------------------------------\n   * Retrieves a rule for the specified putField operator.\n   * \n   * Currently, we propagate all the property lookups all the from a TaintValue\n   * Therefore, we return the rule with the key ('all', 'all')\n   * \n   * @param {string} operator - The unary operator.\n   * @returns {Function|null} The rule function if found, otherwise null.\n   */\n  getRule(func) {\n    const found = this.ruleDict.find(x => x.func === func);\n    return found ? found.rule : null;\n  }\n\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the fromCharCode function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: ANY_ARGS_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * String.fromCharCode(num1, num2, ..., numN)\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * String.fromCharCode(TAINTED(65), 66)\n   * -> TAINTED(\"AB\")\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  fromCharCodeStringModel(base, args, reflected, result, iid) {\n    let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(argsArray);\n\n    if (taintInfo) {\n      taintInfo.addTaintPropOperation('fromCharCode', [base, argsArray], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, taintInfo);\n    }\n    return result;\n  }\n\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the at function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED or ANY_ARGS_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.at(index)\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"abcdef\").at(2)\n   * -> TAINTED(\"c\")\n   * \n   * TYPE-2:\n   * \"abcdef\".at(TAINTED(2))\n   * -> TAINTED(\"c\")\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  atStringModel(base, args, reflected, result, iid) {\n    let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base) || _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(argsArray);\n\n    if (taintInfo) {\n      taintInfo.addTaintPropOperation('at', [base, argsArray], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, taintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the fromCodePoint function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: ANY_ARGS_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * String.fromCodePoint(num1, num2, ..., numN)\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * String.fromCodePoint(TAINTED(65), 66)\n   * -> TAINTED(\"AB\")\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  fromCodePointStringModel(base, args, reflected, result, iid) {\n    let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(argsArray);\n\n    if (taintInfo) {\n      taintInfo.addTaintPropOperation('fromCodePoint', [base, argsArray], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, taintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the raw function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: ANY_ARGS_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * String.raw(template, ...substitutions)\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(String.raw`Hello ${'world'}`)\n   * -> TAINTED(\"Hello world\")\n   * \n   * TYPE-2:\n   * String.raw`Hello ${TAINTED('world')}`\n   * -> TAINTED(\"Hello world\")\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  rawStringModel(base, args, reflected, result, iid) {\n    let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(argsArray);\n\n    if (taintInfo) {\n      taintInfo.addTaintPropOperation('raw', [base, argsArray], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, taintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the charAt function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED or ANY_ARGS_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.charAt(index)\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"abcdef\").charAt(2)\n   * -> TAINTED(\"c\")\n   * \n   * TYPE-2:\n   * \"abcdef\".charAt(TAINTED(2))\n   * -> TAINTED(\"c\")\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  charAtStringModel(base, args, reflected, result, iid) {\n    let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base) || _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(argsArray);\n\n    if (taintInfo) {\n      taintInfo.addTaintPropOperation('charAt', [base, argsArray], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, taintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the charCodeAt function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.charCodeAt(index)\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"abcdef\").charCodeAt(2)\n   * -> TAINTED(99)\n   * \n   * TYPE-2:\n   * \"abcdef\".charCodeAt(2)\n   * -> 99\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  charCodeAtStringModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n\n    if (taintInfo) {\n      let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n      taintInfo.addTaintPropOperation('charCodeAt', [base, argsArray], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, taintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the codePointAt function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.codePointAt(pos)\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"abc\").codePointAt(1)\n   * -> TAINTED(98)\n   * \n   * TYPE-2:\n   * \"abc\".codePointAt(1)\n   * -> 98\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  codePointAtStringModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n\n    if (taintInfo) {\n      let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n      taintInfo.addTaintPropOperation('codePointAt', [base, argsArray], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, taintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the concat function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED or ANY_ARGS_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * concat(str1, str2, ..., strN)\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"a\").concat(\"b\", \"c\")\n   * -> TAINTED(\"a,b,c\")\n   * \n   * TYPE-2:\n   * \"a\".concat(TAINTED(\"b\"), \"c\")\n   * -> TAINTED(\"a,b,c\")\n   * \n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  concatStringModel(base, args, reflected, result, iid) {\n    let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n    if (!taintInfo) {\n      taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(argsArray);\n    }\n\n    if (taintInfo) {\n      taintInfo.addTaintPropOperation('concat', [base, argsArray], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, taintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the endsWith function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.endsWith(searchString, [position])\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"Hello world\").endsWith(\"world\")\n   * -> TAINTED(true)\n   * \n   * TYPE-2:\n   * \"Hello world\".endsWith(TAINTED(\"world\"))\n   * -> true\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  endsWithStringModel(base, args, reflected, result, iid) {\n    if (_taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base)) {\n      const taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n      let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n      taintInfo.addTaintPropOperation('endsWith', [base, argsArray], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, taintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the includes function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.includes(searchString, [position])\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"Hello world\").includes(\"world\")\n   * -> TAINTED(true)\n   * \n   * TYPE-2:\n   * \"Hello world\".includes(TAINTED(\"world\"))\n   * -> true\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  includesStringModel(base, args, reflected, result, iid) {\n    if (_taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base)) {\n      const taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n      let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n      taintInfo.addTaintPropOperation('includes', [base, argsArray], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, taintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the indexOf function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.indexOf(searchValue, [fromIndex])\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"Hello world\").indexOf(\"world\")\n   * -> TAINTED(6)\n   * \n   * TYPE-2:\n   * \"Hello world\".indexOf(TAINTED(\"world\"))\n   * -> 6\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  indexOfStringModel(base, args, reflected, result, iid) {\n    if (_taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base)) {\n      const taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n      let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n      taintInfo.addTaintPropOperation('indexOf', [base, argsArray], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, taintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the isWellFormed function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.isWellFormed()\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"Hello world\").isWellFormed()\n   * -> TAINTED(true)\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  isWellFormedStringModel(base, args, reflected, result, iid) {\n    if (_taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base)) {\n      const taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n      let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n      taintInfo.addTaintPropOperation('isWellFormed', [base, argsArray], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, taintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the lastIndexOf function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.lastIndexOf(searchValue, [fromIndex])\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"Hello world\").lastIndexOf(\"world\")\n   * -> TAINTED(6)\n   * \n   * TYPE-2:\n   * \"Hello world\".lastIndexOf(TAINTED(\"world\"))\n   * -> 6\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  lastIndexOfStringModel(base, args, reflected, result, iid) {\n    if (_taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base)) {\n      const taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n      let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n      taintInfo.addTaintPropOperation('lastIndexOf', [base, argsArray], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, taintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the localeCompare function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED or FIRST_ARG_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.localeCompare(compareString, locales, options)\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"a\").localeCompare(\"b\")\n   * -> TAINTED(-1)\n   * \n   * TYPE-2:\n   * \"a\".localeCompare(TAINTED(\"b\"))\n   * -> TAINTED(-1)\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  localeCompareStringModel(base, args, reflected, result, iid) {\n    let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base) || _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(argsArray[0]);\n\n    if (taintInfo) {\n      taintInfo.addTaintPropOperation('localeCompare', [base, argsArray], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, taintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the match function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED or FIRST_ARG_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.match(regexp)\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"hello world\").match(/world/)\n   * -> TAINTED([\"world\"])\n   * \n   * TYPE-2:\n   * \"hello world\".match(TAINTED(/world/))\n   * -> TAINTED([\"world\"])\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  matchStringModel(base, args, reflected, result, iid) {\n    let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base) || _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(argsArray[0]);\n\n    if (taintInfo) {\n      taintInfo.addTaintPropOperation('match', [base, argsArray], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, taintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the matchAll function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED or FIRST_ARG_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.matchAll(regexp)\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"hello world\").matchAll(/world/)\n   * -> TAINTED([\"world\"])\n   * \n   * TYPE-2:\n   * \"hello world\".matchAll(TAINTED(/world/))\n   * -> TAINTED([\"world\"])\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  matchAllStringModel(base, args, reflected, result, iid) {\n    let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base) || _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(argsArray[0]);\n\n    if (taintInfo) {\n      taintInfo.addTaintPropOperation('matchAll', [base, argsArray], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, taintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the normalize function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.normalize([form])\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"Hello world\").normalize()\n   * -> TAINTED(\"Hello world\")\n   * \n   * TYPE-2:\n   * \"Hello world\".normalize()\n   * -> \"Hello world\"\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  normalizeStringModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n\n    if (taintInfo) {\n      let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n      taintInfo.addTaintPropOperation('normalize', [base, argsArray], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, taintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the padEnd function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.padEnd(targetLength, [padString])\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"abc\").padEnd(6)\n   * -> TAINTED(\"abc   \")\n   * \n   * TYPE-2:\n   * \"abc\".padEnd(6, TAINTED(\" \"))\n   * -> \"abc   \"\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  padEndStringModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n\n    if (taintInfo) {\n      let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n      taintInfo.addTaintPropOperation('padEnd', [base, argsArray], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, taintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the padStart function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.padStart(targetLength, [padString])\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"abc\").padStart(6)\n   * -> TAINTED(\"   abc\")\n   * \n   * TYPE-2:\n   * \"abc\".padStart(6, TAINTED(\" \"))\n   * -> \"   abc\"\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  padStartStringModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n\n    if (taintInfo) {\n      let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n      taintInfo.addTaintPropOperation('padStart', [base, argsArray], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, taintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the repeat function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.repeat(count)\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"abc\").repeat(2)\n   * -> TAINTED(\"abcabc\")\n   * \n   * TYPE-2:\n   * \"abc\".repeat(TAINTED(2))\n   * -> \"abcabc\"\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  repeatStringModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n\n    if (taintInfo) {\n      let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n      taintInfo.addTaintPropOperation('repeat', [base, argsArray], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, taintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the replace function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED or ANY_ARGS_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.replace(regexp|substr, newSubstr|function)\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"Hello world\").replace(\"world\", \"universe\")\n   * -> TAINTED(\"Hello universe\")\n   * \n   * TYPE-2:\n   * \"Hello world\".replace(TAINTED(\"world\"), \"universe\")\n   * -> TAINTED(\"Hello universe\")\n   * \n   * TYPE-3:\n   * \"Hello world\".replace(\"world\", TAINTED(\"universe\"))\n   * -> TAINTED(\"Hello universe\")\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  replaceStringModel(base, args, reflected, result, iid) {\n    let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base) || _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(argsArray);\n\n    if (taintInfo) {\n      taintInfo.addTaintPropOperation('replace', [base, argsArray], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, taintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the replaceAll function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED or ANY_ARGS_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.replaceAll(regexp|substr, newSubstr|function)\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"Hello world world\").replaceAll(\"world\", \"universe\")\n   * -> TAINTED(\"Hello universe universe\")\n   * \n   * TYPE-2:\n   * \"Hello world world\".replaceAll(TAINTED(\"world\"), \"universe\")\n   * -> TAINTED(\"Hello universe universe\")\n   * \n   * TYPE-3:\n   * \"Hello world world\".replaceAll(\"world\", TAINTED(\"universe\"))\n   * -> TAINTED(\"Hello universe universe\")\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  replaceAllStringModel(base, args, reflected, result, iid) {\n    let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base) || _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(argsArray);\n\n    if (taintInfo) {\n      taintInfo.addTaintPropOperation('replaceAll', [base, argsArray], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, taintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the search function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.search(regexp)\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"Hello world\").search(/world/)\n   * -> TAINTED(6)\n   * \n   * TYPE-2:\n   * \"Hello world\".search(TAINTED(/world/))\n   * -> 6\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  searchStringModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n\n    if (taintInfo) {\n      let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n      taintInfo.addTaintPropOperation('search', [base, argsArray], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, taintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the slice function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.slice(beginIndex, [endIndex])\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"Hello world\").slice(0, 5)\n   * -> TAINTED(\"Hello\")\n   * \n   * TYPE-2:\n   * \"Hello world\".slice(TAINTED(0), 5)\n   * -> \"Hello\"\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  sliceStringModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n\n    if (taintInfo) {\n      let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n      taintInfo.addTaintPropOperation('slice', [base, argsArray], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, taintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the split function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.split([separator], [limit])\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"Hello world\").split(\" \")\n   * -> TAINTED([\"Hello\", \"world\"])\n   * \n   * TYPE-2:\n   * \"Hello world\".split(TAINTED(\" \"), 1)\n   * -> [\"Hello\"]\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  splitStringModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n\n    if (taintInfo) {\n      let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n      taintInfo.addTaintPropOperation('split', [base, argsArray], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, taintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the startsWith function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.startsWith(searchString, [position])\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"Hello world\").startsWith(\"Hello\")\n   * -> TAINTED(true)\n   * \n   * TYPE-2:\n   * \"Hello world\".startsWith(TAINTED(\"Hello\"))\n   * -> true\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  startsWithStringModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n\n    if (taintInfo) {\n      let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n      taintInfo.addTaintPropOperation('startsWith', [base, argsArray], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, taintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the toLocaleLowerCase function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.toLocaleLowerCase()\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"Hello World\").toLocaleLowerCase()\n   * -> TAINTED(\"hello world\")\n   * \n   * TYPE-2:\n   * \"Hello World\".toLocaleLowerCase()\n   * -> \"hello world\"\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  toLocaleLowerCaseStringModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n\n    if (taintInfo) {\n      let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n      taintInfo.addTaintPropOperation('toLocaleLowerCase', [base, argsArray], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, taintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the toLocaleUpperCase function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.toLocaleUpperCase()\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"Hello World\").toLocaleUpperCase()\n   * -> TAINTED(\"HELLO WORLD\")\n   * \n   * TYPE-2:\n   * \"Hello World\".toLocaleUpperCase()\n   * -> \"HELLO WORLD\"\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  toLocaleUpperCaseStringModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n\n    if (taintInfo) {\n      let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n      taintInfo.addTaintPropOperation('toLocaleUpperCase', [base, argsArray], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, taintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the toLowerCase function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.toLowerCase()\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"Hello World\").toLowerCase()\n   * -> TAINTED(\"hello world\")\n   * \n   * TYPE-2:\n   * \"Hello World\".toLowerCase()\n   * -> \"hello world\"\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  toLowerCaseStringModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n\n    if (taintInfo) {\n      let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n      taintInfo.addTaintPropOperation('toLowerCase', [base, argsArray], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, taintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the toString function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.toString()\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"Hello World\").toString()\n   * -> TAINTED(\"Hello World\")\n   * \n   * TYPE-2:\n   * \"Hello World\".toString()\n   * -> \"Hello World\"\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  toStringStringModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n\n    if (taintInfo) {\n      let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n      taintInfo.addTaintPropOperation('toString', [base, argsArray], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, taintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the toUpperCase function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.toUpperCase()\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"Hello World\").toUpperCase()\n   * -> TAINTED(\"HELLO WORLD\")\n   * \n   * TYPE-2:\n   * \"Hello World\".toUpperCase()\n   * -> \"HELLO WORLD\"\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  toUpperCaseStringModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n\n    if (taintInfo) {\n      let argsArray = _utils_util_js__WEBPACK_IMPORTED_MODULE_6__.Utils.getArrayLikeArguments(args, reflected);\n      taintInfo.addTaintPropOperation('toUpperCase', [base, argsArray], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, taintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the toWellFormed function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.toWellFormed()\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"Hello World\").toWellFormed()\n   * -> TAINTED(\"Hello World\")\n   * \n   * TYPE-2:\n   * \"Hello World\".toWellFormed()\n   * -> \"Hello World\"\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  toWellFormedStringModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n\n    if (taintInfo) {\n      taintInfo.addTaintPropOperation('toWellFormed', [base], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, taintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the trim function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.trim()\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"  Hello world  \").trim()\n   * -> TAINTED(\"Hello world\")\n   * \n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  trimStringModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n\n    if (taintInfo) {\n      taintInfo.addTaintPropOperation('trim', [base], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, taintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the trimEnd function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.trimEnd()\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"  Hello world  \").trimEnd()\n   * -> TAINTED(\"  Hello world\")\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  trimEndStringModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n\n    if (taintInfo) {\n      taintInfo.addTaintPropOperation('trimEnd', [base], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, taintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the trimStart function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.trimStart()\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"  Hello world  \").trimStart()\n   * -> TAINTED(\"Hello world  \")\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  trimStartStringModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n\n    if (taintInfo) {\n      taintInfo.addTaintPropOperation('trimStart', [base], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, taintInfo);\n    }\n    return result;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Apply the taint propagation rule for the valueOf function.\n   * \n   * @condition\n   * --------------------------------\n   * Condition Barrier: BASE_TAINTED\n   * \n   * @usage\n   * --------------------------------\n   * str.valueOf()\n   * \n   * @example\n   * --------------------------------\n   * TYPE-1:\n   * TAINTED(\"Hello world\").valueOf()\n   * -> TAINTED(\"Hello world\")\n   * \n   * @param {Function} f - The string built-in function.\n   * @param {Array} args - The arguments to the function.\n   * @param {String} reflected - The reflected function name.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   * @returns {TaintValue | *} - The tainted result or the original result if no taint is present.\n   */\n  valueOfStringModel(base, args, reflected, result, iid) {\n    let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.rgetTaintInfo(base);\n\n    if (taintInfo) {\n      taintInfo.addTaintPropOperation('valueOf', [base], iid);\n      return _taint_helper_js__WEBPACK_IMPORTED_MODULE_5__.TaintHelper.createTaintValue(result, taintInfo);\n    }\n    return result;\n  }\n\n}\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/rules/js-builtins/string-builtins.js?");

/***/ }),

/***/ "./src/rules/operations/binary-ops.js":
/*!********************************************!*\
  !*** ./src/rules/operations/binary-ops.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BinaryOpsTaintPropRules: () => (/* binding */ BinaryOpsTaintPropRules)\n/* harmony export */ });\n/* harmony import */ var _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../values/wrapped-values.js */ \"./src/values/wrapped-values.js\");\n/* harmony import */ var _values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../values/taint-info.js */ \"./src/values/taint-info.js\");\n/* harmony import */ var _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../rule-builder.js */ \"./src/rules/rule-builder.js\");\n/* harmony import */ var _rules_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../rules.js */ \"./src/rules/rules.js\");\n/* harmony import */ var _taint_helper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../taint-helper.js */ \"./src/taint-helper.js\");\n\n\n\n\n\n\n/**\n * @description\n * --------------------------------\n * Class to manage taint propagation rules for binary operations.\n */\nclass BinaryOpsTaintPropRules {\n  constructor() {\n    this.ruleDict = [];\n    this.buildRules();\n    this.BinaryJumpTable = BinaryOpsTaintPropRules.BinaryJumpTable;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Build rules for each binary operator by iterating over BinaryJumpTable.\n   * Add the rule functions to the ruleDict.\n   */\n  buildRules() {\n    for (const operator in BinaryOpsTaintPropRules.BinaryJumpTable) {\n      const condition = (left, right) => _taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.isTainted(left) || _taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.isTainted(right);\n      const rule = _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__.RuleBuilder.makeRuleBinary(operator, condition);\n      this.addRule(operator, rule);\n    }\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Adds a rule to the rule dictionary.\n   * \n   * @param {string} operator - The binary operator.\n   * @param {Function} rule - The rule function to be added.\n   */\n  addRule(operator, rule) {\n    this.ruleDict.push({ operator, rule });\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Retrieves a rule for the specified binary operator.\n   * \n   * @param {string} operator - The binary operator.\n   * @returns {Function|null} The rule function if found, otherwise null.\n   */\n  getRule(operator) {\n    const found = this.ruleDict.find(x => x.operator === operator);\n    return found ? found.rule : null;\n  }\n\n\n  /**\n   * Table of binary operations and their corresponding functions.\n   */\n  static BinaryJumpTable = {\n    \"==\": function(left, right) { return left == right; },\n    \"===\": function(left, right) { return left === right; },\n    \"!=\": function(left, right) { return left != right; },\n    \"!==\": function(left, right) { return left !== right; },\n    \"<\": function(left, right) { return left < right; },\n    \">\": function(left, right) { return left > right; },\n    \"<=\": function(left, right) { return left <= right; },\n    \">=\": function(left, right) { return left >= right; },\n    \"+\": function(left, right) { return left + right; },\n    \"-\": function(left, right) { return left - right; },\n    \"*\": function(left, right) { return left * right; },\n    \"/\": function(left, right) { return left / right; },\n    \"%\": function(left, right) { return left % right; },\n    \">>\": function(left, right) { return left >> right; },\n    \"<<\": function(left, right) { return left << right; },\n    \">>>\": function(left, right) { return left >>> right; },\n    \"&\": function(left, right) { return left & right; },\n    \"&&\": function(left, right) { return left && right; },\n    \"|\": function(left, right) { return left | right; },\n    \"||\": function(left, right) { return left || right; },\n    \"^\": function(left, right) { return left ^ right; },\n    \"instanceof\": function(left, right) { return left instanceof right; },\n    \"in\": function(left, right) { return left in right; },\n    \"delete\": function(left, right) { return left[right] && delete left[right] }\n  };\n}\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/rules/operations/binary-ops.js?");

/***/ }),

/***/ "./src/rules/operations/get-field.js":
/*!*******************************************!*\
  !*** ./src/rules/operations/get-field.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GetFieldTaintPropRules: () => (/* binding */ GetFieldTaintPropRules)\n/* harmony export */ });\n/* harmony import */ var _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../values/wrapped-values.js */ \"./src/values/wrapped-values.js\");\n/* harmony import */ var _values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../values/taint-info.js */ \"./src/values/taint-info.js\");\n/* harmony import */ var _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../rule-builder.js */ \"./src/rules/rule-builder.js\");\n/* harmony import */ var _rules_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../rules.js */ \"./src/rules/rules.js\");\n/* harmony import */ var _taint_helper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../taint-helper.js */ \"./src/taint-helper.js\");\n\n\n\n\n\n\n\n/**\n * @description\n * --------------------------------\n * Class to manage taint propagation rules for property lookup operations.\n */\nclass GetFieldTaintPropRules {\n  constructor() {\n    this.ruleDict = [];\n    this.buildRules();\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Function to build rules for property lookup operations.\n   * \n   * Currently, we propagate all the property lookups all the from a TaintValue\n   * However, we can overwrite the rules afterwards\n   */\n  buildRules() {\n    const condition = (base, offset) => _taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.isTainted(base);\n    const rule = _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__.RuleBuilder.makeRuleGetField(condition, this.defaultGetFieldModel);\n    this.addRule('default', 'default', rule);\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Adds a rule to the rule dictionary.\n   * \n   * @param {string} operator - The unary operator.\n   * @param {Function} rule - The rule function to be added.\n   */\n  addRule(base, offset, rule) {\n    this.ruleDict.push({base, offset, rule});\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Retrieves a rule for the specified unary operator.\n   * \n   * Currently, we propagate all the property lookups all the from a TaintValue\n   * Therefore, we return the rule with the key ('all', 'all')\n   * \n   * @param {string} operator - The unary operator.\n   * @returns {Function|null} The rule function if found, otherwise null.\n   */\n  getRule(base, offset) {\n    const found = this.ruleDict.find(x => x.base === 'default');\n    return found ? found.rule : null;\n  }\n\n\n  /**\n   * @description\n   * --------------------------------\n   * Rule to propagate taint for property setting operations.\n   * \n   * @param {*} base \n   * @param {*} offset \n   * @param {*} val \n   */\n  defaultGetFieldModel(base, offset, val, iid) {\n    let offset_c = _taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.concrete(offset);\n    if (_taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.isTainted(base)) {\n      // TYPE-1\n      // If value itself is tainted, we don't need to create new taint value\n      if (_taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.isTainted(val)) {\n        let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.getTaintInfo(val);\n        taintInfo.addTaintPropOperation('getField', [base], iid);\n        // TODO: Not sure if the taintInfo will be updated through addTaintPropOperation\n      }\n\n      // TYPE-2\n      // If the base object itself is tainted while the val is not\n      else {\n        let taintInfo = _taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.getTaintInfo(base);\n        taintInfo.addTaintPropOperation('getField', [base], iid);\n        _taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.createTaintValue(val, taintInfo)\n      }\n    }else{\n      base[offset_c] = val;\n    }\n\n    return val;\n  }\n}\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/rules/operations/get-field.js?");

/***/ }),

/***/ "./src/rules/operations/put-field.js":
/*!*******************************************!*\
  !*** ./src/rules/operations/put-field.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PutFieldTaintPropRules: () => (/* binding */ PutFieldTaintPropRules)\n/* harmony export */ });\n/* harmony import */ var _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../values/wrapped-values.js */ \"./src/values/wrapped-values.js\");\n/* harmony import */ var _values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../values/taint-info.js */ \"./src/values/taint-info.js\");\n/* harmony import */ var _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../rule-builder.js */ \"./src/rules/rule-builder.js\");\n/* harmony import */ var _rules_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../rules.js */ \"./src/rules/rules.js\");\n/* harmony import */ var _taint_helper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../taint-helper.js */ \"./src/taint-helper.js\");\n\n\n\n\n\n\n\n/**\n * @description\n * --------------------------------\n * Class to manage taint propagation rules for property lookup operations.\n */\nclass PutFieldTaintPropRules {\n  constructor() {\n    this.ruleDict = [];\n    this.buildRules();\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Function to build rules for property setting operations.\n   * \n   * Setting properties on DOM nodes should always strip the taint.\n   */\n  buildRules() {\n    const condition = (base, offset, val) => { return true; };\n    const defaultRule = _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__.RuleBuilder.makeRulePutField(condition, this.defaultPutFieldModel);\n    this.addRule('default', 'default', defaultRule);\n\n    const DOMNodesPutFieldRule = _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__.RuleBuilder.makeRulePutField(condition, this.DOMNodesPutFieldModel);\n    this.addRule('DOMNodes', 'default', DOMNodesPutFieldRule);\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Adds a rule to the rule dictionary.\n   * \n   * @param {string} operator - The unary operator.\n   * @param {Function} rule - The rule function to be added.\n   */\n  addRule(base, offset, rule) {\n    this.ruleDict.push({base, offset, rule});\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Retrieves a rule for the specified putField operator.\n   * \n   * Currently, we propagate all the property lookups all the from a TaintValue\n   * Therefore, we return the rule with the key ('all', 'all')\n   * \n   * @param {string} operator - The unary operator.\n   * @returns {Function|null} The rule function if found, otherwise null.\n   */\n  getRule(base, offset) {\n    if (base instanceof Element) {\n      return this.ruleDict.find(x => x.base === 'DOMNodes').rule;\n    }else{\n      return this.ruleDict.find(x => x.base === 'default').rule;\n    }\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Rule to propagate taint for property setting operations.\n   * Always strip the taint from the value.\n   * \n   * @param {*} base \n   * @param {*} offset \n   * @param {*} val \n   */\n  DOMNodesPutFieldModel(base, offset, val, iid) {\n    if (!base instanceof Element) {\n      throw new Error('DOMNodesPutFieldModel: base is not an Element');\n    }\n\n    val = _taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.concrete(val);\n\n    let offset_c = _taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.concrete(offset);\n    if (_taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.isTainted(base)) {\n      _taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.concrete(base)[offset_c] = val;\n    }else{\n      base[offset_c] = val;\n    }\n\n    return val;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Rule to propagate taint for property setting operations.\n   * \n   * @param {*} base \n   * @param {*} offset \n   * @param {*} val \n   */\n  defaultPutFieldModel(base, offset, val, iid) {\n    let offset_c = _taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.concrete(offset);\n    if (_taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.isTainted(base)) {\n      _taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.concrete(base)[offset_c] = val;\n    }else{\n      base[offset_c] = val;\n    }\n\n    return val;\n  }\n}\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/rules/operations/put-field.js?");

/***/ }),

/***/ "./src/rules/operations/unary-ops.js":
/*!*******************************************!*\
  !*** ./src/rules/operations/unary-ops.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UnaryOpsTaintPropRules: () => (/* binding */ UnaryOpsTaintPropRules)\n/* harmony export */ });\n/* harmony import */ var _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../values/wrapped-values.js */ \"./src/values/wrapped-values.js\");\n/* harmony import */ var _values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../values/taint-info.js */ \"./src/values/taint-info.js\");\n/* harmony import */ var _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../rule-builder.js */ \"./src/rules/rule-builder.js\");\n/* harmony import */ var _rules_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../rules.js */ \"./src/rules/rules.js\");\n/* harmony import */ var _taint_helper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../taint-helper.js */ \"./src/taint-helper.js\");\n\n\n\n\n\n\n/**\n * @description\n * --------------------------------\n * Class to manage taint propagation rules for unary operations.\n */\nclass UnaryOpsTaintPropRules {\n  constructor() {\n    this.ruleDict = [];\n    this.buildRules();\n    this.UnaryJumpTable = UnaryOpsTaintPropRules.UnaryJumpTable;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Build rules for each unary operator by iterating over UnaryJumpTable.\n   * Add the rule functions to the ruleDict.\n   */\n  buildRules() {\n    for (const operator in this.UnaryJumpTable) {\n      const condition = (left) => _taint_helper_js__WEBPACK_IMPORTED_MODULE_4__.TaintHelper.isTainted(left);\n      const rule = _rule_builder_js__WEBPACK_IMPORTED_MODULE_2__.RuleBuilder.makeRuleUnary(operator, condition);\n      this.addRule(operator, rule);\n    }\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Adds a rule to the rule dictionary.\n   * \n   * @param {string} operator - The unary operator.\n   * @param {Function} rule - The rule function to be added.\n   */\n  addRule(operator, rule) {\n    this.ruleDict.push({operator, rule});\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Retrieves a rule for the specified unary operator.\n   * \n   * @param {string} operator - The unary operator.\n   * @returns {Function|null} The rule function if found, otherwise null.\n   */\n  getRule(operator) {\n    const found = this.ruleDict.find(x => x.operator === operator);\n    return found ? found.rule : null;\n  }\n\n  static UnaryJumpTable = {\n    \"!\": function(v) { return !v; },\n    \"~\": function(v) { return ~v; },\n    \"-\": function(v) { return -v; },\n    \"+\": function(v) { return +v; },\n    \"typeof\": function(v) { return typeof v; },\n    \"void\": function(v) { return void v; },\n  };\n\n  // TODO: need to handle typeof and void separately\n  // typeof and void that has been applied on a tainted value should return a normal value\n\n}\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/rules/operations/unary-ops.js?");

/***/ }),

/***/ "./src/rules/rule-builder.js":
/*!***********************************!*\
  !*** ./src/rules/rule-builder.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RuleBuilder: () => (/* binding */ RuleBuilder)\n/* harmony export */ });\n/* harmony import */ var _taint_helper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../taint-helper.js */ \"./src/taint-helper.js\");\n/* harmony import */ var _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../values/wrapped-values.js */ \"./src/values/wrapped-values.js\");\n/* harmony import */ var _values_taint_info_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../values/taint-info.js */ \"./src/values/taint-info.js\");\n/* harmony import */ var _operations_binary_ops_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./operations/binary-ops.js */ \"./src/rules/operations/binary-ops.js\");\n/**\n * RuleBuilder class\n * \n * @description\n * --------------------------------\n * A helper class for building rules for concolic execution.\n * \n * What is a rule?\n * --------------------------------\n * Rule is a function that is used to introduce/update/delete the symbolic information\n * associated with the arguments and results of operation (e.g., function call, binary operation, etc.), \n * based on the given context conditions.\n * \n * Therefore, a rule consists of the following components:\n * 1/ Built-in function or Operator, \n * 2/ Condition check function (verifies context conditions),\n * 3/ Modeling function\n * \n * All the rules should be built from the RuleBuilder class, while the modeling function\n * are coming from the corresponding rule classes.\n *\n */\n\n\n\n\n\n\n/**\n * @description\n * --------------------------------\n * The RuleFunctionPrototype constructor.\n * \n * All the rule functions should inherit this prototype for type checking.\n * That said, all the rule function's prototype should be the prototype of \n * RuleFunctionPrototype function.\n */\nfunction RuleFunctionPrototype() {\n  this.type = 'RuleFunction';\n}\n\nclass RuleBuilder {\n\n  /**\n   * @description\n   * --------------------------------\n   * Given the unary operator name, condition check function\n   * makeRule returns a function (rule) that intake the operand (left),\n   * and applies the rule to the function call.\n   * \n   * Currently, we generally adopt the following rule:\n   * If the left operator is TaintValue, we wrap the result with the TaintValue\n   * \n   * @param {string} operator - The unary operator.\n   * @param {Function} condition - The condition check function.\n   * @param {boolean} [concretize=true] - Whether to concretize the operand.\n   * @param {boolean} [featureDisabled=false] - Whether the feature is disabled.\n   * @returns {Function} The rule function.\n   */\n  static makeRuleUnary(operator, condition, concretize = true, featureDisabled = false) {\n    let newRule = (left, iid) => {\n      let result = UnaryJumpTable[operator](_taint_helper_js__WEBPACK_IMPORTED_MODULE_0__.TaintHelper.rconcrete(left));\n\n      if (!featureDisabled && condition(left)) {\n        let taintInfo;\n        taintInfo = left.getTaintInfo();\n        taintInfo.addTaintPropOperation(`UnaryOps: ${ops}`, [left], iid);\n        result = new _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_1__.TaintValue(result, taintInfo);\n      }\n\n      return result;\n    };\n\n    Object.setPrototypeOf(newRule, new RuleFunctionPrototype());\n    return newRule;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Given the binary operator name, condition check function\n   * makeRule returns a function (rule) that takes the operands (left, right),\n   * and applies the rule to the function call.\n   * \n   * Currently, we generally adopt the following rule:\n   * If either operand is a TaintValue, we wrap the result with the TaintValue\n   * \n   * @param {string} operator - The binary operator.\n   * @param {Function} condition - The condition check function.\n   * @param {boolean} [concretize=true] - Whether to concretize the operands.\n   * @param {boolean} [featureDisabled=false] - Whether the feature is disabled.\n   * @returns {Function} The rule function.\n   */\n  static makeRuleBinary(operator, condition, concretize = true, featureDisabled = false) {\n    let newRule = (left, right, iid) => {\n      let leftValue = _taint_helper_js__WEBPACK_IMPORTED_MODULE_0__.TaintHelper.rconcrete(left);\n      let rightValue = _taint_helper_js__WEBPACK_IMPORTED_MODULE_0__.TaintHelper.rconcrete(right);\n      let result = _operations_binary_ops_js__WEBPACK_IMPORTED_MODULE_3__.BinaryOpsTaintPropRules.BinaryJumpTable[operator](leftValue, rightValue);\n\n      if (!featureDisabled && condition(left, right)) {\n        let taintInfo;\n\n        if (left instanceof _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_1__.TaintValue || right instanceof _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_1__.TaintValue) {\n          taintInfo = new _values_taint_info_js__WEBPACK_IMPORTED_MODULE_2__.TaintInfo();\n          if (left instanceof _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_1__.TaintValue) taintInfo = left.getTaintInfo();\n          if (right instanceof _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_1__.TaintValue) taintInfo = right.getTaintInfo();\n\n          /**\n           * @TODO\n           * Need to handle the condition that both operands are taint value\n           */\n          \n          taintInfo.addTaintPropOperation(`BinaryOps: ${operator}`, [left, right], iid);\n          result = new _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_1__.TaintValue(result, taintInfo);\n        }\n      }\n\n      return result;\n    };\n\n\n    Object.setPrototypeOf(newRule, new RuleFunctionPrototype());\n    return newRule;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Creates a new rule.\n   * \n   * GetField operation is handle based on the base object type.\n   * \n   * The offset should always get concretized.\n   * Regarding the base object,\n   * 1/ If the base object is tainted and is primitive type (wrapped), \n   *    we concretize the base object and do the taint propagation.\n   * 2/ If the base object is tainted and is not primitive type (object, array, etc.),\n   *    we don't need to concretize the base object,\n   *    but it is also fine to concretize it in one layer.\n   * \n   * @TODO\n   * --------------------------------\n   * Currently, we don't do the taint propagation. No model function will be applied here\n   * \n   * @param {Function} f - The function to apply the rule to.\n   * @param {Function} condition - The condition check function.\n   * @param {Function} model - The modeling function.\n   * @returns {Object} The rule object.\n   */\n  static makeRuleGetField(condition, modelF, concretize = true, featureDisabled = false) {\n    let newRule = (base, offset, iid) => {\n      let base_c = _taint_helper_js__WEBPACK_IMPORTED_MODULE_0__.TaintHelper.concrete(base);\n      let offset_c = _taint_helper_js__WEBPACK_IMPORTED_MODULE_0__.TaintHelper.concrete(offset);\n      let result = base_c[offset_c];\n      \n      if (!featureDisabled && condition(base) && !(result instanceof Function)) {\n        result = modelF(base, offset, result, iid);\n      }\n\n      return result;\n    };\n\n    Object.setPrototypeOf(newRule, new RuleFunctionPrototype());\n    return newRule;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Creates a new rule.\n   * \n   * The makeRule function for the putField operation is *different* from the other operations.\n   * Because, for other operations, in the makeRule stage, we handle the behavior of the concrete field.\n   * But for the putField operation, the concrete field is handled in the modeling function.\n   * Because, it depends on whether the base object is a DOM Node or not.\n   * \n   * @param {Function} f - The function to apply the rule to.\n   * @param {Function} condition - The condition check function.\n   * @param {Function} model - The modeling function.\n   * @returns {Object} The rule object.\n   */\n  static makeRulePutField(condition, modelF, concretize = true, featureDisabled = false) {\n    let newRule = (base, offset, val, iid) => {\n\n      if (!featureDisabled && condition(val)) {\n        val = modelF(base, offset, val);\n      }\n\n      return val;\n    };\n\n    Object.setPrototypeOf(newRule, new RuleFunctionPrototype());\n    return newRule;\n  }\n\n\n\n  /**\n   * @description\n   * --------------------------------\n   * Creates a new rule.\n   * \n   * Given the function, condition check function, and modeling function,\n   * makeRule returns a function (rule) that intake the base object and arguments of the function call,\n   * and applies the rule to the function call.\n   * \n   * For the invokeFun rule, it has additional parameter `reflected` which indicates whether the function is reflected.\n   * This is because during the makeRule stage, we pass `f` as the real function, e.g. `String.fromCharCode`.\n   * However, in the program, when the rule has been called, it might used the reflected function, e.g. `String.fromCharCode.call`.\n   * The arguments of the reflected function are different from the real function, that the first argument is the base object.\n   * \n   * @param {Function} f - The function to apply the rule to.\n   * @param {Function} condition - The condition check function.\n   * @param {Function} model - The modeling function.\n   * @returns {Object} The rule object.\n   */\n  static makeRule(f, condition, modelF, concretize = true, featureDisabled = false) {\n    let newRule = (base, args, iid, reflected) => {\n      let [result, thrown] = this.runOriginFunc(f, base, args, concretize, reflected);\n\n      if (!featureDisabled && condition(base, args, reflected)) {\n          result = modelF(base, args, reflected, result, iid);\n      }\n\n      if (thrown) {\n          throw thrown;\n      }\n\n      return result;\n    };\n    Object.setPrototypeOf(newRule, new RuleFunctionPrototype());\n    return newRule;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Creates a new none-affect rule.\n   * \n   * The none-affect rule is rule that will not do anything but run the original function.\n   * This means, even the arguments are tainted or the return value is tainted,\n   * we don't do anything but call the original function without even concretization.\n   * \n   * There are builtins that you want to use this rule, e.g. `Array.prototype.push`. As you\n   * don't want to propagate the taint to the return array while you also don't want to lose the\n   * taint information of its elements.\n   * \n   * @param {Function} f - The function to apply the rule to.\n   */\n  static makeNoneRule(f) {\n    let newrule = (base, args, iid, reflected) => {\n      let [result, thrown] =  this.runOriginFunc(f, base, args, false, reflected);\n\n      if (thrown) {\n        throw thrown;\n      }\n\n      return result;\n    };\n    Object.setPrototypeOf(newrule, new RuleFunctionPrototype());\n    return newrule;\n  }\n\n\n  /**\n   * @description\n   * --------------------------------\n   * Executes a function with the provided base and arguments, optionally concretizing them.\n   * \n   * @notes\n   * --------------------------------\n   * We should be careful when using recursive concrete (rconcrete) function. It will make us lose\n   * the taint unintentionally. \n   * \n   * For example, for `Array.from([TAINTED(\"a\")]`, we will lose the taint information of the element if \n   * we use rconcrete. But we can pass the taint (make the taint alive) by using concrete + noneAffect model function.\n   * \n   * \n   * @param {Function} f - The function to execute.\n   * @param {Object} base - The base object for the function call.\n   * @param {Arguments} args - The arguments for the function call.\n   * @param {boolean} [concretize=true] - Whether to concretize the base and arguments.\n   * @returns {Array} An array containing the result of the function and any thrown error.\n   */\n  static runOriginFunc(f, base, args, concretize=true, reflected) {\n    let result, thrown;\n\n    try {\n      let c_base, c_args;\n      if (concretize==true) {\n        c_base = base !== null ? _taint_helper_js__WEBPACK_IMPORTED_MODULE_0__.TaintHelper.concrete(base) : base;\n        c_args = Array.from(args).map(item => _taint_helper_js__WEBPACK_IMPORTED_MODULE_0__.TaintHelper.concrete(item)); \n      } else {\n        c_base = base;\n        c_args = Array.from(args);\n      }\n      \n      if (reflected === \"apply\") {\n        result = Function.prototype.apply.call(f.apply, c_base, c_args);\n      }else if (reflected === \"call\") {\n        result = Function.prototype.apply.call(f.call, c_base, c_args);\n      }else {\n        result = Function.prototype.apply.call(f, c_base, c_args);\n      }\n    } catch (e) {\n      thrown = e;\n    }\n\n    return [result, thrown];\n  }\n}\n\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/rules/rule-builder.js?");

/***/ }),

/***/ "./src/rules/rule-concretized.js":
/*!***************************************!*\
  !*** ./src/rules/rule-concretized.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConcretizedFunctions: () => (/* binding */ ConcretizedFunctions)\n/* harmony export */ });\n/**\n * This class contains the list of functions that are known to be concretized\n */\nclass ConcretizedFunctions {\n  // List of functions known to be concretized\n  static concretizedList = [\n    // Array Object\n    Array.isArray,\n    Array.prototype.indexOf,\n    Array.prototype.some,\n    Array.prototype.includes,\n    Array.prototype.find,\n    Array.prototype.lastIndexOf,\n    Array.prototype.at\n\n  ];\n\n  // Method to check if a given function is in the concretized list\n  static isKnownConcretized(func) {\n    return ConcretizedFunctions.concretizedList.includes(func);\n  }\n}\n\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/rules/rule-concretized.js?");

/***/ }),

/***/ "./src/rules/rule-condition.js":
/*!*************************************!*\
  !*** ./src/rules/rule-condition.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConditionBuilder: () => (/* binding */ ConditionBuilder)\n/* harmony export */ });\n/* harmony import */ var _taint_helper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../taint-helper.js */ \"./src/taint-helper.js\");\n/* harmony import */ var _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../values/wrapped-values.js */ \"./src/values/wrapped-values.js\");\n/* harmony import */ var _values_taint_info_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../values/taint-info.js */ \"./src/values/taint-info.js\");\n\n\n\n\n/**\n * Condition Barrier Class\n * \n * @description\n * --------------------------------\n * This class generates the condition barrier for the taint propagation rules.\n * \n * Each condition barrier is a function that takes the base, arguments, and reflected object\n * and returns a boolean value to indicate whether the taint propagation rule should be applied.\n * \n * Currently, we support the following condition barriers:\n * - BASE_TAINTED: The base object is tainted.\n * - ANY_ARGS_TAINTED: Any of the arguments is tainted.\n * - FIRST_ARG_TAINTED: The first argument is tainted.\n * - SECOND_ARG_TAINTED: The second argument is tainted.\n * - LAST_ARG_TAINTED: The last argument is tainted.\n */\nclass ConditionBuilder {\n  static BASE_TAINTED(base, args, reflected) {\n    return _taint_helper_js__WEBPACK_IMPORTED_MODULE_0__.TaintHelper.risTainted(base);\n  }\n\n  static ANY_ARGS_TAINTED(base, args, reflected) {\n    return _taint_helper_js__WEBPACK_IMPORTED_MODULE_0__.TaintHelper.isAnyArgumentsTainted(args, reflected);\n  }\n\n  static FIRST_ARG_TAINTED(base, args, reflected) {\n    return args.length > 0 && _taint_helper_js__WEBPACK_IMPORTED_MODULE_0__.TaintHelper.risTainted(args[0]);\n  }\n\n  static SECOND_ARG_TAINTED(base, args, reflected) {\n    return args.length > 1 && _taint_helper_js__WEBPACK_IMPORTED_MODULE_0__.TaintHelper.risTainted(args[0]);\n  }\n\n  static LAST_ARG_TAINTED(base, args, reflected) {\n    return args.length > 0 && _taint_helper_js__WEBPACK_IMPORTED_MODULE_0__.TaintHelper.risTainted(args[args.length - 1]);\n  }\n\n  static NONE(base, args, reflected) {\n    return false;\n  }\n\n  static ALL(base, args, reflected) {\n    return true;\n  }\n\n  static validateConditionString(conditionString) {\n    const validConditions = ['BASE_TAINTED', 'ANY_ARGS_TAINTED', 'FIRST_ARG_TAINTED', 'SECOND_ARG_TAINTED', 'LAST_ARG_TAINTED', 'NONE', 'ALL'];\n    const conditionTokens = conditionString.split(/\\s*(&&|\\|\\|)\\s*/);\n    for (const token of conditionTokens) {\n      if (!validConditions.includes(token.trim()) && !['&&', '||'].includes(token.trim())) {\n        throw new Error(`Invalid condition: ${token}`);\n      }\n    }\n  }\n\n  static makeCondition(conditionString) {\n    ConditionBuilder.validateConditionString(conditionString);\n\n    const conditions = {\n      'BASE_TAINTED': this.BASE_TAINTED,\n      'ANY_ARGS_TAINTED': this.ANY_ARGS_TAINTED,\n      'FIRST_ARG_TAINTED': this.FIRST_ARG_TAINTED,\n      'SECOND_ARG_TAINTED': this.SECOND_ARG_TAINTED,\n      'LAST_ARG_TAINTED': this.LAST_ARG_TAINTED,\n      'NONE': this.NONE,\n      'ALL': this.ALL,\n    };\n\n    const conditionFunction = new Function('conditions', 'base', 'args', 'reflected', `\n      return ${conditionString\n        .replace(/BASE_TAINTED/g, 'conditions.BASE_TAINTED(base, args, reflected)')\n        .replace(/ANY_ARGS_TAINTED/g, 'conditions.ANY_ARGS_TAINTED(base, args, reflected)')\n        .replace(/FIRST_ARG_TAINTED/g, 'conditions.FIRST_ARG_TAINTED(base, args, reflected)')\n        .replace(/SECOND_ARG_TAINTED/g, 'conditions.SECOND_ARG_TAINTED(base, args, reflected)')\n        .replace(/LAST_ARG_TAINTED/g, 'conditions.LAST_ARG_TAINTED(base, args, reflected)')\n        .replace(/NONE/g, 'conditions.NONE(base, args, reflected)')\n        .replace(/ALL/g, 'conditions.ALL(base, args, reflected)')\n        .replace(/\\|\\|/g, '||')\n        .replace(/&&/g, '&&')};\n    `);\n\n    return (base, args, reflected) => conditionFunction(conditions, base, args, reflected);\n  }\n}\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/rules/rule-condition.js?");

/***/ }),

/***/ "./src/rules/rules.js":
/*!****************************!*\
  !*** ./src/rules/rules.js ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TaintPropRules: () => (/* binding */ TaintPropRules),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _operations_binary_ops_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./operations/binary-ops.js */ \"./src/rules/operations/binary-ops.js\");\n/* harmony import */ var _operations_unary_ops_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./operations/unary-ops.js */ \"./src/rules/operations/unary-ops.js\");\n/* harmony import */ var _operations_get_field_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./operations/get-field.js */ \"./src/rules/operations/get-field.js\");\n/* harmony import */ var _operations_put_field_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./operations/put-field.js */ \"./src/rules/operations/put-field.js\");\n/* harmony import */ var _js_builtins_string_builtins_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./js-builtins/string-builtins.js */ \"./src/rules/js-builtins/string-builtins.js\");\n/* harmony import */ var _js_builtins_array_builtins_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./js-builtins/array-builtins.js */ \"./src/rules/js-builtins/array-builtins.js\");\n// import StringBuiltinTaintPropRules from './string.js'\n\n\n\n\n\n\n\nclass TaintPropRules {\n  constructor() {\n    this.putFieldRules = new _operations_put_field_js__WEBPACK_IMPORTED_MODULE_3__.PutFieldTaintPropRules()\n    this.getFieldRules = new _operations_get_field_js__WEBPACK_IMPORTED_MODULE_2__.GetFieldTaintPropRules();\n    this.binaryRules = new _operations_binary_ops_js__WEBPACK_IMPORTED_MODULE_0__.BinaryOpsTaintPropRules();\n    this.unaryRules = new _operations_unary_ops_js__WEBPACK_IMPORTED_MODULE_1__.UnaryOpsTaintPropRules();\n\n    this.stringBuiltinsRules = new _js_builtins_string_builtins_js__WEBPACK_IMPORTED_MODULE_4__.StringBuiltinsTaintPropRules();\n    this.arrayBuiltinsRules = new _js_builtins_array_builtins_js__WEBPACK_IMPORTED_MODULE_5__.ArrayBuiltinsTaintPropRules();\n\n\n    this.invokeFunRules = this.aggregateRules([\n      this.stringBuiltinsRules.ruleDict,\n      this.arrayBuiltinsRules.ruleDict\n    ]);\n  }\n\n   /**\n   * Aggregates rules from the provided rule dictionaries.\n   * \n   * @param {Array} ruleDicts - An array of rule dictionaries to aggregate.\n   * @returns {Array} - The aggregated array of rules.\n   */\n   aggregateRules(ruleDicts) {\n    const rules = ruleDicts.flat();\n    \n    return {\n      rules,\n      getRule(fn) {\n        const found = rules.find(x => x.func === fn);\n        return found ? found.rule : null;\n      }\n    };\n  }\n\n  /**\n   * Adds a rule to the rule dictionary.\n   * \n   * @param {Function} fn - The function to which the rule applies.\n   * @param {Function} rule - The rule to be applied.\n   */\n  addRule(fn, rule) {\n    this.ruleDict.push({ fn, rule });\n  }\n\n  /**\n   * Retrieves a rule for the specified function.\n   * \n   * @param {Function} fn - The function for which the rule is retrieved.\n   * @returns {Function|null} The rule if found, otherwise null.\n   */\n  getRule(fn) {\n    const found = this.ruleDict.find(x => x.fn === fn);\n    return found ? found.rule : null;\n  }\n}\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TaintPropRules);\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/rules/rules.js?");

/***/ }),

/***/ "./src/taint-expose.js":
/*!*****************************!*\
  !*** ./src/taint-expose.js ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./values/wrapped-values.js */ \"./src/values/wrapped-values.js\");\n/* harmony import */ var _values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./values/taint-info.js */ \"./src/values/taint-info.js\");\n\n\n\nJ$$.wrapTaintWithIID = function (val, iid) {\n  let taintInfo = new _values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__.TaintInfo(iid, \"ManuallyAdded\", new _values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__.TaintPropOperation(\"ManuallyAdded\", []));\n  return new _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__.TaintValue(val, taintInfo);\n}\n\nJ$$.wrapTaint = function (val, iid) {\n  let taintInfo = new _values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__.TaintInfo(-1, \"ManuallyAdded\", new _values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__.TaintPropOperation(\"ManuallyAdded\", []));\n  return new _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__.TaintValue(val, taintInfo);\n}\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/taint-expose.js?");

/***/ }),

/***/ "./src/taint-helper.js":
/*!*****************************!*\
  !*** ./src/taint-helper.js ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TaintHelper: () => (/* binding */ TaintHelper)\n/* harmony export */ });\n/* harmony import */ var _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./values/wrapped-values.js */ \"./src/values/wrapped-values.js\");\n/* harmony import */ var _values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./values/taint-info.js */ \"./src/values/taint-info.js\");\n/* harmony import */ var _utils_util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/util.js */ \"./src/utils/util.js\");\n\n\n\n\n/**\n * @description\n * --------------------------------\n * This class defines the taint-related helper functions\n * This class help you check, add, merge, and remove taint information\n */\nclass TaintHelper {\n  \n  /**\n   * Create a new taint value\n   * @param {*} value \n   * @param {TaintInfo} taintInfo \n   */\n  static createTaintValue(value, taintInfo) {\n    if (value === undefined || value === null) {\n      return value;\n    }\n\n    // Check if value is tainted already\n    if (TaintHelper.isTainted(value)) {\n      // TODO: If it is already tainted, we need to merge the taint info\n      // Currently, we just return the value itself\n      return value;\n    }\n\n    if (_utils_util_js__WEBPACK_IMPORTED_MODULE_2__.Utils.isPrimitive(value)) {\n      if (J$$.analysis.debugPrint) {\n        _utils_util_js__WEBPACK_IMPORTED_MODULE_2__.Utils.debugPrint (\"Adding taint to \" + value);\n      }\n      return new _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__.TaintValue(value, taintInfo);\n    }\n    else {\n      try {\n        if (J$$.analysis.debugPrint) {\n          _utils_util_js__WEBPACK_IMPORTED_MODULE_2__.Utils.debugPrint (\"Adding taint to \" + value);\n        }\n        Object.defineProperty(value, _values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__.TaintPropName, {\n          value: taintInfo,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        });\n        return value;\n      }\n      catch (e) {\n        console.log(`Error in adding taint to ${value}: ${e}`);\n        return value;\n      }\n    }\n  }\n\n  static risTainted(value) {\n    if (TaintHelper.isTainted(value)) {\n      return true;\n    } else if (Array.isArray(value)) {\n      return value.some(item => TaintHelper.risTainted(item));\n    } else if (value && typeof value === 'object' && value.constructor === Object) {\n      return Object.keys(value).some(key => TaintHelper.risTainted(value[key]));\n    }\n    return false;\n  }\n\n  /**\n   * Check if the value is tainted in one level\n   * @param {*} value \n   * @returns \n   */\n  static isTainted(value) {\n    return value instanceof _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__.TaintValue || (!_utils_util_js__WEBPACK_IMPORTED_MODULE_2__.Utils.isPrimitive(value) && value[_values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__.TaintPropName]);\n  }\n\n  /**\n   * Concrete the value if it is tainted recursively\n   * \n   * Note that at most time, we don't need to concrete the value recursively\n   * \n   * - For the primitive types, we can just concrete them in one level\n   * - For the object types, we doesn't need to strip the taint as it \n   *   shouldn't affect the execution at most time\n   * \n   * @param {*} value \n   * @returns \n   */\n  static rconcrete(value) {\n\n    if (!TaintHelper.risTainted(value)) {\n      return value;\n    }\n\n    if (TaintHelper.isTainted(value)) {\n      return TaintHelper.concrete(value);\n    } else if (Array.isArray(value)) {\n      return value.map(item => TaintHelper.rconcrete(item));\n    } else if (value && typeof value === 'object' && value.constructor === Object) {\n      // This operation might be dangerous, because we will lose the keys that cannot be looped out\n      return Object.keys(value).reduce((acc, key) => {\n        acc[key] = TaintHelper.rconcrete(value[key]);\n        return acc;\n      }, {});\n    }\n\n    return value;\n  }\n\n  /**\n   * Concrete the value if it is tainted in one level\n   * @param {*} value \n   * @returns \n   */\n  static concrete(value) {\n    if (TaintHelper.isTainted(value)) {\n      if (value instanceof _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__.TaintValue) {\n        return value.getConcrete();\n      } else {\n        // If the value is not wrapped in TaintValue, but has taint info\n        // We return the value itself without getting rid of the taint info\n        return value;\n      }\n    }\n    return value;\n  }\n\n  static getTaintInfo(value) {\n    if (TaintHelper.isTainted(value)) {\n      if (value instanceof _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__.TaintValue) {\n        return value.getTaintInfo();\n      } else{\n        return value[_values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__.TaintPropName];\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * Recursively check and get nested arrays and objects for taint information.\n   * \n   * @TODO\n   * --------------------------------\n   * Now, we don't merge the taint information from different elements in the array.\n   * Or we should return multiple taint info if there are multiple taints and let the caller \n   * to merge them\n   * \n   * Now, we only support array and primitive types\n   * \n   * @param {Array|Object} value - The item to check for taint.\n   * @returns {TaintInfo|null} - The taint information if found, otherwise null.\n   */\n  static rgetTaintInfo(value) {\n    \n    if (TaintHelper.isTainted(value)) {\n      return TaintHelper.getTaintInfo(value);\n    }\n\n    if (Array.isArray(value)) {\n      for (let element of value) {\n        let taintInfo = TaintHelper.rgetTaintInfo(element);\n        if (taintInfo) return taintInfo;\n      }\n    }\n\n    return null;\n  }\n    \n  /**\n   * Check if any of the arguments are tainted\n   * If function has been called in this way: f.apply(this, args),\n   * We need to unwrap the args, because it is [arg1, arg2, ...]\n   * \n   * @param {Argruments} args \n   * @param {String} reflected \n   * @returns \n   */\n  static isAnyArgumentsTainted(args, reflected) {\n    if (args.length === 0) { return false; }\n\n    let argsArray = args;\n    if (_utils_util_js__WEBPACK_IMPORTED_MODULE_2__.Utils.isArguments(args)) {\n      argsArray = Array.from(args);\n    }\n    \n    if (reflected === 'apply') {\n      // For f.apply(this, args)\n      // If there is only one argument, it is the arg itself\n      // If there is more than one argument, it is [arg1, arg2, ...]\n      if (argsArray[1] instanceof Array) {\n        return argsArray[1].some(arg => TaintHelper.risTainted(arg));\n      } else {\n        return TaintHelper.risTainted(argsArray[1]);\n      }\n    }\n\n    return argsArray.some(arg => TaintHelper.risTainted(arg));\n  }\n}\n\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/taint-helper.js?");

/***/ }),

/***/ "./src/taint-sinks.js":
/*!****************************!*\
  !*** ./src/taint-sinks.js ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TaintSinkRules: () => (/* binding */ TaintSinkRules)\n/* harmony export */ });\n/* harmony import */ var _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./values/wrapped-values.js */ \"./src/values/wrapped-values.js\");\n/* harmony import */ var _values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./values/taint-info.js */ \"./src/values/taint-info.js\");\n\n\n\n\nclass TaintSinkRules {\n\n  /**\n   * @description\n   * --------------------------------\n   * This class defines the taint sink policy.\n   * This function will be invoked during the putField operation hook.\n   * \n   * SINK-TYPE-1-0:\n   * - SINK-TO-SCRIPT-SRC\n   * - Tainted value flows to the script.src property.\n   * - E.g. script.src = taintedValue\n   * - Conditions:\n   *   - `base` is a script element\n   *   - `offset` is 'src'\n   * \n   * SINK-TYPE-1-1:\n   * - SINK-TO-DOM-ELEMENT-INNERHTML\n   * - Tainted value flows to the innerHTML property of a DOM element.\n   * - E.g. element.innerHTML = taintedValue\n   * - Conditions:\n   *   - `base` is a DOM element\n   *   - `offset` is 'innerHTML'\n   * \n   * SINK-TYPE-1-2:\n   * - SINK-TO-DOM-ELEMENT-OUTERHTML\n   * - Tainted value flows to the outerHTML property of a DOM element.\n   * - E.g. element.outerHTML = taintedValue\n   * - Conditions:\n   *   - `base` is a DOM element\n   *   - `offset` is 'outerHTML'\n   * \n   * SINK-TYPE-1-3:\n   * - SINK-TO-DOM-ELEMENT-SRCDOC\n   * - Tainted value flows to the srcdoc property of an iframe element.\n   * - E.g. iframe.srcdoc = taintedValue\n   * - Conditions:\n   *   - `base` is an iframe element\n   *   - `offset` is 'srcdoc'\n   * \n   * SINK-TYPE-1-4:\n   * - SINK-TO-LINK-HREF\n   * - Tainted value flows to the srcdoc property of an iframe element.\n   * - E.g. link.rel = 'script'; link.href = taintedValue\n   * - Conditions:\n   *   - `base` is an link element\n   *   - `offset` is 'href'\n   *   - (`base.rel` is 'script') \n   *     sometimes rel attribute is defined after href attribute\n   * \n   * SINK-TYPE-2:\n   * - SINK-TO-WINDOW-LOCATION\n   * - Tainted value flows to the window.location property.\n   * - E.g. window.location = taintedValue\n   * - Conditions:\n   *   - `base` is the window object\n   *   - `offset` is 'location'\n   * \n   * SINK-TYPE-3:\n   * - SINK-TO-LOCATION-HREF\n   * - Tainted value flows to the href property of the window.location object.\n   * - E.g. window.location.href = taintedValue\n   * - Conditions:\n   *   - `base` is the window.location object\n   *   - `offset` is 'href'\n   * \n   * SINK-TYPE-4:\n   * - SINK-TO-DOCUMENT-COOKIE\n   * - Tainted value flows to the cookie property of the document object.\n   * - E.g. document.cookie = taintedValue\n   * - Conditions:\n   *   - `base` is the document object\n   *   - `offset` is 'cookie'\n   * \n   * SINK-TYPE-5:\n   * - SINK-TO-DOCUMENT-DOMAIN\n   * - Tainted value flows to the domain property of the document object.\n   * - E.g. document.domain = taintedValue\n   * - Conditions:\n   *   - `base` is the document object\n   *   - `offset` is 'domain'\n   * \n   * @param {*} base - The base object of the getField operation (which should not be a WrappedValue).\n   * @param {*} offset - The offset (property name) of the getField operation.\n   * @param {*} val - The value being assigned in the getField operation.\n   * @param {number} iid - The instruction id.\n   */\n  checkTaintAtSinkPutField(base, offset, val) {\n\n    if (!this.isTainted(val)) { return false; }\n    if (base instanceof _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__.WrappedValue) { base = base.getConcrete(); }\n\n    if (base instanceof Element) {\n      if (base.tagName && base.tagName.toUpperCase() === 'SCRIPT' && offset === 'src') {\n        return \"SINK-TO-SCRIPT-SRC\";\n      } else if (offset === 'innerHTML' || offset === 'outerHTML') {\n        return `SINK-TO-DOM-ELEMENT-${offset.toUpperCase()}`;\n      } else if (offset === 'srcdoc') {\n        return \"SINK-TO-DOM-ELEMENT-SRCDOC\";\n      } else if (base.tagName && base.tagName.toUpperCase() === 'LINK' && offset === 'href') {\n        return \"SINK-TO-LINK-HREF\";\n      }\n    }\n\n    if (base === window && offset === 'location') {\n      return \"SINK-TO-WINDOW-LOCATION\";\n    }\n\n    if (base === window.location && offset === 'href') {\n      return \"SINK-TO-LOCATION-HREF\";\n    }\n\n    if (base === document && offset === 'cookie') {\n      return \"SINK-TO-DOCUMENT-COOKIE\";\n    }\n\n    if (base === document && offset === 'domain') {\n      return \"SINK-TO-DOCUMENT-DOMAIN\";\n    }\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * This function will be invoked during the call operation hook\n   * \n   * @param {Function} f - The function that is being called.\n   * @param {*} base - The base object of the function call.\n   * @param {Array} args - The arguments to the function.\n   * @param {*} result - The result of the function.\n   * @param {number} iid - The instruction id.\n   */\n  checkTaintAtSinkInvokeFun(f, base, args) {\n\n    if (f.name === 'eval') {\n      if (args.length && this.isTainted(args[0])) {\n        return [\"SINK-TO-EVAL\", args[0]];\n      }\n    }\n\n    if (f.name === 'setTimeout' || f.name === 'setInterval') {\n      if (args.length && this.isTainted(args[0])) {\n        return [`SINK-TO-${f.name.toUpperCase()}`, args[0]];\n      }\n    }\n\n    if (base === document) {\n      if (f.name === 'write' || f.name === 'writeln') {\n        if (args.length && this.isTainted(args[0])) {\n          return [`SINK-TO-DOCUMENT-${f.name.toUpperCase()}`, args[0]];\n        }\n      }\n    }\n\n    if (f.name === 'insertAdjacentHTML' && this.isDOMElement(base)) {\n      if (args.length >= 2 && this.isTainted(args[1])) {\n        return [\"SINK-TO-INSERTADJACENTHTML\", args[1]];\n      }\n    }\n\n    if (f.name === 'setAttribute' && base && base.tagName && base.tagName.toUpperCase() === 'SCRIPT') {\n      if (args.length >= 2 && this.isTainted(args[1])) {\n        return [\"SINK-TO-SETATTRIBUTE-SCRIPT-SRC\", args[1]];\n      }\n    }\n\n    if (f.name === 'fetch') {\n      if (args.length && this.isTainted(args[0])) {\n        return [\"SINK-TO-FETCH\", args[0]];\n      }\n    }\n\n    if (base.toString() === '[object XMLHttpRequest]' && f.name === 'open') {\n      if (args.length && this.isTainted(args[1])) {\n        return [\"SINK-TO-XMLHTTPREQUEST-OPEN\", args[1]];\n      }\n    }\n\n    if (this.isLocationObject(base) && (f.name === 'replace' || f.name === 'assign')) {\n      if (args.length && this.isTainted(args[0])) {\n        return [`SINK-TO-LOCATION-${f.name.toUpperCase()}`, args[0]];\n      }\n    }\n\n    if (base === JSON && f.name === 'parse') {\n      if (args.length && this.isTainted(args[0])) {\n        return [\"SINK-TO-JSON-PARSE\", args[0]];\n      }\n    }\n\n    if ((base === window.localStorage || base === window.sessionStorage) && f.name === 'setItem') {\n      if (args.length && this.isTainted(args[1])) {\n        return [`SINK-TO-${base === window.localStorage ? 'LOCALSTORAGE' : 'SESSIONSTORAGE'}-SETITEM`, args[1]];\n      }\n    }\n\n    return [false, null];\n  }\n\n  isTainted(value) {\n    return value instanceof _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__.TaintValue;\n  }\n\n  isDOMElement(element) {\n    return element instanceof Element;\n  }\n\n  isLocationObject(obj) {\n    return obj === window.location || obj === location;\n  }\n\n}\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/taint-sinks.js?");

/***/ }),

/***/ "./src/taint-sources.js":
/*!******************************!*\
  !*** ./src/taint-sources.js ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TaintSourceRules: () => (/* binding */ TaintSourceRules)\n/* harmony export */ });\n/* harmony import */ var _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./values/wrapped-values.js */ \"./src/values/wrapped-values.js\");\n/* harmony import */ var _values_taint_info_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./values/taint-info.js */ \"./src/values/taint-info.js\");\n\n\n\n/**\n * @description\n * --------------------------------\n * This class defines the taint source policy\n * The taint source listed below is *over-approximated*, \n * that we assume we can control the DOM elements (through DOM Clobbering & DOM APIs).\n * \n */\nclass TaintSourceRules {\n  /**\n   * @description\n   * --------------------------------\n   * This function will be invoked during the getField operation hook\n   * \n   * SOURCE-TYPE-1: \n   * - SOURCE-FROM-DOM-ELEMENT\n   * - Value flows from the DOM Elements as taint sources\n   * - E.g. image.src, script.src, iframe.src, etc.\n   * \n   * SOURCE-TYPE-2: \n   * - SOURCE-FROM-DOCUMENT\n   * - Value flows from the document object as taint sources\n   * - E.g. document.cookie, document.domain, document.doctype, and etc.\n   * \n   * SOURCE-TYPE-3:\n   * - SOURCE-FROM-WINDOW\n   * - Value flows from the window object as taint sources\n   * - This is potentially clobberable if there is:\n   *   !window.MathJax && window.MathJax = ...\n   *   Tracing a defined value might be a good idea\n   * - E.g. window.MathJax\n   * \n   * @param {*} base - The base object of the getField operation. (which not be a WrappedValue)\n   * @param {*} offset - The offset of the getField operation.\n   * @param {*} val - The value of the getField operation.\n   * @param {number} iid - The instruction id.\n   */\n  shouldTaintSourceAtGetField(base, offset, val, iid) {\n    // SOURCE-TYPE-1:\n    // Check if the base is a DOM element\n    if (this.isDOMElement(base) && \n        !this.isFunction(val)) {\n      return \"SOURCE-FROM-DOM-ELEMENT\";\n    }\n\n    // SOURCE-TYPE-2:\n    // Check if the base is the document object\n    if (this.isDocumentObject(base) &&\n        !this.isFunction(val)) {\n      return \"SOURCE-FROM-DOCUMENT\";\n    }\n\n    // SOURCE-TYPE-3:\n    // Check if the base is the window object\n    if (this.isWindowObject(base) &&\n        !this.isFunction(val)) {\n      return \"SOURCE-FROM-WINDOW\";\n    }\n\n    return false;\n  }\n\n  /**\n   * @description\n   * --------------------------------\n   * This function will be invoked during the invokeFun operation hook\n   * \n   * SOURCE-TYPE-3:\n   * - SOURCE-FROM-BROWSER-API\n   * - Value flows from the browser APIs as taint sources\n   * - E.g. exampleAttr = div1.getAttribute(\"id\");\n   * - Conditions:\n   *   - `base` is a DOM Element or the document object\n   *   - `f`is a built-in function\n   *   - `result` is not a function (we don't taint functions)\n   *   - `f.name` is not in the blacklistForBrowserAPIs\n   * \n   * @param {Function} f - The function being invoked.\n   * @param {*} base - The base object of the getField operation. (which should not be a WrappedValue)\n   * @param {Array} args - The arguments passed to the function.\n   * @param {*} result - The result of the getField operation.\n   * @param {number} iid - The instruction id.\n   */\n  shouldTaintSourceAtInvokeFun(f, base, args, result, iid) {\n    if (this.isBuiltInFunction(f) && \n       (this.isDOMElement(base) || this.isDocumentObject(base)) &&\n       !this.isBuiltInFunction(result) &&\n       !this.blacklistForBrowserAPIs.includes(f.name)) {\n        return \"SOURCE-FROM-BROWSER-API\";\n    }\n\n    return false;\n  }\n\n  isDOMElement(element) {\n    return element instanceof Element;\n  }\n\n  isDocumentObject(obj) {\n    return obj === document;\n  }\n\n  isWindowObject(obj) {\n    return obj === window;\n  }\n\n  isBuiltInFunction(f) {\n    return typeof f === 'function' && (f === Object.prototype.toString.call(f).indexOf('[native code]') !== -1);\n  }\n\n  isFunction(f) {\n    return typeof f === 'function';\n  }\n\n  blacklistForBrowserAPIs = [\n    'createElement',\n    'appendChild',\n    'insertBefore',\n    'insertAdjacentElement',\n    'insertAdjacentHTML',\n    'insertAdjacentText',\n    'insertAdjacentElement',\n  ];\n}\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/taint-sources.js?");

/***/ }),

/***/ "./src/taint-tracking.js":
/*!*******************************!*\
  !*** ./src/taint-tracking.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TaintTracking: () => (/* binding */ TaintTracking)\n/* harmony export */ });\n/* harmony import */ var _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/logger.js */ \"./src/utils/logger.js\");\n/* harmony import */ var _coverage_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./coverage.js */ \"./src/coverage.js\");\n/* harmony import */ var _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./values/wrapped-values.js */ \"./src/values/wrapped-values.js\");\n/* harmony import */ var _values_taint_info_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./values/taint-info.js */ \"./src/values/taint-info.js\");\n/* harmony import */ var _rules_rules_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rules/rules.js */ \"./src/rules/rules.js\");\n/* harmony import */ var _taint_sources_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./taint-sources.js */ \"./src/taint-sources.js\");\n/* harmony import */ var _taint_sinks_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./taint-sinks.js */ \"./src/taint-sinks.js\");\n/* harmony import */ var _taint_helper_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./taint-helper.js */ \"./src/taint-helper.js\");\n/* harmony import */ var _utils_util_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/util.js */ \"./src/utils/util.js\");\n/* harmony import */ var _rules_rule_concretized_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./rules/rule-concretized.js */ \"./src/rules/rule-concretized.js\");\n// JALANGI DO NOT INSTRUMENT\n/**\n * @description\n * --------------------------------\n * This script holds the concolic execution behaviors which will be invoked by the jalangi2 runtime.\n * This script will load and execute in the browser environment.\n * \n * @notes\n * --------------------------------\n * Ideally, the analysis class should not directly manipulate TaintValues; this should be managed by\n * sources, sinks, and taint propagation rules. \n * The analysis should simply apply the appropriate rules for each operation hook.\n * \n * @usage \n * --------------------------------\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass TaintTracking {\n  constructor(sandbox) {\n    this.taintID = 0;\n    this.sandbox = sandbox;\n    this.coverage = new _coverage_js__WEBPACK_IMPORTED_MODULE_1__.Coverage(sandbox);\n    this.logger = new _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Logger('debug', 'TaintTracking');\n\n    this.taintPropRules = new _rules_rules_js__WEBPACK_IMPORTED_MODULE_4__.TaintPropRules();\n    this.taintSourceRules = new _taint_sources_js__WEBPACK_IMPORTED_MODULE_5__.TaintSourceRules();\n    this.taintSinkRules = new _taint_sinks_js__WEBPACK_IMPORTED_MODULE_6__.TaintSinkRules();\n\n    this.dangerousFlows = [];\n\n    this.debugPrint = true;\n  }\n\n  /**\n   * This callback is called before a binary operation. Binary operations include  +, -, *, /, %, &, |, ^,\n   * <<, >>, >>>, <, >, <=, >=, ==, !=, ===, !==, instanceof, delete, in.  No callback for <code>delete x</code>\n   * because this operation cannot be performed reflectively.\n   *  \n   * @notes\n   * We always skip the original binary operation and let binary handle the operation.\n   * \n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {string} op - Operation to be performed\n   * @param {*} left - Left operand\n   * @param {*} right - Right operand\n   * @param {boolean} isOpAssign - True if the binary operation is part of an expression of the form\n   * <code>x op= e</code>\n   * @param {boolean} isSwitchCaseComparison - True if the binary operation is part of comparing the discriminant\n   * with a consequent in a switch statement.\n   * @param {boolean} isComputed - True if the operation is of the form <code>delete x[p]</code>, and false\n   * otherwise (even if the operation if of the form <code>delete x.p</code>)\n   * @returns {{op: string, left: *, right: *, skip: boolean}|undefined} - If an object is returned and the\n   * <tt>skip</tt> property is true, then the binary operation is skipped.  Original <tt>op</tt>, <tt>left</tt>,\n   * and <tt>right</tt> are replaced with that from the returned object if an object is returned.\n   */\n  binaryPre (iid, op, left, right, isOpAssign, isSwitchCaseComparison, isComputed) {\n    return {op: op, left: left, right: right, skip: true};\n  };\n\n  /**\n   * This callback is called after a binary operation. Binary operations include  +, -, *, /, %, &, |, ^,\n   * <<, >>, >>>, <, >, <=, >=, ==, !=, ===, !==, instanceof, delete, in.\n   *\n   * @steps\n   * 1/ Apply the taint propagation rules for the binary operation if one of the operands is tainted.\n   * \n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {string} op - Operation to be performed\n   * @param {*} left - Left operand\n   * @param {*} right - Right operand\n   * @param {undefined} result - Always undefined, as we skip the original binary operation\n   * @param {boolean} isOpAssign - True if the binary operation is part of an expression of the form\n   * <code>x op= e</code>\n   * @param {boolean} isSwitchCaseComparison - True if the binary operation is part of comparing the discriminant\n   * with a consequent in a switch statement.\n   * @param {boolean} isComputed - True if the operation is of the form <code>delete x[p]</code>, and false\n   * otherwise (even if the operation if of the form <code>delete x.p</code>)\n   * @returns {{result: *}|undefined} - If an object is returned, the result of the binary operation is\n   * replaced with the value stored in the <tt>result</tt> property of the object.\n   */\n  binary (iid, op, left, right, result, isOpAssign, isSwitchCaseComparison, isComputed) {\n    let rule = this.taintPropRules.binaryRules.getRule(op);\n    if (rule) {\n      result = rule(left, right, iid);\n    } else {\n      result = this.taintPropRules.binaryRules.BinaryJumpTable[op](left, right);\n    }\n\n    return {result: result};\n  };\n\n  /**\n   * This callback is called before a unary operation. Unary operations include  +, -, ~, !, typeof, void.\n   *  \n   * @notes\n   * We always skip the original unary operation and let unary handle the operation.\n   * \n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {string} op - Operation to be performed\n   * @param {*} left - Left operand\n   * @returns {{op: *, left: *, skip: boolean} | undefined} If an object is returned and the\n   * <tt>skip</tt> property is true, then the unary operation is skipped.  Original <tt>op</tt> and <tt>left</tt>\n   * are replaced with that from the returned object if an object is returned.\n   */\n  unaryPre (iid, op, left) {\n      return {op: op, left: left, skip: true};\n  };\n\n  /**\n   * This callback is called after a unary operation. Unary operations include  +, -, ~, !, typeof, void.\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {string} op - Operation to be performed\n   * @param {*} left - Left operand\n   * @param {*} result - The result of the unary operation\n   * @returns {{result: *}|undefined} - If an object is returned, the result of the unary operation is\n   * replaced with the value stored in the <tt>result</tt> property of the object.\n   *\n   */\n  unary (iid, op, left, result) {    \n    let rule = this.taintPropRules.unaryRules.getRule(op);\n    if (rule) {\n      result = rule(left, iid);\n    } else {\n      result = this.taintPropRules.unaryRules.UnaryJumpTable[op](left);\n    }\n\n    return {result: result};\n  };\n\n\n  /**\n   * This callback is called after a condition check before branching. Branching can happen in various statements\n   * including if-then-else, switch-case, while, for, ||, &&, ?:.\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {*} result - The value of the conditional expression\n   * @returns {{result: *}|undefined} - If an object is returned, the result of the conditional expression is\n   * replaced with the value stored in the <tt>result</tt> property of the object.\n   */\n  conditional (iid, result) {\n    return {result: result};\n  };\n\n  /**\n   * This callback is called before a string passed as an argument to eval or Function is instrumented.\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {*} code - Code that is going to get instrumented\n   * @param {boolean} isDirect - true if this is a direct call to eval\n   * @returns {{code: *, skip: boolean}} - If an object is returned and the\n   * <tt>skip</tt> property is true, then the instrumentation of <tt>code</tt> is skipped.\n   * Original <tt>code</tt> is replaced with that from the returned object if an object is returned.\n   */\n  instrumentCodePre (iid, code, isDirect) {\n    return {code: code, skip: false};\n  };\n\n  /**\n   * This callback is called after a string passed as an argument to eval or Function is instrumented.\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {*} newCode - Instrumented code\n   * @param {Object} newAst - The AST of the instrumented code\n   * @param {boolean} isDirect - true if this is a direct call to eval\n   * @returns {{result: *}|undefined} - If an object is returned, the instrumented code is\n   * replaced with the value stored in the <tt>result</tt> property of the object.\n   */\n  instrumentCode (iid, newCode, newAst, isDirect) {\n      return {result: newCode};\n  };\n\n\n  /**\n   * This callback is called before a function, method, or constructor invocation.\n   * \n   * @example\n   * y.f(a, b, c)\n   * --------------------------------\n   * var skip = false;\n   * var aret = analysis.invokeFunPre(113, f, y, [a, b, c], false, true);\n   * if (aret) {\n   *     f = aret.f;\n   *     y = aret.y;\n   *     args = aret.args;\n   *     skip = aret.skip\n   * }\n   * if (!skip) {\n   *     f.apply(y, args);\n   * }\n   * \n   * @steps\n   * 1/ Check the taint value at the sink function call.\n   * 2/ If a taint value is passed, check whether the function is a built-in function\n   *    and has the taint propagation rules.\n   * 3/ If the function is a built-in function and has the taint propagation rules,\n   *    we update the taint information on the return value.\n   * 4/ If the function is a built-in function and has no taint propagation rules,\n   *    we concretize the taint value and apply the original function. Concretization\n   *    will be logged.\n   * 5/ Log the coverage information for the analysis.\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {function} f - The function object that going to be invoked\n   * @param {object} base - The receiver object for the function <tt>f</tt>\n   * @param {Arguments} args - The array of arguments passed to <tt>f</tt>\n   * @param {boolean} isConstructor - True if <tt>f</tt> is invoked as a constructor\n   * @param {boolean} isMethod - True if <tt>f</tt> is invoked as a method\n   * @param {number} functionIid - The iid (i.e. the unique instruction identifier) where the function was created\n   * @param {number} functionSid - The sid (i.e. the unique script identifier) where the function was created\n   * {@link MyAnalysis#functionEnter} when the function <tt>f</tt> is executed.  The <tt>functionIid</tt> can be\n   * treated as the static identifier of the function <tt>f</tt>.  Note that a given function code block can\n   * create several function objects, but each such object has a common <tt>functionIid</tt>, which is the iid\n   * that is passed to {@link MyAnalysis#functionEnter} when the function executes.\n   * @returns {{f: function, base: Object, args: Arguments, skip: boolean}|undefined} - If an object is returned and\n   * the <tt>skip</tt> property of the object is true, then the invocation operation is skipped.\n   * Original <tt>f</tt>, <tt>base</tt>, and <tt>args</tt> are replaced with that from the returned object if\n   * an object is returned. The args should has Arguments type as it will passed to the InvokeFun operation.\n   */\n  invokeFunPre (iid, f, base, args, isConstructor, isMethod, functionIid, functionSid) {\n    let [reason, taintedArg] = this.taintSinkRules.checkTaintAtSinkInvokeFun(f, base, args);\n    if (reason) {\n      // TODO: Handle multiple tainted arguments here\n      _utils_util_js__WEBPACK_IMPORTED_MODULE_8__.Utils.reportDangerousFlow(\n        taintedArg.getTaintInfo().getTaintSource().reason,\n        taintedArg.getTaintInfo().getTaintSource().location,\n        reason,\n        iid,\n        taintedArg,\n        iid\n      )\n    }\n\n    // Check if the function is a built-in function\n    // Functions can be called in different ways, \n    // e.g. y.f(arg1, arg2, ...), y.f.call(this, arg1, arg2), y.f.apply(this, args)\n    // - y.f(arg1, arg2, ...) => base = y, f = y.f, args = [arg1, arg2, ...]\n    // - y.f.call(this, arg1, arg2) => base = f, f = f.apply, args = [this, arg1, arg2]\n    // - y.f.apply(this, args) => base = f, f = f.apply, args = [this, ...args]\n    // This will affect how we check the taint args and the base object\n    let fTobeCheck = f;\n    let reflected = \"\";\n    if (typeof(base) === \"function\" && (f === Function.prototype.apply || f === Function.prototype.call)) {\n      fTobeCheck = base;\n      reflected = f === Function.prototype.apply ? \"apply\" : \"call\";\n    }\n\n    let base_c = _taint_helper_js__WEBPACK_IMPORTED_MODULE_7__.TaintHelper.concrete(base);\n    let f_c = _taint_helper_js__WEBPACK_IMPORTED_MODULE_7__.TaintHelper.concrete(f);\n\n    if (f_c !== f) {\n      // We don't taint the function object\n      throw new Error(\"[TheHulk] Function object is tainted!\");\n    }\n\n    // If none of the arguments are tainted, we skip to the use any rules\n    if (!_taint_helper_js__WEBPACK_IMPORTED_MODULE_7__.TaintHelper.isAnyArgumentsTainted(args, reflected) && !_taint_helper_js__WEBPACK_IMPORTED_MODULE_7__.TaintHelper.risTainted(base)) {\n      return {f: f_c, base: base_c, args: args, skip: false};\n    }\n\n    if (_utils_util_js__WEBPACK_IMPORTED_MODULE_8__.Utils.isNativeFunction(fTobeCheck)) {\n      let rule = this.taintPropRules.invokeFunRules.getRule(fTobeCheck);\n      if (rule) {\n        return {f: rule, base: base, args: args, skip: false, reflected: reflected};\n      }\n      else {\n        // f is a built-in function but no rule found\n        // We concretize the taint value and apply the original function\n        if (!_rules_rule_concretized_js__WEBPACK_IMPORTED_MODULE_9__.ConcretizedFunctions.isKnownConcretized(f)){\n          _utils_util_js__WEBPACK_IMPORTED_MODULE_8__.Utils.reportUnsupportedBuiltin(f.name, iid);\n        }\n        args = Array.from(args).map(item => _taint_helper_js__WEBPACK_IMPORTED_MODULE_7__.TaintHelper.concrete(item)); \n\n        return {f: f_c, base: base_c, args: args, skip: false, reflected:\"\"};\n      }\n    }\n  \n    // f is not a built-in function\n    return {f: f_c, base: base_c, args: args, skip: false, reflected:\"\"};\n  };\n\n  /**\n   * This callback is called after a function, method, or constructor invocation.\n   *\n   * @example\n   * x = y.f(a, b, c)\n   * --------------------------------\n   * var skip = false;\n   * var aret = analysis.invokeFunPre(113, f, y, [a, b, c], false, true);\n   * if (aret) {\n   *     f = aret.f;\n   *     y = aret.y;\n   *     args = aret.args;\n   *     skip = aret.skip\n   * }\n   * if (!skip) {\n   *     result =f.apply(y, args);\n   * }\n   * aret = analysis.invokeFun(117, f, y, args, result, false, true);\n   * if (aret) {\n   *     x = aret.result\n   * } else {\n   *     x = result;\n   * }\n   * \n   * @steps\n   * 1/ Taint the return value if the function api is a taint source.\n   * 2/ Log the coverage information for the analysis.\n   * \n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {function} f - The function object that was invoked\n   * @param {*} base - The receiver object for the function <tt>f</tt>\n   * @param {Array} args - The array of arguments passed to <tt>f</tt>\n   * @param {*} result - The value returned by the invocation\n   * @param {boolean} isConstructor - True if <tt>f</tt> is invoked as a constructor\n   * @param {boolean} isMethod - True if <tt>f</tt> is invoked as a method\n   * @param {number} functionIid - The iid (i.e. the unique instruction identifier) where the function was created\n   * @param {number} functionSid - The sid (i.e. the unique script identifier) where the function was created\n   * {@link MyAnalysis#functionEnter} when the function f is executed.  <tt>functionIid</tt> can be treated as the\n   * static identifier of the function <tt>f</tt>.  Note that a given function code block can create several function\n   * objects, but each such object has a common <tt>functionIid</tt>, which is the iid that is passed to\n   * {@link MyAnalysis#functionEnter} when the function executes.\n   * @returns {{result: *}| undefined} - If an object is returned, the return value of the invoked function is\n   * replaced with the value stored in the <tt>result</tt> property of the object.  This enables one to change the\n   * value that is returned by the actual function invocation.\n   *\n   */\n  invokeFun (iid, f, base, args, result, isConstructor, isMethod, functionIid, functionSid) {\n    let reason = this.taintSourceRules.shouldTaintSourceAtInvokeFun(f, base, args, result);\n    if (reason) {\n      // TODO: We need to clone the variable or only save the taint information and not the value\n      let taintInfo = new _values_taint_info_js__WEBPACK_IMPORTED_MODULE_3__.TaintInfo(iid, reason, new _values_taint_info_js__WEBPACK_IMPORTED_MODULE_3__.TaintPropOperation(\"invokeFun\", [f, base, args, result]));\n      result = _taint_helper_js__WEBPACK_IMPORTED_MODULE_7__.TaintHelper.createTaintValue(result, taintInfo);\n    }\n    return {result: result};\n  };\n\n  /**\n   * This callback is called after the creation of a literal.  A literal can be a function literal, an object literal,\n   * an array literal, a number, a string, a boolean, a regular expression, null, NaN, Infinity, or undefined.\n   *\n   * @example\n   * x = \"Hello\"\n   * --------------------------------\n   * var result = \"Hello\";\n   * var aret = analysis.literal(201, result, false);\n   * if (aret) {\n   *     result = aret.result;\n   * }\n   * x = result;\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {*} val - The literal value\n   * @param {boolean} hasGetterSetter - True if the literal is an object and the object defines getters and setters\n   * @returns {{result: *} | undefined} - If the function returns an object, then the original literal value is\n   * replaced with the value stored in the <tt>result</tt> property of the object.\n   *\n   */\n  literal(iid, val, _hasGetterSetter) {\n\t\treturn {result: val};\n\t};\n\n  /**\n  * This callback is called when a for-in loop is used to iterate the properties of an object.\n  *\n  * @example\n  * for (x in y) { }\n  * --------------------------------\n  * var aret = analysis.forinObject(iid, y);\n  * if (aret) {\n  *     y = aret.result;\n  * }\n  * for (x in y) {}\n  *\n  * @param {number} iid - Static unique instruction identifier of this callback\n  * @param {*} val - Objects whose properties are iterated in a for-in loop.\n  * @returns {{result: *} | undefined} - If the function returns an object, then the original object whose\n  * properties are being iterated is replaced with the value stored in the <tt>result</tt> property of the\n  * returned object.\n  *\n  */\n  forinObject (iid, val) {\n    return {result: val};\n  };\n\n\n  /**\n   * This callback is triggered at the beginning of a scope for every local variable declared in the scope, for\n   * every formal parameter, for every function defined using a function statement, for <tt>arguments</tt>\n   * variable, and for the formal parameter passed in a catch statement.\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {string} name - Name of the variable that is declared\n   * @param {*} val - Initial value of the variable that is declared.  Variables can be local variables, function\n   * parameters, catch parameters, <tt>arguments</tt>, or functions defined using function statements.  Variables\n   * declared with <tt>var</tt> have <tt>undefined</tt> as initial values and cannot be changed by returning a\n   * different value from this callback.  On the beginning of an execution of a function, a <tt>declare</tt>\n   * callback is called on the <tt>arguments</tt> variable.\n   * @param {boolean} isArgument - True if the variable is <tt>arguments</tt> or a formal parameter.\n   * @param {number} argumentIndex - Index of the argument in the function call.  Indices start from 0.  If the\n   * variable is not a formal parameter, then <tt>argumentIndex</tt> is -1.\n   * @param {boolean} isCatchParam - True if the variable is a parameter of a catch statement.\n   * @returns {{result: *} | undefined} - If the function returns an object, then the original initial value is\n   * replaced with the value stored in the <tt>result</tt> property of the object.  This does not apply to local\n   * variables declared with <tt>var</tt>.\n   *\n   */\n  declare (iid, name, val, isArgument, argumentIndex, isCatchParam) {\n    return {result: val};\n  };\n\n\n  /**\n   * This callback is called before a property of an object is accessed.\n   * \n   * @steps\n   * 1/ We always skip the original getField operation and let getField handle the operation.\n   * \n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {*} base - Base object\n   * @param {string|*} offset - Property\n   * @param {boolean} isComputed - True if property is accessed using square brackets.  For example,\n   * <tt>isComputed</tt> is <tt>true</tt> if the get field operation is <tt>o[p]</tt>, and <tt>false</tt>\n   * if the get field operation is <tt>o.p</tt>\n   * @param {boolean} isOpAssign - True if the operation is of the form <code>o.p op= e</code>\n   * @param {boolean} isMethodCall - True if the get field operation is part of a method call (e.g. <tt>o.p()</tt>)\n   * @returns {{base: *, offset: *, skip: boolean} | undefined} - If an object is returned and the <tt>skip</tt>\n   * property of the object is true, then the get field operation is skipped.  Original <tt>base</tt> and\n   * <tt>offset</tt> are replaced with that from the returned object if an object is returned.\n   *\n   */\n  getFieldPre (iid, base, offset, isComputed, isOpAssign, isMethodCall) {\n    return {base: base, offset: offset, skip: true};\n  };\n\n\n  /**\n   * This callback is called after a property of an object is accessed.\n   * \n   * @steps\n   * 1/ Apply the taint propagation rules for the get field operation if the property should be tainted.\n   * 2/ Introduced a new taint value if the property is a taint source.\n   * 3/ Log the coverage information for the analysis.\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {*} base - Base object\n   * @param {string|*} offset - Property\n   * @param {*} val - Value of <code>base[offset]</code>\n   * @param {boolean} isComputed - True if property is accessed using square brackets.  For example,\n   * <tt>isComputed</tt> is <tt>true</tt> if the get field operation is <tt>o[p]</tt>, and <tt>false</tt>\n   * if the get field operation is <tt>o.p</tt>\n   * @param {boolean} isOpAssign - True if the operation is of the form <code>o.p op= e</code>\n   * @param {boolean} isMethodCall - True if the get field operation is part of a method call (e.g. <tt>o.p()</tt>)\n   * @returns {{result: *} | undefined} - If an object is returned, the value of the get field operation  is\n   * replaced with the value stored in the <tt>result</tt> property of the object.\n   */\n  getField (iid, base, offset, val, isComputed, isOpAssign, isMethodCall) {\n    \n    val = this.taintPropRules.getFieldRules.getRule(base, offset)(base, offset, iid)\n    \n    let reason = this.taintSourceRules.shouldTaintSourceAtGetField(base, offset, val);\n    if (reason) {\n      // The taint introduced from taintSourceRules has more priority\n      if (val instanceof _values_wrapped_values_js__WEBPACK_IMPORTED_MODULE_2__.WrappedValue) {\n        val = val.getConcrete();\n      }\n      let taintInfo = new _values_taint_info_js__WEBPACK_IMPORTED_MODULE_3__.TaintInfo(iid, reason, new _values_taint_info_js__WEBPACK_IMPORTED_MODULE_3__.TaintPropOperation(\"getField\", [base, offset], iid));\n      val = _taint_helper_js__WEBPACK_IMPORTED_MODULE_7__.TaintHelper.createTaintValue(val, taintInfo);\n    }\n\n    return {result: val};\n  };\n\n\n  /**\n   * This callback is called before a property of an object is written.\n   * \n   * @steps\n   * 1/ We always skip the original putFieldPre operation and let putField handle the operation.\n   * \n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {*} base - Base object\n   * @param {*} offset - Property\n   * @param {*} val - Value to be stored in <code>base[offset]</code>\n   * @param {boolean} isComputed - True if property is accessed using square brackets.  For example,\n   * <tt>isComputed</tt> is <tt>true</tt> if the get field operation is <tt>o[p]</tt>, and <tt>false</tt>\n   * if the get field operation is <tt>o.p</tt>\n   * @param {boolean} isOpAssign - True if the operation is of the form <code>o.p op= e</code>\n   * @returns {{base: *, offset: *, val: *, skip: boolean} | undefined} -  If an object is returned and the <tt>skip</tt>\n   * property is true, then the put field operation is skipped.  Original <tt>base</tt>, <tt>offset</tt>, and\n   * <tt>val</tt> are replaced with that from the returned object if an object is returned.\n   */\n  putFieldPre (iid, base, offset, val, isComputed, isOpAssign) {\n    return {base: base, offset: offset, val: val, skip: false};\n  };\n\n\n  /**\n   * This callback is called after a property of an object is written.\n   * \n   * @steps\n   * 1/ Check whether a taint value has been set to the sink property (e.g. .innerHTML)\n   * 2/ Apply the taint propagation rules for the put field operation\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {*} base - Base object\n   * @param {*} offset - Property\n   * @param {*} val - Value to be stored in <code>base[offset]</code>\n   * @param {boolean} isComputed - True if property is accessed using square brackets.  For example,\n   * <tt>isComputed</tt> is <tt>true</tt> if the get field operation is <tt>o[p]</tt>, and <tt>false</tt>\n   * if the get field operation is <tt>o.p</tt>\n   * @param {boolean} isOpAssign - True if the operation is of the form <code>o.p op= e</code>\n   * @returns {{result: *} | undefined} -   If an object is returned, the result of the put field operation is\n   * replaced with the value stored in the <tt>result</tt> property of the object.\n   */\n  putField (iid, base, offset, val, isComputed, isOpAssign) {\n    let reason = this.taintSinkRules.checkTaintAtSinkPutField(base, offset, val);\n    if (reason) {\n      _utils_util_js__WEBPACK_IMPORTED_MODULE_8__.Utils.reportDangerousFlow(\n        val.taintInfo.getTaintSourceReason(),\n        val.taintInfo.getTaintSourceLocation(),\n        reason,\n        iid,\n        val,\n        iid\n      )\n    }\n\n    val = this.taintPropRules.putFieldRules.getRule(base, offset)(base, offset, val, iid)\n\n    return {result: val};\n  };\n\n\n  /**\n   * This callback is called after a variable is read.\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {string} name - Name of the variable being read\n   * @param {*} val - Value read from the variable\n   * @param {boolean} isGlobal - True if the variable is not declared using <tt>var</tt> (e.g. <tt>console</tt>)\n   * @param {boolean} isScriptLocal - True if the variable is declared in the global scope using <tt>var</tt>\n   * @returns {{result: *} | undefined} - If an object is returned, the result of the read operation is\n   * replaced with the value stored in the <tt>result</tt> property of the object.\n   */\n  read (iid, name, val, isGlobal, isScriptLocal) {\n    return {result: val};\n  };\n\n  /**\n   * This callback is called before a variable is written.\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {string} name - Name of the variable being read\n   * @param {*} val - Value to be written to the variable\n   * @param {*} lhs - Value stored in the variable before the write operation\n   * @param {boolean} isGlobal - True if the variable is not declared using <tt>var</tt> (e.g. <tt>console</tt>)\n   * @param {boolean} isScriptLocal - True if the variable is declared in the global scope using <tt>var</tt>\n   * @returns {{result: *} | undefined} - If an object is returned, the result of the write operation is\n   * replaced with the value stored in the <tt>result</tt> property of the object.\n   */\n  write (iid, name, val, lhs, isGlobal, isScriptLocal) {\n      return {result: val};\n  };\n\n  /**\n   * This callback is called before a value is returned from a function using the <tt>return</tt> keyword.\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {*} val - Value to be returned\n   * @returns {{result: *} | undefined} - If an object is returned, the value to be returned is\n   * replaced with the value stored in the <tt>result</tt> property of the object.\n   */\n  _return (iid, val) {\n      return {result: val};\n  };\n\n  /**\n   * This callback is called before a value is thrown using the <tt>throw</tt> keyword.\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {*} val - Value to be thrown\n   * @returns {{result: *} | undefined} - If an object is returned, the value to be thrown is\n   * replaced with the value stored in the <tt>result</tt> property of the object.\n   */\n  _throw (iid, val) {\n      return {result: val};\n  };\n\n  /**\n   * This callback is called when a <tt>with</tt> statement is executed\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {*} val - Value used as an argument to <tt>with</tt>\n   * @returns {{result: *} | undefined} - If an object is returned, the value to be used in <tt>with</tt> is\n   * replaced with the value stored in the <tt>result</tt> property of the object.\n   */\n  _with (iid, val) {\n      return {result: val};\n  };\n\n\n  /**\n   * This callback is called before the execution of a function body starts.\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {function} f - The function object whose body is about to get executed\n   * @param {*} dis - The value of the <tt>this</tt> variable in the function body\n   * @param {Array} args - List of the arguments with which the function is called\n   * @returns {undefined} - Any return value is ignored\n   */\n  functionEnter (iid, f, dis, args) {};\n  \n  /**\n   * This callback is called when the execution of a function body completes\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {*} returnVal - The value returned by the function\n   * @param {{exception:*} | undefined} wrappedExceptionVal - If this parameter is an object, the function\n   * execution has thrown an uncaught exception and the exception is being stored in the <tt>exception</tt>\n   * property of the parameter\n   * @returns {{returnVal: *, wrappedExceptionVal: *, isBacktrack: boolean}}  If an object is returned, then the\n   * actual <tt>returnVal</tt> and <tt>wrappedExceptionVal.exception</tt> are replaced with that from the\n   * returned object. If an object is returned and the property <tt>isBacktrack</tt> is set, then the control-flow\n   * returns to the beginning of the function body instead of returning to the caller.  The property\n   * <tt>isBacktrack</tt> can be set to <tt>true</tt> to repeatedly execute the function body as in MultiSE\n   * symbolic execution.\n   */\n  functionExit (iid, returnVal, wrappedExceptionVal) {\n      return {returnVal: returnVal, wrappedExceptionVal: wrappedExceptionVal, isBacktrack: false};\n  };\n\n\n  /**\n   * This callback is called before the execution of a JavaScript file\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {string} instrumentedFileName - Name of the instrumented script file\n   * @param {string} originalFileName - Name of the original script file\n   */\n  scriptEnter (iid, instrumentedFileName, originalFileName) {};\n  \n\n  /**\n   * This callback is called when the execution of a JavaScript file completes\n   *\n   * @param {number} iid - Static unique instruction identifier of this callback\n   * @param {{exception:*} | undefined} wrappedExceptionVal - If this parameter is an object, the script\n   * execution has thrown an uncaught exception and the exception is being stored in the <tt>exception</tt>\n   * property of the parameter\n   * @returns {{wrappedExceptionVal: *, isBacktrack: boolean}} - If an object is returned, then the\n   * actual <tt>wrappedExceptionVal.exception</tt> is replaced with that from the\n   * returned object. If an object is returned and the property <tt>isBacktrack</tt> is set, then the control-flow\n   * returns to the beginning of the script body.  The property\n   * <tt>isBacktrack</tt> can be set to <tt>true</tt> to repeatedly execute the script body as in MultiSE\n   * symbolic execution.\n   */\n  scriptExit (iid, wrappedExceptionVal) {\n      return {wrappedExceptionVal: wrappedExceptionVal, isBacktrack: false};\n  };\n}\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/taint-tracking.js?");

/***/ }),

/***/ "./src/utils/iidToLocation.js":
/*!************************************!*\
  !*** ./src/utils/iidToLocation.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* Copyright (c) Royal Holloway, University of London | Contact Blake Loring (blake@parsed.uk), Duncan Mitchell (Duncan.Mitchell.2015@rhul.ac.uk), or Johannes Kinder (johannes.kinder@rhul.ac.uk) for details or support | LICENSE.md for license details */\n// JALANGI DO NOT INSTRUMENT\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(sandbox, sid, iid) {\n  const iid_string = sandbox.iidToLocation(sid, iid);\n\n  if (!iid_string) {\n      return undefined;\n  }\n\n  return iid_string.substr(1, iid_string.length - 2).split(\":\").slice(1); //Comes in the form (Filename:1:2:3:4)   \n}\n\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/utils/iidToLocation.js?");

/***/ }),

/***/ "./src/utils/logger.js":
/*!*****************************!*\
  !*** ./src/utils/logger.js ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Logger: () => (/* binding */ Logger)\n/* harmony export */ });\n// JALANGI DO NOT INSTRUMENT\n/**\n * @description:\n * --------------------------------\n * This class implements a logger to replace the log4js module which\n * is not compatible with webpack bundle.\n */\nclass Logger {\n  constructor(level = 'info', name = 'default') {\n    this.name = name;\n    this.level = level;\n    this.levels = ['debug', 'info', 'warn', 'error'];\n    this.levelIndex = this.levels.indexOf(level);\n  }\n\n  log(level, message) {\n    const levelIndex = this.levels.indexOf(level);\n    if (levelIndex >= this.levelIndex) {\n      const logMessage = `[${new Date().toISOString()}] [${level.toUpperCase()}] [${this.name}] ${message}`;\n      switch (level) {\n        case 'debug':\n          console.log(`\\x1b[34m%s\\x1b[0m`, logMessage);\n          break;\n        case 'info':\n          console.log(`\\x1b[32m%s\\x1b[0m`, logMessage);\n          break;\n        case 'warn':\n          console.log(`\\x1b[33m%s\\x1b[0m`, logMessage);\n          break;\n        case 'error':\n          console.log(`\\x1b[31m%s\\x1b[0m`, logMessage);\n          break;\n      }\n    }\n  }\n\n  debug(message) {\n    this.log('debug', message);\n  }\n\n  info(message) {\n    this.log('info', message);\n  }\n\n  warn(message) {\n    this.log('warn', message);\n  }\n\n  error(message) {\n    this.log('error', message);\n  }\n\n  alertSink(msg) {\n    console.log(\"\\x1b[31m%s\\x1b[0m\", `[!] ${msg}`);\n  }\n}\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/utils/logger.js?");

/***/ }),

/***/ "./src/utils/util.js":
/*!***************************!*\
  !*** ./src/utils/util.js ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Utils: () => (/* binding */ Utils)\n/* harmony export */ });\n/* harmony import */ var _taint_helper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../taint-helper.js */ \"./src/taint-helper.js\");\n\n\n/**\n * @description\n * --------------------------------\n * General utility functions that are used across the analysis\n */\nclass Utils {\n  static reportDangerousFlow(sourceReason, sourceLoc, sinkReason, sinkLoc, taintedValue, iid) {\n    console.log(\"%c[TheHulk] Found a dangerous flow from %s to %s!\",\n                'background: #222; color: #bada55',            \n                sourceReason, sinkReason);\n    \n    const clonedTaintedValue = JSON.parse(JSON.stringify(taintedValue));\n\n    J$$.analysis.dangerousFlows.push({\n      sourceReason: sourceReason,\n      sourceLoc: sourceLoc,\n      sinkReason: sinkReason,\n      sinkLoc: sinkLoc,\n      taintedValue: clonedTaintedValue,\n      iid: iid\n    });\n  }\n\n  static reportUnsupportedBuiltin(builtinName) {\n    if (!J$$.analysis.debugPrint) {\n      return;\n    }\n\n    console.log(\"%c[TheHulk] Debug: Unsupported builtin %s!\",\n                'background: white; color: brown',            \n                builtinName);\n  }\n\n  static debugPrint(message) {\n    if (!J$$.analysis.debugPrint) {\n      return;\n    }\n\n    console.log(\"%c[TheHulk] Debug: %s!\",\n      'background: white; color: brown',            \n      message);\n  }\n\n  /**\n   * Retrun the array like arguments\n   * \n   * @param {Argruments} args \n   * @param {String} reflected \n   * @returns \n   */\n  static getArrayLikeArguments(args, reflected) {\n    if (args.length === 0) { return []; }\n      \n    let argsArray = args;\n    if (Utils.isArguments(args)) {\n      argsArray = Array.from(args);\n    }\n    \n    if (reflected === 'apply') {\n      // For f.apply(this, args)\n      // If there is only one argument, it is the arg itself\n      // If there is more than one argument, it is [arg1, arg2, ...]\n      if (argsArray[1] instanceof Array) {\n        return argsArray[1];\n      } else {\n        return [argsArray[1]];\n      }\n    }\n\n    return argsArray;\n  }\n\n  static isNativeFunction(f) {\n    const toString = Object.prototype.toString;\n    const fnToString = Function.prototype.toString;\n    const reHostCtor = /^\\[object .+?Constructor\\]$/;\n    \n    // We need to make sure String() is not overwritten by developer\n    // If String() is instrumented, we will get recursive function call \n    const staticPattern = \"function toString() { [native code] }\"\n    const reNative = RegExp(\"^\" + staticPattern\n            .replace(/[.*+?^${}()|[\\]\\/\\\\]/g, \"\\\\$&\")\n            .replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\"\n    );\n\n    function isNativeCore(value) {\n        if (value.hasOwnProperty('toString')) {\n            console.warn('WARNING: isNativeFunction will not work on custom toString methods. We assume nobody would overwrite core method toStrings');\n            return false;\n        }\n\n        if (typeof(value) === \"function\") {\n            return reNative.test(fnToString.call(value)); \n        } else if (typeof(value) === \"object\") {\n            return reHostCtor.test(toString.call(value));\n        } else {\n            return false;\n        }\n    }\n\n    if (f === null || f === undefined) {\n        console.warn('isNativeFunction called on null or undefined');\n        return false;\n    }\n\n    if (typeof(f) === \"function\" || typeof(f) === \"object\") {\n        return isNativeCore(f);\n    } else {\n        console.warn('isNativeFunction called on non-function/non-object');\n        return false;\n    }\n  }\n\n  static isArguments(args) {\n    return Object.prototype.toString.call(args) === '[object Arguments]';\n  }\n\n  static isPrimitive(value) {\n    return value !== Object(value);\n  }\n\n  /**\n   * Check the real type of the value no matter if it is tainted\n   * @param {*} value \n   */\n  static realTypeOf(value) {\n    if (_taint_helper_js__WEBPACK_IMPORTED_MODULE_0__.TaintHelper.isTainted(value)) {\n      return typeof _taint_helper_js__WEBPACK_IMPORTED_MODULE_0__.TaintHelper.concrete(value);\n    }\n    return typeof value;\n  }\n\n  /**\n   * Check if the value is a string no matter if it is tainted\n   * @param {*} value \n   * @returns \n   */\n  static isString(value) {\n    return Utils.realTypeOf(value) === 'string' || _taint_helper_js__WEBPACK_IMPORTED_MODULE_0__.TaintHelper.concrete(value) instanceof String;\n  }\n\n  /**\n   * Check if the value is an iterator from String.prototype.matchAll\n   * @param {*} value \n   * @returns {boolean}\n   */\n  static isRegExpStringIterator(value) {\n    const matchAllIteratorPrototype = Object.getPrototypeOf(''.matchAll(''));\n    return Object.getPrototypeOf(value) === matchAllIteratorPrototype;\n  }\n\n  static isArray(value) { \n    return Array.isArray(value);\n  }\n}\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/utils/util.js?");

/***/ }),

/***/ "./src/values/taint-info.js":
/*!**********************************!*\
  !*** ./src/values/taint-info.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TaintInfo: () => (/* binding */ TaintInfo),\n/* harmony export */   TaintPropName: () => (/* binding */ TaintPropName),\n/* harmony export */   TaintPropOperation: () => (/* binding */ TaintPropOperation)\n/* harmony export */ });\n/**\n * @description\n * --------------------------------\n * Taint information for a value.\n * This class stores the following information about a taint:\n * 1/ Taint Identifier (ID)\n * 2/ Taint Source (Location) (i.e. where the taint originated from)\n * 3/ Taint propagation operations (i.e. how the taint is being propagated)\n * \n * The taint identifier is a unique identifier for the taint source. The derived\n * values will have the same taint identifier as value from which they are derived.\n * However, the taint propagation operations will differ.\n * \n * @example\n * --------------------------------\n * let b = a.replace(/[&<>n, 0=\\/]/g, \"\");\n * a.taintInfo = { \n *    taintID: 1,\n *    taintSource: {\n *      location: 1,\n *      sourceLocation: undefined,\n *      reason: \"DOM Clobberable Lookup\",\n *      operation: \"document.cookie\"\n *    },\n *    taintPropOperations: []\n * }\n * \n * b is derived from a, so we have\n * =>\n * b.taintInfo = a.taintInfo\n * b.taintInfo.addTaintPropOperation(\"replace\", [\"/[&<>n, 0=\\/]/g\", \"\"])\n */\nclass TaintInfo {\n  /**\n   * TaintInfo constructor\n   * @param {Smi} iid \n   * @param {String} reason: The reason why the taint was introduced\n   * @param {TaintPropOperation} operation: The operation that introduced the taint\n   */\n  constructor(iid, reason, operation) {\n    this.taintID = J$$.analysis.taintID++ || 0;\n    this.taintSource = {\n      location: iid,\n      sourceLocation: undefined, // J$$.iidToLocation(iid)\n      reason: reason,\n      operation: operation\n    }\n\n    this.taintPropOperations = [];\n    if (operation) this.taintPropOperations = [operation];\n  }\n\n  getTaintID() {\n    return this.taintID;\n  }\n\n  getTaintSource() {\n    return this.taintSource;\n  }\n\n  getTaintSourceReason() {\n    return this.taintSource.reason;\n  }\n\n  getTaintSourceLocation() {\n    return this.taintSource.location;\n  }\n\n  getTaintPropOperations() {\n    return this.taintPropOperations;\n  }\n\n  addTaintPropOperation(operation, argument, location) {\n    this.taintPropOperations.push(\n      new TaintPropOperation(operation, argument, location));\n  }\n}\n\n/**\n * @description\n * --------------------------------\n * Taint propagation operation. This class stores the operation that is being\n * performed on the taint.\n * \n * @example\n * --------------------------------\n * TAINT.replace(/[&<>n, 0=\\/]/g, \"\");\n * =>\n * new TaintPropOperation(\"replace\", [\"/[&<>n, 0=\\/]/g\", \"\"]);\n * \n */\nclass TaintPropOperation {\n  /**\n   * TaintPropOperation constructor\n   * \n   * @TODO\n   * Concrete the arguments here, like toString, etc.\n   * \n   * @param {String} operation \n   * @param {Array<*>} argument\n   * @param {Number} location\n   */\n  constructor(operation, argument, location) {\n    this.operation = operation;\n    this.arguments = argument;\n    this.location = location;\n  }\n\n  getOperation() {\n    return this.operation;\n  }\n\n  getArguments() {\n    return this.arguments;\n  }\n\n}\n\nconst TaintPropName = \"__TAINT__\";\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/values/taint-info.js?");

/***/ }),

/***/ "./src/values/wrapped-values.js":
/*!**************************************!*\
  !*** ./src/values/wrapped-values.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConcolicValue: () => (/* binding */ ConcolicValue),\n/* harmony export */   TaintValue: () => (/* binding */ TaintValue),\n/* harmony export */   WrappedValue: () => (/* binding */ WrappedValue)\n/* harmony export */ });\n// JALANGI DO NOT INSTRUMENT\nclass WrappedValue {\n  /**\n   * \n   * @TODO\n   * Append the origin location & type of the wrapped value to the constructor\n   * \n   * @param {*} concrete \n   */\n  constructor(concrete) {\n    Object.defineProperty(this, 'concrete', {\n        value: concrete,\n        enumerable: false,\n        writable: true,\n        configurable: true\n    });\n  }\n\n  clone() {\n    return new WrappedValue(this.concrete);\n  }\n\n  toString() {\n    return \"Wrapped(\" + this.concrete + \", \" + (this.rider ? this.rider.toString() : \"\") + \")\";\n  }\n\n  valueOf() {\n    return this.concrete ? this.concrete.valueOf() : this.concrete;\n  }\n\n  getConcrete() {\n    return this.concrete;\n  }\n}\n\nclass ConcolicValue extends WrappedValue { \n  constructor(concrete, symbolic, arrayType = undefined) {\n      super(concrete);\n      this.__defineProperty('symbolic', symbolic);\n      this.__defineProperty('_arrayType', arrayType);\n  }\n\n  __defineProperty(name, value){\n    Object.defineProperty(this, name, {\n        value: value,\n        enumerable: false,\n        writable: true,\n        configurable: true\n    });\n  }\n\n  toString() {\n      return \"Concolic(\" + this.concrete + \", \" + this.symbolic + \")\";\n  }\n\n  clone() {\n      return new ConcolicValue(this.concrete, this.symbolic);\n  }\n\n  getConcrete() {\n      return this.concrete;\n  }\n\n  getSymbolic() {\n      return this.symbolic;\n  }\n\n  getArrayType() {\n      return this._arrayType;\n  }\n\n}\n\nConcolicValue.getSymbolic = function(val) {\n  return val instanceof ConcolicValue ? val.symbolic : undefined;\n};\n\nConcolicValue.setSymbolic = function(val, val_s) {\n  if (val instanceof ConcolicValue) {\n      val.symbolic = val_s;\n  }\n};\n\n\n/**\n * @description\n * --------------------------------\n * TaintValue is a wrapper class for values that are tainted\n * Similar to ConcolicValue class, but with the addition of taint information\n * Ideally, all the JavaScript values can be wrapped with TaintValue\n * \n */\nclass TaintValue extends WrappedValue {\n  /**\n   * TaintValue constructor\n   * \n   * @param {*} concrete \n   * @param {TaintInfo} taintInfo \n   */\n  constructor(concrete, taintInfo) {\n    super(concrete);\n    this.__defineProperty('taintInfo', taintInfo);\n  }\n\n  __defineProperty(name, value){\n    Object.defineProperty(this, name, {\n        value: value,\n        enumerable: false,\n        writable: true,\n        configurable: true\n    });\n  }\n\n  toString() {\n    return \"TaintValue(\" + this.concrete + \", \" + this.taintInfo + \")\";\n  }\n\n  clone() {\n    return new TaintValue(this.concrete, this.taintInfo);\n  }\n\n  getConcrete() {\n    return this.concrete;\n  }\n\n  getTaintInfo() {\n    return this.taintInfo;\n  }\n}\n\n\n\n//# sourceURL=webpack://thehulk-concolic-analysis/./src/values/wrapped-values.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/entry.js");
/******/ 	
/******/ })()
;