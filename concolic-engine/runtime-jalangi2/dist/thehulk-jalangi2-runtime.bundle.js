/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/config.js":
/*!***********************!*\
  !*** ./src/config.js ***!
  \***********************/
/***/ (() => {

eval("/*\n * Copyright (c) 2014 Samsung Electronics Co., Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *        http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// do not remove the following comment\n// JALANGI DO NOT INSTRUMENT\nif (typeof J$$ === 'undefined') {\n    J$$ = {};\n}\n\n(function (sandbox) {\n    if (typeof sandbox.Config !== 'undefined') {\n        return;\n    }\n\n    var Config = sandbox.Config = {};\n\n    Config.DEBUG = false;\n    Config.WARN = false;\n    Config.SERIOUS_WARN = false;\n// make MAX_BUF_SIZE slightly less than 2^16, to allow over low-level overheads\n    Config.MAX_BUF_SIZE = 64000;\n    Config.LOG_ALL_READS_AND_BRANCHES = false;\n\n    //**********************************************************\n    //  Functions for selective instrumentation of operations\n    //**********************************************************\n    // In the following functions\n    // return true in a function, if you want the ast node (passed as the second argument) to be instrumented\n    // ast node gets instrumented if you do not define the corresponding function\n    Config.ENABLE_SAMPLING = false;\n//    Config.INSTR_INIT = function(name, ast) { return false; };\n//    Config.INSTR_READ = function(name, ast) { return false; };\n//    Config.INSTR_WRITE = function(name, ast) { return true; };\n//    Config.INSTR_GETFIELD = function(offset, ast) { return true; }; // offset is null if the property is computed\n//    Config.INSTR_PUTFIELD = function(offset, ast) { return true; }; // offset is null if the property is computed\n//    Config.INSTR_BINARY = function(operator, ast) { return true; };\n//    Config.INSTR_PROPERTY_BINARY_ASSIGNMENT = function(operator, offset, ast) { return true; }; // a.x += e or a[e1] += e2\n//    Config.INSTR_UNARY = function(operator, ast) { return true; };\n//    Config.INSTR_LITERAL = function(literal, ast) { return true;}; // literal gets some dummy value if the type is object, function, or array\n//    Config.INSTR_CONDITIONAL = function(type, ast) { return true; }; // type could be \"&&\", \"||\", \"switch\", \"other\"\n//    Config.INSTR_TRY_CATCH_ARGUMENTS = function(ast) {return false; }; // wrap function and script bodies with try catch block and use arguments in J$.Fe.  DO NOT USE THIS.\n//    Config.INSTR_END_EXPRESSION = function(ast) {return true; }; // top-level expression marker\n}(J$$));\n\n\n//# sourceURL=webpack://jalangi2-runtime/./src/config.js?");

/***/ }),

/***/ "./src/constants.js":
/*!**************************!*\
  !*** ./src/constants.js ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/*\n * Copyright (c) 2014 Samsung Electronics Co., Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *        http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// do not remove the following comment\n// JALANGI DO NOT INSTRUMENT\nif (typeof J$$ === 'undefined') {\n    J$$ = {};\n}\n\n(function (sandbox) {\n    if (typeof sandbox.Constants !== 'undefined') {\n        return;\n    }\n    var Constants = sandbox.Constants = {};\n\n    Constants.isBrowser = !( true && this.exports !== exports);\n\n    var APPLY = Constants.APPLY = Function.prototype.apply;\n    var CALL = Constants.CALL = Function.prototype.call;\n    APPLY.apply = APPLY;\n    APPLY.call = CALL;\n    CALL.apply = APPLY;\n    CALL.call = CALL;\n\n    var HAS_OWN_PROPERTY = Constants.HAS_OWN_PROPERTY = Object.prototype.hasOwnProperty;\n    Constants.HAS_OWN_PROPERTY_CALL = Object.prototype.hasOwnProperty.call;\n\n\n    var PREFIX1 = Constants.JALANGI_VAR = \"J$$\";\n    Constants.SPECIAL_PROP = \"*\" + PREFIX1 + \"*\";\n    Constants.SPECIAL_PROP2 = \"*\" + PREFIX1 + \"I*\";\n    Constants.SPECIAL_PROP3 = \"*\" + PREFIX1 + \"C*\";\n    Constants.SPECIAL_PROP4 = \"*\" + PREFIX1 + \"W*\";\n    Constants.SPECIAL_PROP_SID = \"*\" + PREFIX1 + \"SID*\";\n    Constants.SPECIAL_PROP_IID = \"*\" + PREFIX1 + \"IID*\";\n\n    Constants.UNKNOWN = -1;\n\n    //-------------------------------- End constants ---------------------------------\n\n    //-------------------------------------- Constant functions -----------------------------------------------------------\n\n    var HOP = Constants.HOP = function (obj, prop) {\n        return (prop + \"\" === '__proto__') || CALL.call(HAS_OWN_PROPERTY, obj, prop); //Constants.HAS_OWN_PROPERTY_CALL.apply(Constants.HAS_OWN_PROPERTY, [obj, prop]);\n    };\n\n    Constants.hasGetterSetter = function (obj, prop, isGetter) {\n        if (typeof Object.getOwnPropertyDescriptor !== 'function') {\n            return true;\n        }\n        while (obj !== null) {\n            if (typeof obj !== 'object' && typeof obj !== 'function') {\n                return false;\n            }\n            var desc = Object.getOwnPropertyDescriptor(obj, prop);\n            if (desc !== undefined) {\n                if (isGetter && typeof desc.get === 'function') {\n                    return true;\n                }\n                if (!isGetter && typeof desc.set === 'function') {\n                    return true;\n                }\n            } else if (HOP(obj, prop)) {\n                return false;\n            }\n            obj = obj.__proto__;\n        }\n        return false;\n    };\n\n    Constants.debugPrint = function (s) {\n        if (sandbox.Config.DEBUG) {\n            console.log(\"***\" + s);\n        }\n    };\n\n    Constants.warnPrint = function (iid, s) {\n        if (sandbox.Config.WARN && iid !== 0) {\n            console.log(\"        at \" + iid + \" \" + s);\n        }\n    };\n\n    Constants.seriousWarnPrint = function (iid, s) {\n        if (sandbox.Config.SERIOUS_WARN && iid !== 0) {\n            console.log(\"        at \" + iid + \" Serious \" + s);\n        }\n    };\n\n})(J$$);\n\n\n\n//# sourceURL=webpack://jalangi2-runtime/./src/constants.js?");

/***/ }),

/***/ "./src/entry.js":
/*!**********************!*\
  !*** ./src/entry.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("// If we use commmonJS with require, the webpack will not recongnize the source map?\n__webpack_require__(/*! ./config.js */ \"./src/config.js\");\n__webpack_require__(/*! ./constants.js */ \"./src/constants.js\");\n__webpack_require__(/*! ./runtime.js */ \"./src/runtime.js\");\n__webpack_require__(/*! ./iidToLocation.js */ \"./src/iidToLocation.js\");\n// require('./astUtil.js');\n// require('./esnstrument.js');\n\n// import './config.js';\n// import './constants.js';\n// import './runtime.js';\n// import './iidToLocation.js';\n\n//# sourceURL=webpack://jalangi2-runtime/./src/entry.js?");

/***/ }),

/***/ "./src/iidToLocation.js":
/*!******************************!*\
  !*** ./src/iidToLocation.js ***!
  \******************************/
/***/ (() => {

eval("/*\n * Copyright 2013-2014 Samsung Information Systems America, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *        http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Author: Koushik Sen\n// do not remove the following comment\n// JALANGI DO NOT INSTRUMENT\n\nif (typeof J$$ === 'undefined') {\n  J$$ = {};\n}\n\n(function (sandbox) {\n  if (typeof sandbox.iidToLocation !== 'undefined') {\n      return;\n  }\n  sandbox.iidToLocation = function (sid, iid) {\n      var ret, arr, gid=sid;\n      if (sandbox.smap) {\n          if (typeof sid === 'string' && sid.indexOf(':')>=0) {\n              sid = sid.split(':');\n              iid = parseInt(sid[1]);\n              sid = parseInt(sid[0]);\n          } else {\n              gid = sid+\":\"+iid;\n          }\n          if ((ret = sandbox.smap[sid])) {\n              var fname = ret.originalCodeFileName;\n              if (ret.evalSid !== undefined) {\n                  fname = fname+sandbox.iidToLocation(ret.evalSid, ret.evalIid);\n              }\n              arr = ret[iid];\n              if (arr) {\n                  if (sandbox.Results) {\n                      return \"<a href=\\\"javascript:iidToDisplayCodeLocation('\"+gid+\"');\\\">(\" + fname + \":\" + arr[0] + \":\" + arr[1] + \":\" + arr[2] + \":\" + arr[3] + \")</a>\";\n                  } else {\n                      return \"(\" + fname + \":\" + arr[0] + \":\" + arr[1] + \":\" + arr[2] + \":\" + arr[3] + \")\";\n                  }\n              } else {\n                  return \"(\" + fname + \":iid\" + iid + \")\";\n              }\n          }\n      }\n      return sid+\"\";\n  };\n\n  sandbox.getGlobalIID = function(iid) {\n      return sandbox.sid +\":\"+iid;\n  }\n\n}(J$$));\n\n\n//# sourceURL=webpack://jalangi2-runtime/./src/iidToLocation.js?");

/***/ }),

/***/ "./src/runtime.js":
/*!************************!*\
  !*** ./src/runtime.js ***!
  \************************/
/***/ (() => {

eval("/*\n * Copyright 2014 Samsung Information Systems America, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *        http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Author: Koushik Sen\n\n// do not remove the following comment\n// JALANGI DO NOT INSTRUMENT\n\n\n// wrap in anonymous function to create local namespace when in browser\n// create / reset J$$ global variable to hold analysis runtime\nif (typeof J$$ === 'undefined') {\n  J$$ = {};\n}\n\n(function (sandbox) {\n  if (typeof sandbox.B !== 'undefined') {\n      return;\n  }\n  //----------------------------------- Begin Jalangi Library backend ---------------------------------\n\n  // stack of return values from instrumented functions.\n  // we need to keep a stack since a function may return and then\n  // have another function call in a finally block (see test\n  // call_in_finally.js)\n\n  var global = this;\n  var Function = global.Function;\n  var returnStack = [];\n  var wrappedExceptionVal;\n  var lastVal;\n  var switchLeft;\n  var switchKeyStack = [];\n  var argIndex;\n  var EVAL_ORG = eval;\n  var lastComputedValue;\n  var SPECIAL_PROP_SID = sandbox.Constants.SPECIAL_PROP_SID;\n  var SPECIAL_PROP_IID = sandbox.Constants.SPECIAL_PROP_IID;\n\n  function getPropSafe(base, prop){\n    if(base === null || base === undefined){\n      return undefined;\n    }\n    return base[prop];\n  }\n\n  function decodeBitPattern(i, len) {\n      var ret = new Array(len);\n      for (var j=0; j<len; j++) {\n          var val = (i & 1)?true:false;\n          ret[len - j -1] = val;\n          i = i >> 1;\n      }\n      return ret;\n  }\n\n  function createBitPattern() {\n      var ret = 0;\n      var i;\n      for (i =0; i< arguments.length; i++) {\n          ret = (ret << 1)+(arguments[i]?1:0);\n      }\n      return ret;\n  }\n\n\n  var sidStack = [], sidCounter = 0;\n\n  function createAndAssignNewSid() {\n      sidStack.push(sandbox.sid);\n      sandbox.sid = sidCounter = sidCounter + 1;\n      if (!sandbox.smap) sandbox.smap = {};\n      sandbox.smap[sandbox.sid] = sandbox.iids;\n  }\n\n  function rollBackSid() {\n      sandbox.sid = sidStack.pop();\n  }\n\n  function associateSidWithFunction(f, iid) {\n      if (typeof f === 'function') {\n          if (Object && Object.defineProperty && typeof Object.defineProperty === 'function') {\n              Object.defineProperty(f, SPECIAL_PROP_SID, {\n                  enumerable:false,\n                  writable:true\n              });\n              Object.defineProperty(f, SPECIAL_PROP_IID, {\n                  enumerable:false,\n                  writable:true\n              });\n          }\n          f[SPECIAL_PROP_SID] = sandbox.sid;\n          f[SPECIAL_PROP_IID] = iid;\n      }\n  }\n\n  function updateSid(f) {\n      sidStack.push(sandbox.sid);\n      sandbox.sid = getPropSafe(f, SPECIAL_PROP_SID);\n  }\n\n\n  // unused\n  function isNative(f) {\n      return f.toString().indexOf('[native code]') > -1 || f.toString().indexOf('[object ') === 0;\n  }\n\n//   function callAsNativeConstructorWithEval(Constructor, args) {\n//       var a = [];\n//       for (var i = 0; i < args.length; i++)\n//           a[i] = 'args[' + i + ']';\n//       var eval = EVAL_ORG;\n//       return eval('new Constructor(' + a.join() + ')');\n//   }\n    \n    function callAsNativeConstructorWithoutEval(Constructor, args) {\n        // Ensure args is an array-like object and convert it to an array\n        const argsArray = Array.prototype.slice.call(args);\n        \n        // Create a function that will call the constructor with the provided arguments\n        const func = new Function('Constructor', 'args', \n            `return new Constructor(${argsArray.map((_, i) => 'args[' + i + ']').join(', ')});`);\n        \n        // Call the function with the constructor and the arguments\n        return func(Constructor, argsArray);\n    }\n\n  function callAsNativeConstructor(Constructor, args) {\n      if (args.length === 0) {\n          return new Constructor();\n      }\n      if (args.length === 1) {\n          return new Constructor(args[0]);\n      }\n      if (args.length === 2) {\n          return new Constructor(args[0], args[1]);\n      }\n      if (args.length === 3) {\n          return new Constructor(args[0], args[1], args[2]);\n      }\n      if (args.length === 4) {\n          return new Constructor(args[0], args[1], args[2], args[3]);\n      }\n      if (args.length === 5) {\n          return new Constructor(args[0], args[1], args[2], args[3], args[4]);\n      }\n      return callAsNativeConstructorWithoutEval(Constructor, args);\n  }\n\n  function callAsConstructor(Constructor, args) {\n      var ret;\n      if (true) {\n          ret = callAsNativeConstructor(Constructor, args);\n          return ret;\n      } else { var Temp, inst; }\n  }\n\n  function invokeEval(base, f, args, iid) {\n    return f(args[0]); // eval(script);\n    // TODO: We currently don't instrument eval code\n    // return f(sandbox.instrumentEvalCode(args[0], iid, false));\n  }\n\n  function invokeFunctionDecl(base, f, args, iid) {\n      // Invoke with the original parameters to preserve exceptional behavior if input is invalid\n      f.apply(base, args);\n      // Otherwise input is valid, so instrument and invoke via eval\n      var newArgs = [];\n      for (var i = 0; i < args.length-1; i++) {\n          newArgs[i] = args[i];\n      }\n      var code = '(function(' + newArgs.join(', ') + ') { ' + args[args.length-1] + ' })';\n      var code = sandbox.instrumentEvalCode(code, iid, false);\n      // Using EVAL_ORG instead of eval() is important as it preserves the scoping semantics of Function()\n      var out = EVAL_ORG(code);\n      return out;\n  }\n\n  function callFun(f, base, args, isConstructor, iid) {\n      var result;\n      pushSwitchKey();\n      try {\n          if (f === EVAL_ORG) {\n              result = invokeEval(base, f, args, iid);\n          } else if (f === Function) {\n              result = invokeFunctionDecl(base, f, args, iid);\n          } else if (isConstructor) {\n              result = callAsConstructor(f, args);\n          } else {\n              result = Function.prototype.apply.call(f, base, args);\n          }\n          return result;\n      } finally {\n          popSwitchKey();\n      }\n  }\n\n  function invokeFun(iid, base, f, args, isConstructor, isMethod) {\n      var aret, skip = false, result;\n\n      if (sandbox.analysis && sandbox.analysis.invokeFunPre) {\n          aret = sandbox.analysis.invokeFunPre(iid, f, base, args, isConstructor, isMethod, getPropSafe(f, SPECIAL_PROP_IID), getPropSafe(f, SPECIAL_PROP_SID));\n          if (aret) {\n              f = aret.f;\n              base = aret.base;\n              args = aret.args;\n              skip = aret.skip;\n          }\n      }\n      if (!skip) {\n          result = callFun(f, base, args, isConstructor, iid);\n      }\n      if (sandbox.analysis && sandbox.analysis.invokeFun) {\n          aret = sandbox.analysis.invokeFun(iid, f, base, args, result, isConstructor, isMethod, getPropSafe(f, SPECIAL_PROP_IID), getPropSafe(f, SPECIAL_PROP_SID));\n          if (aret) {\n              result = aret.result;\n          }\n      }\n      return result;\n  }\n\n  // Function call (e.g., f())\n  function F(iid, f, flags) {\n      var bFlags = decodeBitPattern(flags, 1); // [isConstructor]\n      return function () {\n          var base = this;\n          return (lastComputedValue = invokeFun(iid, base, f, arguments, bFlags[0], false));\n      }\n  }\n\n  // Method call (e.g., e.f())\n  function M(iid, base, offset, flags) {\n      var bFlags = decodeBitPattern(flags, 2); // [isConstructor, isComputed]\n      var f = G(iid + 2, base, offset, createBitPattern(bFlags[1], false, true));\n      return function () {\n          return (lastComputedValue = invokeFun(iid, base, f, arguments, bFlags[0], true));\n      };\n  }\n\n  // Ignore argument (identity).\n  function I(val) {\n      return val;\n  }\n\n  var hasGetOwnPropertyDescriptor = typeof Object.getOwnPropertyDescriptor === 'function';\n  // object/function/regexp/array Literal\n  function T(iid, val, type, hasGetterSetter, internalIid) {\n      var aret;\n      associateSidWithFunction(val, internalIid);\n      if (hasGetterSetter) {\n          for (var offset in val) {\n              if (hasGetOwnPropertyDescriptor && val.hasOwnProperty(offset)) {\n                  var desc = Object.getOwnPropertyDescriptor(val, offset);\n                  if (desc !== undefined) {\n                      if (typeof desc.get === 'function') {\n                          T(iid, desc.get, 12, false, internalIid);\n                      }\n                      if (typeof desc.set === 'function') {\n                          T(iid, desc.set, 12, false, internalIid);\n                      }\n                  }\n              }\n          }\n      }\n      if (sandbox.analysis && sandbox.analysis.literal) {\n          aret = sandbox.analysis.literal(iid, val, hasGetterSetter);\n          if (aret) {\n              val = aret.result;\n          }\n      }\n      return (lastComputedValue = val);\n  }\n\n  // wrap object o in for (x in o) { ... }\n  function H(iid, val) {\n      var aret;\n      if (sandbox.analysis && sandbox.analysis.forinObject) {\n          aret = sandbox.analysis.forinObject(iid, val);\n          if (aret) {\n              val = aret.result;\n          }\n      }\n      return val;\n  }\n\n  // variable declaration (Init)\n  function N(iid, name, val, flags) {\n      var bFlags = decodeBitPattern(flags, 3); // [isArgument, isLocalSync, isCatchParam]\n      // isLocalSync is only true when we sync variables inside a for-in loop\n      var aret;\n\n      if (bFlags[0]) {\n          argIndex++;\n      }\n      if (!bFlags[1] && sandbox.analysis && sandbox.analysis.declare) {\n          if (bFlags[0] && argIndex > 1) {\n              aret = sandbox.analysis.declare(iid, name, val, bFlags[0], argIndex - 2, bFlags[2]);\n          } else {\n              aret = sandbox.analysis.declare(iid, name, val, bFlags[0], -1, bFlags[2]);\n          }\n          if (aret) {\n              val = aret.result;\n          }\n      }\n      return val;\n  }\n\n  // getField (property read)\n  function G(iid, base, offset, flags) {\n      var bFlags = decodeBitPattern(flags, 3); // [isComputed, isOpAssign, isMethodCall]\n\n      var aret, skip = false, val;\n\n      if (sandbox.analysis && sandbox.analysis.getFieldPre) {\n          aret = sandbox.analysis.getFieldPre(iid, base, offset, bFlags[0], bFlags[1], bFlags[2]);\n          if (aret) {\n              base = aret.base;\n              offset = aret.offset;\n              skip = aret.skip;\n          }\n      }\n\n      if (!skip) {\n          val = base[offset];\n      }\n      if (sandbox.analysis && sandbox.analysis.getField) {\n          aret = sandbox.analysis.getField(iid, base, offset, val, bFlags[0], bFlags[1], bFlags[2]);\n          if (aret) {\n              val = aret.result;\n          }\n      }\n      return (lastComputedValue = val);\n  }\n\n  // putField (property write)\n  function P(iid, base, offset, val, flags) {\n      var bFlags = decodeBitPattern(flags, 2); // [isComputed, isOpAssign]\n\n      var aret, skip = false;\n\n      if (sandbox.analysis && sandbox.analysis.putFieldPre) {\n          aret = sandbox.analysis.putFieldPre(iid, base, offset, val, bFlags[0], !!bFlags[1]);\n          if (aret) {\n              base = aret.base;\n              offset = aret.offset;\n              val = aret.val;\n              skip = aret.skip;\n          }\n      }\n\n      if (!skip) {\n          base[offset] = val;\n      }\n      if (sandbox.analysis && sandbox.analysis.putField) {\n          aret = sandbox.analysis.putField(iid, base, offset, val, bFlags[0], !!bFlags[1]);\n          if (aret) {\n              val = aret.result;\n          }\n      }\n      return (lastComputedValue = val);\n  }\n\n  // variable write\n  // isGlobal means that the variable is global and not declared as var\n  // isScriptLocal means that the variable is global and is declared as var\n  function R(iid, name, val, flags) {\n      var aret;\n      var bFlags = decodeBitPattern(flags, 2); // [isGlobal, isScriptLocal]\n\n      if (sandbox.analysis && sandbox.analysis.read) {\n          aret = sandbox.analysis.read(iid, name, val, bFlags[0], bFlags[1]);\n          if (aret) {\n              val = aret.result;\n          }\n      }\n      return (lastComputedValue = val);\n  }\n\n  // variable write\n  function W(iid, name, val, lhs, flags) {\n      var bFlags = decodeBitPattern(flags, 3); //[isGlobal, isScriptLocal, isDeclaration]\n      var aret;\n      if (sandbox.analysis && sandbox.analysis.write) {\n          aret = sandbox.analysis.write(iid, name, val, lhs, bFlags[0], bFlags[1]);\n          if (aret) {\n              val = aret.result;\n          }\n      }\n      if (!bFlags[2]) {\n          return (lastComputedValue = val);\n      } else {\n          lastComputedValue = undefined;\n          return val;\n      }\n  }\n\n  // with statement\n  function Wi(iid, val) {\n      if (sandbox.analysis && sandbox.analysis._with) {\n          aret = sandbox.analysis._with(iid, val);\n          if (aret) {\n              val = aret.result;\n          }\n      }\n      return val;\n  }\n\n  // Uncaught exception\n  function Ex(iid, e) {\n      wrappedExceptionVal = {exception:e};\n  }\n\n  // Throw statement\n  function Th(iid, val) {\n      var aret;\n      if (sandbox.analysis && sandbox.analysis._throw) {\n          aret = sandbox.analysis._throw(iid, val);\n          if (aret) {\n              val = aret.result;\n          }\n      }\n      return (lastComputedValue = val);\n  }\n\n  // Return statement\n  function Rt(iid, val) {\n      var aret;\n      if (sandbox.analysis && sandbox.analysis._return) {\n          aret = sandbox.analysis._return(iid, val);\n          if (aret) {\n              val = aret.result;\n          }\n      }\n      returnStack.pop();\n      returnStack.push(val);\n      return (lastComputedValue = val);\n  }\n\n  // Actual return from function, invoked from 'finally' block\n  // added around every function by instrumentation.  Reads\n  // the return value stored by call to Rt()\n  function Ra() {\n      var returnVal = returnStack.pop();\n      wrappedExceptionVal = undefined;\n      return returnVal;\n  }\n\n  // Function enter\n  function Fe(iid, f, dis /* this */, args) {\n      argIndex = 0;\n      returnStack.push(undefined);\n      wrappedExceptionVal = undefined;\n      updateSid(f);\n      if (sandbox.analysis && sandbox.analysis.functionEnter) {\n          sandbox.analysis.functionEnter(iid, f, dis, args);\n      }\n  }\n\n  // Function exit\n  function Fr(iid) {\n      var isBacktrack = false, tmp, aret, returnVal;\n\n      returnVal = returnStack.pop();\n      if (sandbox.analysis && sandbox.analysis.functionExit) {\n          aret = sandbox.analysis.functionExit(iid, returnVal, wrappedExceptionVal);\n          if (aret) {\n              returnVal = aret.returnVal;\n              wrappedExceptionVal = aret.wrappedExceptionVal;\n              isBacktrack = aret.isBacktrack;\n          }\n      }\n      rollBackSid();\n      if (!isBacktrack) {\n          returnStack.push(returnVal);\n      }\n      // if there was an uncaught exception, throw it\n      // here, to preserve exceptional control flow\n      if (wrappedExceptionVal !== undefined) {\n          tmp = wrappedExceptionVal.exception;\n          wrappedExceptionVal = undefined;\n          throw tmp;\n      }\n      return isBacktrack;\n  }\n\n  // Script enter\n  function Se(iid, val, origFileName) {\n      createAndAssignNewSid();\n      if (sandbox.analysis && sandbox.analysis.scriptEnter) {\n          sandbox.analysis.scriptEnter(iid, val, origFileName);\n      }\n      lastComputedValue = undefined;\n  }\n\n  // Script exit\n  function Sr(iid) {\n      var tmp, aret, isBacktrack;\n      if (sandbox.analysis && sandbox.analysis.scriptExit) {\n          aret = sandbox.analysis.scriptExit(iid, wrappedExceptionVal);\n          if (aret) {\n              wrappedExceptionVal = aret.wrappedExceptionVal;\n              isBacktrack = aret.isBacktrack;\n          }\n      }\n      rollBackSid();\n      if (wrappedExceptionVal !== undefined) {\n          tmp = wrappedExceptionVal.exception;\n          wrappedExceptionVal = undefined;\n          throw tmp;\n      }\n      return isBacktrack;\n  }\n\n\n  // Modify and assign +=, -= ...\n  function A(iid, base, offset, op, flags) {\n      var bFlags = decodeBitPattern(flags, 1); // [isComputed]\n      // avoid iid collision: make sure that iid+2 has the same source map as iid (@todo)\n      var oprnd1 = G(iid+2, base, offset, createBitPattern(bFlags[0], true, false));\n      return function (oprnd2) {\n          // still possible to get iid collision with a mem operation\n          var val = B(iid, op, oprnd1, oprnd2, createBitPattern(false, true, false));\n          return P(iid, base, offset, val, createBitPattern(bFlags[0], true));\n      };\n  }\n\n  // Binary operation\n  function B(iid, op, left, right, flags) {\n      var bFlags = decodeBitPattern(flags, 3); // [isComputed, isOpAssign, isSwitchCaseComparison]\n      var result, aret, skip = false;\n\n      if (sandbox.analysis && sandbox.analysis.binaryPre) {\n          aret = sandbox.analysis.binaryPre(iid, op, left, right, bFlags[1], bFlags[2], bFlags[0]);\n          if (aret) {\n              op = aret.op;\n              left = aret.left;\n              right = aret.right;\n              skip = aret.skip;\n          }\n      }\n\n\n      if (!skip) {\n          switch (op) {\n              case \"+\":\n                  result = left + right;\n                  break;\n              case \"-\":\n                  result = left - right;\n                  break;\n              case \"*\":\n                  result = left * right;\n                  break;\n              case \"/\":\n                  result = left / right;\n                  break;\n              case \"%\":\n                  result = left % right;\n                  break;\n              case \"<<\":\n                  result = left << right;\n                  break;\n              case \">>\":\n                  result = left >> right;\n                  break;\n              case \">>>\":\n                  result = left >>> right;\n                  break;\n              case \"<\":\n                  result = left < right;\n                  break;\n              case \">\":\n                  result = left > right;\n                  break;\n              case \"<=\":\n                  result = left <= right;\n                  break;\n              case \">=\":\n                  result = left >= right;\n                  break;\n              case \"==\":\n                  result = left == right;\n                  break;\n              case \"!=\":\n                  result = left != right;\n                  break;\n              case \"===\":\n                  result = left === right;\n                  break;\n              case \"!==\":\n                  result = left !== right;\n                  break;\n              case \"&\":\n                  result = left & right;\n                  break;\n              case \"|\":\n                  result = left | right;\n                  break;\n              case \"^\":\n                  result = left ^ right;\n                  break;\n              case \"delete\":\n                  result = delete left[right];\n                  break;\n              case \"instanceof\":\n                  result = left instanceof right;\n                  break;\n              case \"in\":\n                  result = left in right;\n                  break;\n              default:\n                  throw new Error(op + \" at \" + iid + \" not found\");\n                  break;\n          }\n      }\n\n      if (sandbox.analysis && sandbox.analysis.binary) {\n          aret = sandbox.analysis.binary(iid, op, left, right, result, bFlags[1], bFlags[2], bFlags[0]);\n          if (aret) {\n              result = aret.result;\n          }\n      }\n      return (lastComputedValue = result);\n  }\n\n\n  // Unary operation\n  function U(iid, op, left) {\n      var result, aret, skip = false;\n\n      if (sandbox.analysis && sandbox.analysis.unaryPre) {\n          aret = sandbox.analysis.unaryPre(iid, op, left);\n          if (aret) {\n              op = aret.op;\n              left = aret.left;\n              skip = aret.skip\n          }\n      }\n\n      if (!skip) {\n          switch (op) {\n              case \"+\":\n                  result = +left;\n                  break;\n              case \"-\":\n                  result = -left;\n                  break;\n              case \"~\":\n                  result = ~left;\n                  break;\n              case \"!\":\n                  result = !left;\n                  break;\n              case \"typeof\":\n                  result = typeof left;\n                  break;\n              case \"void\":\n                  result = void(left);\n                  break;\n              default:\n                  throw new Error(op + \" at \" + iid + \" not found\");\n                  break;\n          }\n      }\n\n      if (sandbox.analysis && sandbox.analysis.unary) {\n          aret = sandbox.analysis.unary(iid, op, left, result);\n          if (aret) {\n              result = aret.result;\n          }\n      }\n      return (lastComputedValue = result);\n  }\n\n  function pushSwitchKey() {\n      switchKeyStack.push(switchLeft);\n  }\n\n  function popSwitchKey() {\n      switchLeft = switchKeyStack.pop();\n  }\n\n  function last() {\n      return (lastComputedValue = lastVal);\n  }\n\n  // Switch key\n  // E.g., for 'switch (x) { ... }',\n  // C1 is invoked with value of x\n  function C1(iid, left) {\n      switchLeft = left;\n      return (lastComputedValue = left);\n  }\n\n  // case label inside switch\n  function C2(iid, right) {\n      var aret, result;\n\n      // avoid iid collision; iid may not have a map in the sourcemap\n      result = B(iid+1, \"===\", switchLeft, right, createBitPattern(false, false, true));\n\n      if (sandbox.analysis && sandbox.analysis.conditional) {\n          aret = sandbox.analysis.conditional(iid, result);\n          if (aret) {\n              if (result && !aret.result) {\n                  right = !right;\n              } else if (result && aret.result) {\n                  right = switchLeft;\n              }\n          }\n      }\n      return (lastComputedValue = right);\n  }\n\n  // Expression in conditional\n  function C(iid, left) {\n      var aret;\n      if (sandbox.analysis && sandbox.analysis.conditional) {\n          aret = sandbox.analysis.conditional(iid, left);\n          if (aret) {\n              left = aret.result;\n          }\n      }\n\n      lastVal = left;\n      return (lastComputedValue = left);\n  }\n\n  function S(iid, f) {\n      if (sandbox.analysis && sandbox.analysis.runInstrumentedFunctionBody) {\n          return sandbox.analysis.runInstrumentedFunctionBody(iid, f, getPropSafe(f, SPECIAL_PROP_IID), getPropSafe(f, SPECIAL_PROP_SID));\n      }\n      return true;\n  }\n\n  function L() {\n      return lastComputedValue;\n  }\n\n\n  function X1(iid, val) {\n      if (sandbox.analysis && sandbox.analysis.endExpression) {\n          sandbox.analysis.endExpression(iid);\n      }\n\n      return (lastComputedValue = val);\n  }\n\n  function endExecution() {\n      if (sandbox.analysis && sandbox.analysis.endExecution) {\n          return sandbox.analysis.endExecution();\n      }\n  }\n\n\n  function log(str) {\n      if (sandbox.Results && sandbox.Results.execute) {\n          sandbox.Results.execute(function(div, jquery, editor){\n              div.append(str+\"<br>\");\n          });\n      } else {\n          console.log(str);\n      }\n  }\n\n\n  //----------------------------------- End Jalangi Library backend ---------------------------------\n\n  sandbox.U = U; // Unary operation\n  sandbox.B = B; // Binary operation\n  sandbox.C = C; // Condition\n  sandbox.C1 = C1; // Switch key\n  sandbox.C2 = C2; // case label C1 === C2\n  sandbox._ = last;  // Last value passed to C\n\n  sandbox.H = H; // hash in for-in\n  sandbox.I = I; // Ignore argument\n  sandbox.G = G; // getField\n  sandbox.P = P; // putField\n  sandbox.R = R; // Read\n  sandbox.W = W; // Write\n  sandbox.N = N; // Init\n  sandbox.T = T; // object/function/regexp/array Literal\n  sandbox.F = F; // Function call\n  sandbox.M = M; // Method call\n  sandbox.A = A; // Modify and assign +=, -= ...\n  sandbox.Fe = Fe; // Function enter\n  sandbox.Fr = Fr; // Function return\n  sandbox.Se = Se; // Script enter\n  sandbox.Sr = Sr; // Script return\n  sandbox.Rt = Rt; // returned value\n  sandbox.Th = Th; // thrown value\n  sandbox.Ra = Ra;\n  sandbox.Ex = Ex;\n  sandbox.L = L;\n  sandbox.X1 = X1; // top level expression\n  sandbox.Wi = Wi; // with statement\n  sandbox.endExecution = endExecution;\n\n  sandbox.S = S;\n\n  sandbox.EVAL_ORG = EVAL_ORG;\n  sandbox.log = log;\n})(J$$);\n\n\n\n//# sourceURL=webpack://jalangi2-runtime/./src/runtime.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/entry.js");
/******/ 	
/******/ })()
;