import { SymbolicDOMTree } from "./symdom-tree.js";
import { SymbolicDOMTheory } from "./symdom-theory.js";
import { SymbolicDOMChecker } from "./symdom-checker.js";
import { ClauseBuilder, UnitClause, CompoundClause, RootFormula } from "./clause.js";

/**
 * Represents the symbolic DOM solver. 
 * This class helps represent and reduce constraints to a set of possible symbolic DOM trees.
 *
 * Constraints are expressed as a first-order logic formula composed of unit clauses.
 * A unit clause is a clause that contains exactly one literal.
 * A root formula is a conjunction of unit clauses that contains exactly one isRoot clause.
 * Note that, literal in each unit clause has its own namespace base on which root formula it belongs to.
 */
export class SymbolicDOMSolver {
  constructor() {
    this.rawConstraints = null;
    this.DNFTypeRootFormulas = null;
    this.rootFormulas = new Map();

    this.storedConstraintSet = new Map();
    this.storedRoots = null;
  }

  clear() {
    this.rawConstraints = null;
    this.DNFTypeRootFormulas = null;
    this.rootFormulas.clear();
  }

  store(name, rootFormula) {
    this.storedRoots = rootFormula;
    this.storedConstraintSet.set(name, rootFormula);
  }

  /**
   * Adds a new constraint to the solver.
   * @param {string} verb - The verb of the constraint.
   * @param {UnitClause|CompoundClause|RootFormula|SymbolicDOMTree} constraint - The constraint to add.
   */
  addConstraint(operator, constraint) {
    if (operator == "and") {
      if (constraint instanceof UnitClause) {
        this._andNewUnitConstraint(constraint);
      } else if (constraint instanceof RootFormula) {
        this._andNewRootFormula(constraint);
      }
      else if (constraint instanceof CompoundClause) {
        this._andNewConstraintCompound(constraint);
      } else {
        throw new Error("Expected a UnitClause or CompoundClause instance.");
      }
    } else if (operator == "or") {
      throw new Error("Or operator is not supported.");
    }
  }

  /**
   * Adds a new and constraint to the solver.
   * @param {*} unitClause 
   */
  _andNewUnitConstraint(unitClause) {
    if (!(unitClause instanceof UnitClause)) {
      throw new Error("Expected a UnitClause instance.");
    }

    if (!this.rawConstraints) {
      this.rawConstraints = unitClause;
    } else {
      this.rawConstraints = ClauseBuilder.and(this.rawConstraints, unitClause);
    }
  }

  /**
   * Recursively checks and adds a compound constraint.
   * @param {CompoundClause} clauses - The compound clause to add.
   */
  _andNewConstraintCompound(clauses) {
    if (!(clauses instanceof CompoundClause)) {
      throw new Error("Expected a CompoundClause instance.");
    }

    const processClause = (clause) => {
      if (clause instanceof RootFormula) {
        if (!this.rootFormulas.has(clause.namespace)) {
          this.rootFormulas.set(clause.namespace, RootFormula);
        }
      } else if (clause instanceof CompoundClause) {
        for (const subClause of clause.clauses) {
          processClause(subClause);
        }
      }
    };

    processClause(clauses);
    if (!this.rawConstraints) {
      this.rawConstraints = clauses;
    } else {
      this.rawConstraints = ClauseBuilder.and(this.rawConstraints, clauses);
    }
  }

  /**
   * Add a new root formula to the solver.
   * @param {RootFormula} symDOMTree 
   */
  _andNewRootFormula(rootFormula) {
    if (!(rootFormula instanceof RootFormula)) {
      throw new Error("Expected a RootFormula instance.");
    }

    this.rootFormulas.set(rootFormula.namespace, rootFormula);

    if (!this.rawConstraints) {
      this.rawConstraints = rootFormula;
    } else {
      this.rawConstraints = ClauseBuilder.and(this.rawConstraints, rootFormula);
    }
  }
  
  /**
   * Reduce the constraints to DNF form of root formulas.
   * 
   * E.g., (a and b) and (X or Y) => X' or Y'
   */
  reduceToDNFRootFormulasOnly() {
    let reducedConstraints = this._reduceToDNF();

    // Assume the current formula looks like (a and b and X) or (a and b and Y)
    // Merge every compound clause that has a root formula and unit clauses
    this.DNFTypeRootFormulas = this._findAndMerge(reducedConstraints);

    if (!SymbolicDOMChecker.checkNoUnitClauses(this.DNFTypeRootFormulas)) {
      throw new Error("The DNF form should not contain any unit clauses.");
    }
    
    let results = [];
    for (let i = 0; i < this.DNFTypeRootFormulas.clauses.length; i++) {
      let rootFormula = this.DNFTypeRootFormulas.clauses[i];
      let rootFormulaCNF = this.convertToRootFormulaToCNF(rootFormula.flatten());
      if (rootFormulaCNF instanceof CompoundClause && rootFormulaCNF.operator === 'or') {
        for (let clause of rootFormulaCNF.clauses) {
          if (!SymbolicDOMChecker.checkCNFOfUnitClauses(clause)) {
            throw new Error("The CNF form should contain only unit clauses.");
          }
          results.push(clause);
        }
      } else {
        if (!SymbolicDOMChecker.checkCNFOfUnitClauses(rootFormulaCNF)) {
          throw new Error("The CNF form should contain only unit clauses.");
        }
        results.push(rootFormulaCNF);
      }
    }

    this.DNFTypeRootFormulas.clauses = results;
    return results;
  }

  /**
   * Given a root formula, convert it to Conjunctive Normal Form (CNF) of unit clauses.
   * This function should return a compound clause 'or' where each sub-clause is root formula in CNF format.
   * 
   * This largely follows the _reduceToDNF() function, however, the process is root formula preserving.
   * 
   * @param {RootFormula} rootFormula
   */
  convertToRootFormulaToCNF(rootFormula) {
    const convertToDNF = (clause) => {
      if (clause instanceof UnitClause) {
        return clause;
      }
      
      let newClause = this.distributeAndOverOrOneStep(clause, false, true);
      if (newClause === clause) { return newClause; }

      for (let i = 0; i < newClause.clauses.length; i++) {
        newClause.clauses[i] = convertToDNF(newClause.clauses[i].flatten());
      }

      return newClause;
    }

    if (!rootFormula.isRootFormula) {
      throw new Error("Expected a root formula.");
    }

    return convertToDNF(rootFormula);
  }

  /**
   * Reduce the raw constraints to disjunctive normal form of root formulas and unit clauses.
   * 
   * In other words, there shouldn't be any compound OR clauses besides the first level.
   * The root formulas are considered as cell and won't be touched.
   * 
   * E.g., (a and b) and (X or Y) => (a and b and X) or (a and b and Y)
   */
  _reduceToDNF() {
    if (!this.rawConstraints || this.rawConstraints instanceof UnitClause) {
      return;
    }
  
    // If all clauses are root formulas, no reduction is needed
    const containsNonRoot = (clause) => {
      if (clause instanceof RootFormula) {
        return false;
      } else if (clause instanceof CompoundClause) {
        return clause.clauses.some(containsNonRoot);
      }
      return true;
    };
  
    if (!containsNonRoot(this.rawConstraints)) {
      return this.rawConstraints;
    }
  
    // Convert to Disjunctive Normal Form (DNF) recursively
    const convertToDNF = (clause) => {
      // Traverse the tree to the leaves and apply the distributive law
      let newClause = this.distributeAndOverOrOneStep(clause);
      
      if (newClause === clause) { return newClause; }

      for (let i = 0; i < newClause.clauses.length; i++) {
        newClause.clauses[i] = convertToDNF(newClause.clauses[i]);
      }

      return newClause;
    };

    return convertToDNF(this.rawConstraints);
  }

  /**
   * X and (Y or Z) => (X and Y) or (X and Z)
   * @param {*} clause 
   * @returns 
   */
  distributeAndOverOrOneStep = (clause, earlyStop=true, rootFormulaPreserve=false) => {
    if (!(clause instanceof CompoundClause) || clause.operator != 'and') {
      return clause;
    }

    if (earlyStop && clause.isRootFormula) {
      return clause;
    }

    // Pick one OR compound clause from its clauses
    // If not, then there is no OR clause to distribute over
    const orClause = clause.clauses.find(clause => clause instanceof CompoundClause && clause.operator == 'or');
    if (!orClause) {
      return clause;
    }

    let newClauses = [];
    let otherClauses = clause.clauses.filter(clause => clause !== orClause);
    if (otherClauses.length > 1) {
      otherClauses = new CompoundClause('and', otherClauses);
    } else {
      otherClauses = otherClauses[0];
    }

    function hasIsRootClause(clause) {
      if (clause instanceof UnitClause && clause.verb === 'isRoot') {
        return true;
      } else if (clause instanceof CompoundClause) {
        return clause.clauses.some(hasIsRootClause);
      }
      return false;
    }

    for (let orSubClause of orClause.clauses) {
      if (orSubClause.isRootFormula) {
        orSubClause = orSubClause.clone();
      }

      let newAndClause;
      if (rootFormulaPreserve && (hasIsRootClause(orSubClause) || hasIsRootClause(otherClauses))) {
        newAndClause = new RootFormula(null, [otherClauses.unwrap(), orSubClause.unwrap()]);
      }else{
        newAndClause = new CompoundClause('and', [otherClauses, orSubClause]);
      }

      newClauses.push(newAndClause);
    }

    return new CompoundClause('or', newClauses);
  };

  /**
   * Try the best to merge the unit clauses to the root formula.
   * 
   * @example
   * (a and b and X) or (a and b and Y) => (a and b and X) or (a and b and Y) => (X' or Y')
   * (a and b and X and Y) => (a and b and X and Y) => (X' and Y')
   * 
   * @param {CompoundClause|UnitClause} clause: The DNF form of root formulas and unit clauses. No nested OR compound clauses. 
   * @returns {CompoundClause<OR>|RootFormula} The merged root formulas. It should not contain any unit clauses after merging.
   */
  _findAndMerge(clause, firstCall=true) {
    if (!SymbolicDOMChecker.checkDNF(clause) && firstCall) {
      throw new Error("The clause is not in DNF form.");
    }

    if (clause instanceof UnitClause || clause instanceof RootFormula || !clause.hasRootFormula()) {
      return clause;
    }

    // For compound clauses, only handle the (a and/or b and/or X) case
    // If all the clause.clauses are unit clauses with one root formula, then merge them
    let rootFormulas = clause.clauses.filter(clause => clause.hasRootFormula() || clause instanceof RootFormula);
    let nonRootClauses = clause.clauses.filter(clause => !(clause.hasRootFormula() || clause instanceof RootFormula));

    let mergedRootFormulas = [];
    for (let rf of rootFormulas) {
      let merged = this._findAndMerge(rf, false);
      if (merged instanceof Array) {
        mergedRootFormulas.push(...merged);
      } else {
        mergedRootFormulas.push(merged);
      }
    }
    
    let mergedNonRootClauses = [];
    for (let otherClause of nonRootClauses) {
      let merged = this._findAndMerge(otherClause);
      if (merged instanceof Array) {
        throw new Error("Unexpected array of root formulas for NonRootClauses.");
      } else {
        mergedNonRootClauses.push(merged);
      }
    }

    // Handle the case where there is only one root formula and multiple unit clauses
    let returnRFs = []
    for (let i=0; i<mergedRootFormulas.length; i++) {
      let rootFormula = mergedRootFormulas[i];
      for (let otherClause of mergedNonRootClauses) {
        if (otherClause instanceof UnitClause) {
          if (clause.operator === 'and') {
            rootFormula = this.andOperatorBetweenRootAndUnit(rootFormula, otherClause.clone());
          } else if (clause.operator === 'or') {
            rootFormula = this.orOperatorBetweenRootAndUnit(rootFormula, otherClause.clone());
          }
        } else if (!otherClause.hasRootFormula()) {
          if (clause.operator === 'and') {
            rootFormula = this.andOperatorBetweenRootAndNonRootCompound(rootFormula, otherClause.clone());
          } else if (clause.operator === 'or') {
            rootFormula = this.orOperatorBetweenRootAndNonRootCompound(rootFormula, otherClause.clone());
          }
        }
      }
      returnRFs.push(rootFormula);
    }
    
    if (firstCall) {
      return new CompoundClause(clause.operator, returnRFs);
    } else {
      return returnRFs;
    }
  }

  /**
   * Merge the stored constraint set with the current constraint set.
   * 
   * @param {Array<String>|"ALL"} name - The name of the stored constraint set.
   * @returns {Array[RootFormula]} - The merged root formulas.
   */
  mergeStoredConstraintSet(names){

  }

  /**
   * merge preNode and postNode, the result is saved in preNode
   * 
   * @param {SymbolicDOMNode} preNode - 
   * @param {SymbolicDOMNode} postNode - 
   */
  _mergeDOMNodes(preNode, postNode){
    // step1: check each attribute, see if there is conflict
    if (postNode.attributes){
        for (const attrName in postNode.attributes){
            if (attrName in preNode.attributes){
                if (preNode.attributes[attrName]!=postNode.attributes[attrName]){
                    throw new Error(`Conflict attributes: ${attrName}`);
                }
            }
            else{
                preNode.attributes[attrName] = postNode.attributes[attrName];
            }
        }
    }
    // step2: check types
    var resultTypes = [];
    if (preNode.nodeTypes[0]=='*'){
        resultTypes = postNode.nodeTypes;
    }
    else if (postNode.nodeTypes[0]=='*'){
        resultTypes = preNode.nodeTypes;
    }
    else if (preNode.nodeTypes!=postNode.nodeTypes){
        // get the common types between them
        for (const type of preNode.nodeTypes){
            if (postNode.nodeTypes.includes(type)){
                resultTypes.push(type);
            }
        }
        if (!resultTypes.length){
            throw new Error(`Conflict types`);
        }
    }
    preNode.nodeTypes = resultTypes;
    // step3: check children recursively, not sure
    preNode.children = preNode.children.concat(postNode.children);
    // return preNode;
  }

  /**
   * merge pre and post DOM Trees, the result is saved in pre
   * 
   * @param {SymbolicDOMTree} pre - 
   * @param {SymbolicDOMTree} post - 
   * @param {boolean} checkSibling - if it is merging the topmost constraints, check siblings number
   */
  _mergeDOMTrees(pre, post, checkSibling=false){
    // var newTree = new SymbolicDOMTree();
    var siblingMerged = false;
    if (checkSibling){
        if (pre.topLevelSiblingNodes.length!=post.topLevelSiblingNodes.length){
            throw new Error(`Sibling number conflict at first stage`);
        }
    }
    for (const variable in pre.bind){
        if (post.bind.hasOwnProperty(variable)){
            console.log('Same variable binding hit!')
            console.log('Variable:', variable);
            console.log('Pre node:', pre.bind[variable]);
            console.log('Post node:', post.bind[variable]);
            console.log('\n');
            // merge nodes bound to same variable
            this._mergeDOMNodes(pre.DOMSymbols[pre.bind[variable]], post.DOMSymbols[post.bind[variable]]);
            // take care of thier siblings
            if (!siblingMerged){
                if (!pre.topLevelSiblingNodes.length){
                    pre.topLevelSiblingNodes = post.topLevelSiblingNodes;
                }
                else if (!post.topLevelSiblingNodes.length){
                    post.topLevelSiblingNodes = pre.topLevelSiblingNodes;
                }
                else if (pre.topLevelSiblingNodes.length>1 && post.topLevelSiblingNodes.length>1){
                    throw new Error(`More than one sibling case not implemented!`);
                }
                // this only applies to the case where there is only one sibling
                else{
                    this._mergeDOMNodes(pre.topLevelSiblingNodes[0], post.topLevelSiblingNodes[0]);
                }
            }
        }
    }

  }

  mergeStoredRootsWithOutside(roots){
    var preTree, postTree;
    if (roots.length==1 && this.storedRoots.length==1){
      preTree = roots[0].toSymbolicDOMTree();
      postTree =  this.storedRoots[0].toSymbolicDOMTree();
      this._mergeDOMTrees(preTree, postTree);
      preTree.concreteToString();
      
    }
    // for (let preRoot of roots){
    //   preTree = preRoot.toSymbolicDOMTree();
    //   for (let postRoot of this.storedRoots){
    //     postTree = postRoot.toSymbolicDOMTree();
    //     newTree = this._mergeDOMTrees(preTree, postTree);
    //     newTree.concreteToString();
    //   }
    // }
  }

  

  andOperatorBetweenRootFormulas(rootFormula1, rootFormula2) {
    // Ignore the unit clause for and operator
    return rootFormula1;
  }

  /**
   * Merge the constraints between the root and unit clauses.
   * 
   * @param {RootFormula} rootFormula - The root formula to merge with.
   * @param {UnitClause} unitClause - The unit clause to merge with.
   */
  andOperatorBetweenRootAndUnit(rootFormula, unitClause) {
    if (SymbolicDOMTheory.andOperatorBetweenRootAndUnit(rootFormula, unitClause)){
      console.log("No Conflict detected between the root and the unit.");
      unitClause.namespace = rootFormula.namespace;
      rootFormula.addNewUnitClause('and', unitClause);
    }

    return rootFormula;
  }

  /**
   * Merge the constraints between the root and non-root compound clauses (No Root Formula Nested).
   */
  andOperatorBetweenRootAndNonRootCompound(rootFormula, compound) {
    if (SymbolicDOMTheory.andOperatorBetweenRootAndNonRootCompound(rootFormula, compound)) {
      console.log("No Conflict detected between the root and the compound.");
      compound.namespace = rootFormula.namespace;
      rootFormula.addNewCompoundClause('and', compound); // Treat the compound as a unit clause
    }

    return rootFormula;
  }

  /**
   * Merge the constraints between the root and non-root compound clauses (No Root Formula Nested).
   */
  orOperatorBetweenRootAndNonRootCompound(rootFormula, compound) {
    // Ignore the unit clause for or operator
    return rootFormula;
  }

  /**
   * Merge the constraints between the root and unit clauses.
   * 
   * @param {RootFormula} rootFormula - The root formula to merge with.
   * @param {UnitClause} unitClause - The unit clause to merge with.
   */
  orOperatorBetweenRootAndUnit(rootFormula, unitClause) {
    // Ignore the unit clause for or operator
    return rootFormula;
  }
}
