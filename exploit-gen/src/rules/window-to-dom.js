import { ClauseBuilder, UnitClause, CompoundClause, RootFormula } from "../clause.js";
import { THEHULK_TNS1, THEHULK_TNS2 } from '../constants/thehulk-tag-set.js';

export class WindowToDOMRule {
  /**
   * Entry point for applying rules.
   * @param {String} operation 
   * @param  {...any} args 
   * @returns 
   */
  static apply(operation, ...args) {
    if (operation === 'getField') {
      return WindowToDOMRule.getFieldOp(...args);
    } else {
      return [];
    }
  }

  /**
   * Returns the virtual DOM element(s) for the given field that can achieve WINDOW2DOM objective.
   * @param {*} base 
   * @param {*} offset 
   * @returns {Array<RootFormula>} List of root formulas that can be used to achieve WINDOW2DOM objective.
   */
  static getFieldOp(base, offset) {
    let allRules = [];
    if (base !== 'window') {
      return allRules;
    }

    // ==============================
    // Rule 01
    // Any elements from TNS1 with id=P can clobber window.P
    // e.g., <div id="p"></div>
    // ==============================
    let rule01 = new RootFormula(null, [new UnitClause(null, 'isRoot', 'R1')]);
    rule01.addNewUnitClause('and', new UnitClause(rule01.namespace, 'declareNode', 'R1'));
    rule01.addNewUnitClause('and', new UnitClause(rule01.namespace, 'declareString', 'P'));
    rule01.addNewUnitClause(
      'and', new CompoundClause('or', THEHULK_TNS1.map(tag => new UnitClause(rule01.namespace, 'hasTagName', 'R1', tag)))
    );
    rule01.addNewUnitClause('and', new UnitClause(rule01.namespace, 'hasAttribute', 'R1', 'id', 'P'));
    allRules.push(rule01);

    // ==============================
    // Rule 02
    // Any elements from TNS2 with name=P can clobber window.P
    // e.g., <form name="p"></form>
    // ==============================
    let rule02 = new RootFormula(null, [new UnitClause(null, 'isRoot', 'R1')]);
    rule02.addNewUnitClause('and', new UnitClause(rule02.namespace, 'declareNode', 'R1'));
    rule02.addNewUnitClause('and', new UnitClause(rule02.namespace, 'declareString', 'P'));
    rule02.addNewUnitClause(
      'and', new CompoundClause('or', THEHULK_TNS2.map(tag => new UnitClause(rule02.namespace, 'hasTagName', 'R1', tag)))
    );
    rule02.addNewUnitClause('and', new UnitClause(rule02.namespace, 'hasAttribute', 'R1', 'name', 'P'));
    allRules.push(rule02);

    // ==============================
    // Rule 03
    // HTMLCollection with Nodes in Rule 1 and Rule 2
    // e.g., <div id="p"></div><div id="p"></div> or <span name="p"></span><span name="p"></span>
    // ==============================
    let rule03 = new RootFormula(null, [new UnitClause(null, 'isRoot', 'R1')]);
    rule03.addNewUnitClause('and', new UnitClause(rule03.namespace, 'declareNode', 'R1'));
    rule03.addNewUnitClause('and', new UnitClause(rule03.namespace, 'declareString', 'P'));
    rule03.addNewUnitClause('and', new UnitClause(rule03.namespace, 'length', 'getSiblings(R1)', '>=', '1'));
    let branchClause03_1 = new CompoundClause('and', [
      new CompoundClause('or', THEHULK_TNS1.map(tag => new UnitClause(rule03.namespace, 'hasTagName', 'R2', tag))),
      new UnitClause(rule03.namespace, 'hasAttribute', 'R2', 'id', 'P')
    ]);
    let branchClause03_2 = new CompoundClause('and', [
      new CompoundClause('or', THEHULK_TNS2.map(tag => new UnitClause(rule03.namespace, 'hasTagName', 'R2', tag))),
      new UnitClause(rule03.namespace, 'hasAttribute', 'R2', 'name', 'P')
    ]);

    rule03.addNewCompoundClause('and', new CompoundClause('or', [branchClause03_1, branchClause03_2]));
    rule03.addNewUnitClause('and', new UnitClause(rule03.namespace, 'hasSibling', 'R1', 'R2'));
    rule03.addNewUnitClause('and', new UnitClause(rule03.namespace, 'forall', 'getSiblings(R1)', 'R2'));
    allRules.push(rule03);

    // ==============================
    // Rule 04
    // e.g., <div id="p"><button id="p"></button></div>
    // (Nested child scenario)
    // ==============================
    let rule04 = new RootFormula(null, [new UnitClause(null, 'isRoot', 'R1')]);
    rule04.addNewUnitClause('and', new UnitClause(rule04.namespace, 'declareNode', 'R1'));
    rule04.addNewUnitClause('and', new UnitClause(rule04.namespace, 'declareString', 'P'));
    rule04.addNewUnitClause('and', new UnitClause(rule04.namespace, 'length', 'getChildren(R1)', '>=', '1'));

    let branchClause04_1 = new CompoundClause('and', [
      new CompoundClause('or', THEHULK_TNS1.map(tag => new UnitClause(rule04.namespace, 'hasTagName', 'R2', tag))),
      new UnitClause(rule04.namespace, 'hasAttribute', 'R2', 'id', 'P')
    ]);
    let branchClause04_2 = new CompoundClause('and', [
      new CompoundClause('or', THEHULK_TNS2.map(tag => new UnitClause(rule04.namespace, 'hasTagName', 'R2', tag))),
      new UnitClause(rule04.namespace, 'hasAttribute', 'R2', 'name', 'P')
    ]);

    rule04.addNewCompoundClause('and', new CompoundClause('or', [branchClause04_1, branchClause04_2]));
    rule04.addNewUnitClause('and', new UnitClause(rule04.namespace, 'hasChildren', 'R1', 'R2'));
    rule04.addNewUnitClause('and', new UnitClause(rule04.namespace, 'forall', 'getChildren(R1)', 'R2'));
    allRules.push(rule04);

    return allRules;
  }
}

export default WindowToDOMRule;
