import { ClauseBuilder, UnitClause, CompoundClause, RootFormula } from "../clause.js";
import { THEHULK_TNS1, THEHULK_TNS2 } from '../constants/thehulk-tag-set.js';

export class WindowToDOMRule {
  constructor() {
    this.rules = this.initializeRules();  
  }

  /**
   * Initializes and returns all the rules.
   * @returns {Object} An object containing all the rules.
   */
  initializeRules() {
    const rules = {};

    // ==============================
    // Rule 01
    // Any elements from TNS1 with id=P can clobber window.P
    // e.g., <div id="p"></div>
    // ==============================
    let rule01 = new RootFormula(null, [new UnitClause(null, 'isRoot', '$R1')]);
    rule01.addNewUnitClause('and', new UnitClause(rule01.namespace, 'declareNode', '$R1'));
    rule01.addNewUnitClause('and', new UnitClause(rule01.namespace, 'declareString', '$P'));
    rule01.addNewUnitClause('and', new CompoundClause('or', THEHULK_TNS1.map(tag => new UnitClause(rule01.namespace, 'hasTagName', '$R1', tag))));
    rule01.addNewUnitClause('and', new UnitClause(rule01.namespace, 'hasAttribute', '$R1', 'id', '$P'));
    rules['rule01'] = rule01;
  
    // ==============================
    // Rule 02
    // Any elements from TNS2 with name=P can clobber window.P
    // e.g., <form name="p"></form>
    // ==============================
    let rule02 = new RootFormula(null, [new UnitClause(null, 'isRoot', '$R1')]);
    rule02.addNewUnitClause('and', new UnitClause(rule02.namespace, 'declareNode', '$R1'));
    rule02.addNewUnitClause('and', new UnitClause(rule02.namespace, 'declareString', '$P'));
    rule02.addNewUnitClause('and', new CompoundClause('or', THEHULK_TNS2.map(tag => new UnitClause(rule02.namespace, 'hasTagName', '$R1', tag))));
    rule02.addNewUnitClause('and', new UnitClause(rule02.namespace, 'hasAttribute', '$R1', 'name', '$P'));
    rules['rule02'] = rule02;
  
    // ==============================
    // Rule 03
    // HTMLCollection with Nodes in Rule 1 and Rule 2
    // e.g., <div id="p"></div><div id="p"></div> or <span name="p"></span><span name="p"></span>
    // ==============================
    let rule03 = new RootFormula(null, [new UnitClause(null, 'isRoot', '$R1')]);
    rule03.addNewUnitClause('and', new UnitClause(rule03.namespace, 'declareNode', '$R1'));
    rule03.addNewUnitClause('and', new UnitClause(rule03.namespace, 'declareNode', '$R2'));
    rule03.addNewUnitClause('and', new UnitClause(rule03.namespace, 'length(getSiblings)', '$R1', '>=', '1'));
  
    // For the forall(getSiblings(R1), CompoundClause) clause
    let branchClause03_1 = new CompoundClause('and', [
      new CompoundClause('or', THEHULK_TNS1.map(tag => new UnitClause(rule03.namespace, 'hasTagName', '$R1', tag))), 
      new UnitClause(rule03.namespace, 'hasAttribute', '$R1', 'id', '$P'),
      new CompoundClause('or', THEHULK_TNS1.map(tag => new UnitClause(rule03.namespace, 'hasTagName', '$R2', tag))), 
      new UnitClause(rule03.namespace, 'hasAttribute', '$R2', 'id', '$P')
    ]);
  
    let branchClause03_2 = new CompoundClause('and', [
      new CompoundClause('or', THEHULK_TNS2.map(tag => new UnitClause(rule03.namespace, 'hasTagName', '$R1', tag))), 
      new UnitClause(rule03.namespace, 'hasAttribute', '$R1', 'name', '$P'),
      new CompoundClause('or', THEHULK_TNS2.map(tag => new UnitClause(rule03.namespace, 'hasTagName', '$R2', tag))), 
      new UnitClause(rule03.namespace, 'hasAttribute', '$R2', 'name', '$P')
    ]);
  
    rule03.addNewCompoundClause('and', new CompoundClause('or', [branchClause03_1, branchClause03_2]));
    rule03.addNewUnitClause('and', new UnitClause(rule03.namespace, 'hasSibling', '$R1', '$R2'));
    rule03.addNewUnitClause('and', new UnitClause(rule03.namespace, 'forall', '$R1', 'Siblings', '$R2'));
    rules['rule03'] = rule03;
  
    // ==============================
    // Rule 04
    // e.g., <div id="p"><button id="p"></button></div>
    // (Nested child scenario)
    // ==============================
    let rule04 = new RootFormula(null, [new UnitClause(null, 'isRoot', '$R1')]);
    rule04.addNewUnitClause('and', new UnitClause(rule04.namespace, 'declareNode', '$R1'));
    rule04.addNewUnitClause('and', new UnitClause(rule04.namespace, 'declareNode', '$R2'));
    rule04.addNewUnitClause('and', new UnitClause(rule04.namespace, 'length(getChildren)', '$R1', '>=', '1'));
  
    // For the forall(getChildren(R1), CompoundClause) clause
    let branchClause04_1 = new CompoundClause('and', [
      new CompoundClause('or', THEHULK_TNS1.map(tag => new UnitClause(rule04.namespace, 'hasTagName', '$R1', tag))), 
      new UnitClause(rule04.namespace, 'hasAttribute', '$R1', 'id', '$P'),
      new CompoundClause('or', THEHULK_TNS1.map(tag => new UnitClause(rule04.namespace, 'hasTagName', '$R2', tag))), 
      new UnitClause(rule04.namespace, 'hasAttribute', '$R2', 'id', '$P')
    ]);
  
    let branchClause04_2 = new CompoundClause('and', [
      new CompoundClause('or', THEHULK_TNS2.map(tag => new UnitClause(rule04.namespace, 'hasTagName', '$R1', tag))), 
      new UnitClause(rule04.namespace, 'hasAttribute', '$R1', 'name', '$P'),
      new CompoundClause('or', THEHULK_TNS2.map(tag => new UnitClause(rule04.namespace, 'hasTagName', '$R2', tag))), 
      new UnitClause(rule04.namespace, 'hasAttribute', '$R2', 'name', '$P')
    ]);
  
    rule04.addNewCompoundClause('and', new CompoundClause('or', [branchClause04_1, branchClause04_2]));
    rule04.addNewUnitClause('and', new UnitClause(rule04.namespace, 'hasChild', '$R1', '$R2'));
    rule04.addNewUnitClause('and', new UnitClause(rule04.namespace, 'forall', '$R1', 'Children', '$R2'));
    rules['rule04'] = rule04;

    return rules;
  }

  /**
   * Entry point for applying rules.
   * @param {String} operation 
   * @param  {...any} args 
   * @returns 
   */
  apply(operation, ...args) {
    if (operation === 'getField') {
      return this.getFieldOp(...args);
    } else {
      return [];
    }
  }

  /**
   * Returns the virtual DOM element(s) for the given field that can achieve WINDOW2DOM objective.
   * @param {*} base 
   * @param {*} offset 
   * @returns {Array<RootFormula>} List of root formulas that can be used to achieve WINDOW2DOM objective.
   */
  getFieldOp(base, offset) {
    let allRules = {};
    if (base !== 'window') {
      return allRules;
    }
    
    return this.rules;
  }
}

export default WindowToDOMRule;
