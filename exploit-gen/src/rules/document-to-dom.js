import { ClauseBuilder, UnitClause, CompoundClause, RootFormula } from "../clause.js";
import { THEHULK_TNS2 } from '../constants/thehulk-tag-set.js';

export class DocumentToDOMRule {
  constructor() {
    this.rules = this.initializeRules();
  }

  /**
   * Initializes and returns all the rules.
   * @returns {Object} An object containing all the rules.
   */
  initializeRules() {
    const rules = {};

    // ==============================
    // Rule 05
    // Any elements from TNS2 with name=P can clobber document.P
    // E.g., <img name="p" />
    // ==============================
    let rule05 = new RootFormula(null, [new UnitClause(null, 'isRoot', '$R1')]);
    rule05.addNewUnitClause('and', new UnitClause(rule05.namespace, 'declareNode', '$R1'));
    rule05.addNewUnitClause('and', new UnitClause(rule05.namespace, 'declareString', '$P'));
    rule05.addNewUnitClause('and', new UnitClause(rule05.namespace, 'hasAttribute', '$R1', 'name', '$P'));
    rule05.addNewUnitClause('and', new CompoundClause('or', THEHULK_TNS2.map(tag => new UnitClause(rule05.namespace, 'hasTagName', '$R1', tag))));
    rules['rule05'] = rule05;

    // ==============================
    // Rule 06
    // Object element with id=P can clobber document.P
    // E.g., <object id="p"></object>
    // ==============================
    let rule06 = new RootFormula(null, [new UnitClause(null, 'isRoot', '$R1')]);
    rule06.addNewUnitClause('and', new UnitClause(rule06.namespace, 'declareNode', '$R1'));
    rule06.addNewUnitClause('and', new UnitClause(rule06.namespace, 'declareString', '$P'));
    rule06.addNewUnitClause('and', new UnitClause(rule06.namespace, 'hasTagName', '$R1', 'object'));
    rule06.addNewUnitClause('and', new UnitClause(rule06.namespace, 'hasAttribute', '$R1', 'id', '$P'));
    rules['rule06'] = rule06;

    // ==============================
    // Rule 07
    // HTMLCollection with Nodes in Rule 5 and Rule 6
    // E.g., <img name="p" /><img name="p" />
    // ==============================
    let rule07 = new RootFormula(null, [new UnitClause(null, 'isRoot', '$R1')]);
    rule07.addNewUnitClause('and', new UnitClause(rule07.namespace, 'declareNode', '$R1'));
    rule07.addNewUnitClause('and', new UnitClause(rule07.namespace, 'declareNode', '$R2'));
    rule07.addNewUnitClause('and', new UnitClause(rule07.namespace, 'length(getSiblings)', '$R1', '>=', '1'));

    // For the forall(getSiblings(R1), CompoundClause) clause
    // forall(getSiblings(R1), CompoundClause) =>
    // (declare R2) and (hasSibling, R1, R2) and CompoundClause(R2) and (forall R1, Siblings, R2)
    let branchClause07_1 = new CompoundClause('and', [
      new CompoundClause('or', THEHULK_TNS2.map(tag => new UnitClause(rule07.namespace, 'hasTagName', '$R1', tag))),
      new UnitClause(rule07.namespace, 'hasAttribute', '$R1', 'name', '$P'),
      new CompoundClause('or', THEHULK_TNS2.map(tag => new UnitClause(rule07.namespace, 'hasTagName', '$R2', tag))),
      new UnitClause(rule07.namespace, 'hasAttribute', '$R2', 'name', '$P')
    ]);

    let branchClause07_2 = new CompoundClause('and', [
      new UnitClause(rule07.namespace, 'hasTagName', '$R1', 'object'),
      new UnitClause(rule07.namespace, 'hasAttribute', '$R1', 'id', '$P'),
      new UnitClause(rule07.namespace, 'hasTagName', '$R2', 'object'),
      new UnitClause(rule07.namespace, 'hasAttribute', '$R2', 'id', '$P')
    ]);

    rule07.addNewCompoundClause('and', new CompoundClause('or', [branchClause07_1, branchClause07_2]));
    rule07.addNewUnitClause('and', new UnitClause(rule07.namespace, 'hasSibling', '$R1', '$R2'));
    rule07.addNewUnitClause('and', new UnitClause(rule07.namespace, 'forall', '$R1', 'Siblings', '$R2'));
    rules['rule07'] = rule07;

    // ==============================
    // Rule 08
    // E.g., <object id="p"><img name="p"></object>
    // ==============================
    let rule08 = new RootFormula(null, [new UnitClause(null, 'isRoot', '$R1')]);
    rule08.addNewUnitClause('and', new UnitClause(rule08.namespace, 'declareNode', '$R1'));
    rule08.addNewUnitClause('and', new UnitClause(rule08.namespace, 'declareNode', '$R2'));
    rule08.addNewUnitClause('and', new UnitClause(rule08.namespace, 'length(getChildren)', '$R1', '>=', '1'));

    // For the forall(getChildren(R1), CompoundClause) clause
    let branchClause08_1 = new CompoundClause('and', [
      new UnitClause(rule08.namespace, 'hasTagName', '$R1', 'object'),
      new UnitClause(rule08.namespace, 'hasAttribute', '$R1', 'id', '$P'),
      new CompoundClause('or', THEHULK_TNS2.map(tag => new UnitClause(rule08.namespace, 'hasTagName', '$R2', tag))),
      new UnitClause(rule08.namespace, 'hasAttribute', '$R2', 'name', '$P')
    ]);

    let branchClause08_2 = new CompoundClause('and', [
      new UnitClause(rule08.namespace, 'hasTagName', '$R1', 'object'),
      new UnitClause(rule08.namespace, 'hasAttribute', '$R1', 'id', '$P'),
      new UnitClause(rule08.namespace, 'hasTagName', '$R2', 'object'),
      new UnitClause(rule08.namespace, 'hasAttribute', '$R2', 'id', '$P')
    ]);

    rule08.addNewCompoundClause('and', new CompoundClause('or', [branchClause08_1, branchClause08_2]));
    rule08.addNewUnitClause('and', new UnitClause(rule08.namespace, 'hasChild', '$R1', '$R2'));
    rule08.addNewUnitClause('and', new UnitClause(rule08.namespace, 'forall', '$R1', 'Children', '$R2'));
    rules['rule08'] = rule08;

    return rules;
  }

  /**
   * Entry point for applying rules.
   * @param {String} operation 
   * @param {...any} args 
   * @returns 
   */
  apply(operation, ...args) {
    if (operation === 'getField') {
      return this.getFieldOp(...args);
    } else {
      return [];
    }
  }

  /**
   * Returns the virtual DOM element(s) for the given field that can achieve DOCUMENT2DOM objective.
   * @param {*} base 
   * @param {*} offset 
   * @returns {Object} List of root formulas that can be used to achieve DOCUMENT2DOM objective.
   */
  getFieldOp(base, offset) {
    if (base !== 'document') {
      return {};
    }
    return this.rules;
  }
}

export default DocumentToDOMRule;