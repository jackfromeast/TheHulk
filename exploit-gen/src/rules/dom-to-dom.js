import { ClauseBuilder, UnitClause, CompoundClause, RootFormula } from "../clause.js";
import { THEHULK_TNS3, THEHULK_TNS4 } from '../constants/thehulk-tag-set.js';

export class DOMToDOMRule {
  constructor() {
    this.rules = this.initializeRules();
  }

  /**
   * Initializes and returns all the rules.
   * @returns {Object} An object containing all the rules.
   */
  initializeRules() {
    const rules = {};

    // ==============================
    // Rule 09: FORM Parent-Child Rules (TNS3)
    // <form> with child from TNS3 and name=P
    // ==============================
    let rule09 = new RootFormula(null, [new UnitClause(null, 'isRoot', '$R1')]);
    rule09.addNewUnitClause('and', new UnitClause(rule09.namespace, 'declareNode', '$R1'));
    rule09.addNewUnitClause('and', new UnitClause(rule09.namespace, 'declareNode', '$R2'));
    rule09.addNewUnitClause('and', new UnitClause(rule09.namespace, 'hasChild', '$R1', '$R2'));
    rule09.addNewUnitClause('and', new UnitClause(rule09.namespace, 'hasTagName', '$R1', 'form'));
    rule09.addNewUnitClause('and', new CompoundClause('or', THEHULK_TNS3.map(tag => new UnitClause(rule09.namespace, 'hasTagName', '$R2', tag))));
    rule09.addNewUnitClause('and', new UnitClause(rule09.namespace, 'hasAttribute', '$R2', 'name', '$P'));
    rules['rule09'] = rule09;

    // ==============================
    // Rule 10: FORM Parent-Child Rules (TNS4)
    // <form> with child from TNS4 and id=P
    // ==============================
    let rule10 = new RootFormula(null, [new UnitClause(null, 'isRoot', '$R1')]);
    rule10.addNewUnitClause('and', new UnitClause(rule10.namespace, 'declareNode', '$R1'));
    rule10.addNewUnitClause('and', new UnitClause(rule10.namespace, 'declareNode', '$R2'));
    rule10.addNewUnitClause('and', new UnitClause(rule10.namespace, 'hasChild', '$R1', '$R2'));
    rule10.addNewUnitClause('and', new UnitClause(rule10.namespace, 'hasTagName', '$R1', 'form'));
    rule10.addNewUnitClause('and', new CompoundClause('or', THEHULK_TNS4.map(tag => new UnitClause(rule10.namespace, 'hasTagName', '$R2', tag))));
    rule10.addNewUnitClause('and', new UnitClause(rule10.namespace, 'hasAttribute', '$R2', 'id', '$P'));
    rules['rule10'] = rule10;

    // ==============================
    // Rule 11: FORM Parent-Child Rules with Input Element
    // <form id=X> with child <input form=X id=P>
    // ==============================
    let rule11 = new RootFormula(null, [new UnitClause(null, 'isRoot', '$R1')]);
    rule11.addNewUnitClause('and', new UnitClause(rule11.namespace, 'declareNode', '$R1'));
    rule11.addNewUnitClause('and', new UnitClause(rule11.namespace, 'declareNode', '$R2'));
    rule11.addNewUnitClause('and', new UnitClause(rule11.namespace, 'hasChild', '$R1', '$R2'));
    rule11.addNewUnitClause('and', new UnitClause(rule11.namespace, 'hasTagName', '$R1', 'form'));
    rule11.addNewUnitClause('and', new UnitClause(rule11.namespace, 'hasAttribute', '$R1', 'id', '$X'));
    rule11.addNewUnitClause('and', new UnitClause(rule11.namespace, 'hasTagName', '$R2', 'input'));
    rule11.addNewUnitClause('and', new UnitClause(rule11.namespace, 'hasAttribute', '$R2', 'form', '$X'));
    rule11.addNewUnitClause('and', new UnitClause(rule11.namespace, 'hasAttribute', '$R2', 'id', '$P'));
    rules['rule11'] = rule11;

    // ==============================
    // Rule 12: Nested Window Proxy Rules
    // <iframe> with nested <iframe> and id=P or name=P
    // ==============================
    let rule12 = new RootFormula(null, [new UnitClause(null, 'isRoot', '$R1')]);
    rule12.addNewUnitClause('and', new UnitClause(rule12.namespace, 'declareNode', '$R1'));
    rule12.addNewUnitClause('and', new UnitClause(rule12.namespace, 'declareNode', '$R2'));
    rule12.addNewUnitClause('and', new UnitClause(rule12.namespace, 'hasTagName', '$R1', 'iframe'));
    rule12.addNewUnitClause('and', new UnitClause(rule12.namespace, 'hasSrcDoc', '$R1', '$R2'));
    rule12.addNewUnitClause('and', new UnitClause(rule12.namespace, 'hasTagName', '$R2', 'iframe'));
    rule12.addNewCompoundClause('and', new CompoundClause('or', [
      new UnitClause(rule12.namespace, 'hasAttribute', '$R2', 'id', '$P'),
      new UnitClause(rule12.namespace, 'hasAttribute', '$R2', 'name', '$P')
    ]));
    rules['rule12'] = rule12;

    // ==============================
    // Rule 13: Nested Window Proxy Rules with Recursive Clobbering
    // <iframe> with nested <iframe> and recursive clobbering
    // ==============================
    let rule13 = new RootFormula(null, [new UnitClause(null, 'isRoot', '$R1')]);
    rule13.addNewUnitClause('and', new UnitClause(rule13.namespace, 'declareNode', '$R1'));
    rule13.addNewUnitClause('and', new UnitClause(rule13.namespace, 'declareNode', '$R2'));
    rule13.addNewUnitClause('and', new UnitClause(rule13.namespace, 'hasTagName', '$R1', 'iframe'));
    rule13.addNewUnitClause('and', new UnitClause(rule13.namespace, 'hasSrcDoc', '$R1', '$R2'));
    rule13.addNewCompoundClause('and', new CompoundClause('or', [
      new UnitClause(rule13.namespace, 'hasAttribute', '$R2', 'id', '$P'),
      new UnitClause(rule13.namespace, 'hasAttribute', '$R2', 'name', '$P')
    ]));
    rules['rule13'] = rule13;

    // ==============================
    // Rule 14: HTML Collection Rules (Siblings)
    // HTMLCollection with siblings where one has name=P and others have id=X
    // ==============================
    let rule14 = new RootFormula(null, [new UnitClause(null, 'isRoot', '$R1')]);
    rule14.addNewUnitClause('and', new UnitClause(rule14.namespace, 'declareNode', '$R1'));
    rule14.addNewUnitClause('and', new UnitClause(rule14.namespace, 'declareNode', '$R2'));
    rule14.addNewUnitClause('and', new UnitClause(rule14.namespace, 'length(getSiblings)', '$R1', '>=', '1'));
    rule14.addNewUnitClause('and', new UnitClause(rule14.namespace, 'include(getSiblings)', '$R1', '$R2'));

    let branchClause14_1 = new CompoundClause('and', [
      new UnitClause(rule14.namespace, 'not', '$R', '$R2'),
      new UnitClause(rule14.namespace, 'not', 'hasAttribute', '$R', 'id', '$P')
    ]);
    let branchClause14_2 = new CompoundClause('and', [
      new UnitClause(rule14.namespace, 'equals', '$R', '$R2'),
      new UnitClause(rule14.namespace, 'hasAttribute', '$R', 'name', '$P')
    ]);
    let branchClause14_3 = new CompoundClause('and', [
      new UnitClause(rule14.namespace, 'not', '$R', '$R2'),
      new UnitClause(rule14.namespace, 'not', 'hasAttribute', '$R', 'name', '$P')
    ]);
    let branchClause14_4 = new CompoundClause('and', [
      new UnitClause(rule14.namespace, 'equals', '$R', '$R2'),
      new UnitClause(rule14.namespace, 'hasAttribute', '$R', 'id', '$P')
    ]);

    rule14.addNewCompoundClause('and', new CompoundClause('or', [
      new CompoundClause('and', [branchClause14_1, branchClause14_2]),
      new CompoundClause('and', [branchClause14_3, branchClause14_4])
    ]));
    rules['rule14'] = rule14;

    // ==============================
    // Rule 15: HTML Collection Rules (Children)
    // HTMLCollection with children where one has name=P and others have id=X
    // ==============================
    let rule15 = new RootFormula(null, [new UnitClause(null, 'isRoot', '$R1')]);
    rule15.addNewUnitClause('and', new UnitClause(rule15.namespace, 'declareNode', '$R1'));
    rule15.addNewUnitClause('and', new UnitClause(rule15.namespace, 'declareNode', '$R2'));
    rule15.addNewUnitClause('and', new UnitClause(rule15.namespace, 'length(getChildren)', '$R1', '>=', '1'));
    rule15.addNewUnitClause('and', new UnitClause(rule15.namespace, 'include(getChildren)', '$R1', '$R2'));

    let branchClause15_1 = new CompoundClause('and', [
      new UnitClause(rule15.namespace, 'not', '$R', '$R2'),
      new UnitClause(rule15.namespace, 'not', 'hasAttribute', '$R', 'id', '$P')
    ]);
    let branchClause15_2 = new CompoundClause('and', [
      new UnitClause(rule15.namespace, 'equals', '$R', '$R2'),
      new UnitClause(rule15.namespace, 'hasAttribute', '$R', 'name', '$P')
    ]);
    let branchClause15_3 = new CompoundClause('and', [
      new UnitClause(rule15.namespace, 'not', '$R', '$R2'),
      new UnitClause(rule15.namespace, 'not', 'hasAttribute', '$R', 'name', '$P')
    ]);
    let branchClause15_4 = new CompoundClause('and', [
      new UnitClause(rule15.namespace, 'equals', '$R', '$R2'),
      new UnitClause(rule15.namespace, 'hasAttribute', '$R', 'id', '$P')
    ]);

    rule15.addNewCompoundClause('and', new CompoundClause('or', [
      new CompoundClause('and', [branchClause15_1, branchClause15_2]),
      new CompoundClause('and', [branchClause15_3, branchClause15_4])
    ]));
    rules['rule15'] = rule15;


    // ==============================
    // Rule 16: Sibling Rules
    // ==============================
    let rule16 = new RootFormula(null, [new UnitClause(null, 'isRoot', '$R1')]);
    rule16.addNewUnitClause('and', new UnitClause(rule16.namespace, 'declareNode', '$R1'));
    rule16.addNewUnitClause('and', new UnitClause(rule16.namespace, 'declareNode', '$R2'));
    rule16.addNewUnitClause('and', new UnitClause(rule16.namespace, 'hasSibling', '$R1', '$R2'));
    rule16.addNewUnitClause('and', new UnitClause(rule16.namespace, 'length(getSiblings)', '$R1', '>=', '1'));
    rules['rule16'] = rule16;

    return rules;
  }

  /**
   * Entry point for applying rules.
   * @param {String} operation 
   * @param {...any} args 
   * @returns 
   */
  apply(operation, ...args) {
    if (operation === 'getField') {
      return this.getFieldOp(...args);
    } else {
      return [];
    }
  }

  /**
   * Returns the virtual DOM element(s) for the given field that can achieve DOM2DOM objective.
   * @param {*} base 
   * @param {*} offset 
   * @returns {Object} List of root formulas that can be used to achieve DOM2DOM objective.
   */
  getFieldOp(base, offset) {
    return this.rules;
  }
}

export default DOMToDOMRule;