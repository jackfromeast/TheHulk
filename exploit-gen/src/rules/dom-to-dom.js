import { ClauseBuilder, UnitClause, CompoundClause, RootFormula } from "../clause.js";
import { THEHULK_TNS3, THEHULK_TNS4 } from '../constants/thehulk-tag-set.js';

export class DOMToDOM {
  /**
   * Entry point for applying rules.
   * @param {String} operation 
   * @param  {...any} args 
   * @returns 
   */
  static apply(operation, ...args) {
    if (operation === 'getField') {
      return DOMToDOM.getFieldOp(...args);
    } else {
      return [];
    }
  }

  /**
   * Returns the virtual DOM element(s) for the given field that can achieve DOM2DOM objective.
   * @param {*} base 
   * @param {*} offset 
   * @returns {Array<RootFormula>} List of root formulas that can be used to achieve DOM2DOM objective.
   */
  static getFieldOp(base, offset) {
    let allRules = [];
    if (base !== 'dom') {
      return allRules;
    }

    // ==============================
    // Rule 09: FORM Parent-Child Rules
    // ==============================
    let rule09 = new RootFormula(null, [new UnitClause(null, 'isRoot', 'R1')]);
    rule09.addNewUnitClause('and', new UnitClause(rule09.namespace, 'declareNode', 'R1'));
    rule09.addNewUnitClause('and', new UnitClause(rule09.namespace, 'declareNode', 'R2'));
    rule09.addNewUnitClause('and', new UnitClause(rule09.namespace, 'declareString', 'P'));
    rule09.addNewUnitClause('and', new UnitClause(rule09.namespace, 'hasTagName', 'R1', 'form'));
    rule09.addNewUnitClause('and', new UnitClause(rule09.namespace, 'hasChild', 'R1', 'R2'));
    rule09.addNewUnitClause('and', new CompoundClause(
      'or', THEHULK_TNS3.map(tag => new UnitClause(rule09.namespace, 'hasTagName', 'R2', tag))));
    rule09.addNewUnitClause('and', new UnitClause(rule09.namespace, 'hasAttribute', 'R2', 'name', 'P'));
    allRules.push(rule09);

    // ==============================
    // Rule 10: FORM Parent-Child Rules
    // ==============================
    let rule10 = new RootFormula(null, [new UnitClause(null, 'isRoot', 'R1')]);
    rule10.addNewUnitClause('and', new UnitClause(rule10.namespace, 'declareNode', 'R1'));
    rule10.addNewUnitClause('and', new UnitClause(rule10.namespace, 'declareNode', 'R2'));
    rule10.addNewUnitClause('and', new UnitClause(rule10.namespace, 'declareString', 'P'));
    rule10.addNewUnitClause('and', new UnitClause(rule10.namespace, 'hasTagName', 'R1', 'form'));
    rule10.addNewUnitClause('and', new UnitClause(rule10.namespace, 'hasChild', 'R1', 'R2'));
    rule10.addNewUnitClause('and', new CompoundClause('or', THEHULK_TNS4.map(tag => new UnitClause(rule10.namespace, 'hasTagName', 'R2', tag))));
    rule10.addNewUnitClause('and', new UnitClause(rule10.namespace, 'hasAttribute', 'R2', 'id', 'P'));
    allRules.push(rule10);

    // ==============================
    // Rule 11: FORM Parent-Child Rules with Input Element
    // ==============================
    let rule11 = new RootFormula(null, [new UnitClause(null, 'isRoot', 'R1')]);
    rule11.addNewUnitClause('and', new UnitClause(rule11.namespace, 'declareNode', 'R1'));
    rule11.addNewUnitClause('and', new UnitClause(rule11.namespace, 'declareNode', 'R2'));
    rule11.addNewUnitClause('and', new UnitClause(rule11.namespace, 'declareString', 'P'));
    rule11.addNewUnitClause('and', new UnitClause(rule11.namespace, 'declareString', 'X'));
    rule11.addNewUnitClause('and', new UnitClause(rule11.namespace, 'hasTagName', 'R1', 'form'));
    rule11.addNewUnitClause('and', new UnitClause(rule11.namespace, 'hasChild', 'R1', 'R2'));
    rule11.addNewUnitClause('and', new UnitClause(rule11.namespace, 'hasTagName', 'R2', 'input'));
    rule11.addNewUnitClause('and', new UnitClause(rule11.namespace, 'hasAttribute', 'R1', 'id', 'X'));
    rule11.addNewUnitClause('and', new UnitClause(rule11.namespace, 'hasAttribute', 'R2', 'form', 'X'));
    rule11.addNewUnitClause('and', new UnitClause(rule11.namespace, 'hasAttribute', 'R2', 'id', 'P'));
    allRules.push(rule11);

    // ==============================
    // Rule 12: Nested Window Proxy Rules
    // ==============================
    let rule12 = new RootFormula(null, [new UnitClause(null, 'isRoot', 'R1')]);
    rule12.addNewUnitClause('and', new UnitClause(rule12.namespace, 'declareNode', 'R1'));
    rule12.addNewUnitClause('and', new UnitClause(rule12.namespace, 'declareNode', 'R2'));
    rule12.addNewUnitClause('and', new UnitClause(rule12.namespace, 'declareString', 'P'));
    rule12.addNewUnitClause('and', new UnitClause(rule12.namespace, 'hasTagName', 'R1', 'iframe'));
    rule12.addNewUnitClause('and', new UnitClause(rule12.namespace, 'hasSrcDoc', 'R1', 'R2'));
    rule12.addNewUnitClause('and', new UnitClause(rule12.namespace, 'hasTagName', 'R2', 'iframe'));
    rule12.addNewCompoundClause('and', new CompoundClause('or', [
      new UnitClause(rule12.namespace, 'hasAttribute', 'R2', 'id', 'P'),
      new UnitClause(rule12.namespace, 'hasAttribute', 'R2', 'name', 'P')
    ]));
    allRules.push(rule12);

    // ==============================
    // Rule 13: Nested Window Proxy Rules with Recursive Clobbering
    // ==============================
    let rule13 = new RootFormula(null, [new UnitClause(null, 'isRoot', 'R1')]);
    rule13.addNewUnitClause('and', new UnitClause(rule13.namespace, 'declareNode', 'R1'));
    rule13.addNewUnitClause('and', new UnitClause(rule13.namespace, 'declareNode', 'R2'));
    rule13.addNewUnitClause('and', new UnitClause(rule13.namespace, 'declareString', 'P'));
    rule13.addNewUnitClause('and', new UnitClause(rule13.namespace, 'hasTagName', 'R1', 'iframe'));
    rule13.addNewUnitClause('and', new UnitClause(rule13.namespace, 'hasSrcDoc', 'R1', 'R2'));
    rule13.addNewCompoundClause('and', new CompoundClause('or', [
      new CompoundClause('and', [
        new CompoundClause('or', THEHULK_TNS1.map(tag => new UnitClause(rule13.namespace, 'hasTagName', 'R2', tag))),
        new UnitClause(rule01.namespace, 'hasAttribute', 'R1', 'id', 'P')
      ]),
      new CompoundClause('and', [
        new CompoundClause('or', THEHULK_TNS2.map(tag => new UnitClause(rule13.namespace, 'hasTagName', 'R2', tag))),
        new UnitClause(rule13.namespace, 'hasAttribute', 'R2', 'name', 'P')
      ])
    ]));
    allRules.push(rule13);

    // ==============================
    // Rule 14: HTML Collection Rules (Siblings)
    // ==============================
    let rule14 = new RootFormula(null, [new UnitClause(null, 'isRoot', 'R1')]);
    rule14.addNewUnitClause('and', new UnitClause(rule14.namespace, 'declareNode', 'R1'));
    rule14.addNewUnitClause('and', new UnitClause(rule14.namespace, 'declareNode', 'R2'));
    rule14.addNewUnitClause('and', new UnitClause(rule14.namespace, 'declareString', 'P'));
    rule14.addNewUnitClause('and', new UnitClause(rule14.namespace, 'length', 'getSiblings(R1)', '>=', '1'));
    rule14.addNewUnitClause('and', new UnitClause(rule14.namespace, 'hasSibling', 'R1', 'R2'));
    rule14.addNewCompoundClause('and', new CompoundClause('or', [
      new CompoundClause('and', [
        new UnitClause(rule14.namespace, 'not', 'R', 'R2'),
        new UnitClause(rule14.namespace, 'not', 'hasAttribute', 'R', 'id', 'P')
      ]),
      new CompoundClause('and', [
        new UnitClause(rule14.namespace, 'R', 'R2'),
        new UnitClause(rule14.namespace, 'hasAttribute', 'R2', 'name', 'P')
      ]),
      new CompoundClause('and', [
        new UnitClause(rule14.namespace, 'not', 'R', 'R2'),
        new UnitClause(rule14.namespace, 'not', 'hasAttribute', 'R', 'name', 'P')
      ]),
      new CompoundClause('and', [
        new UnitClause(rule14.namespace, 'R', 'R2'),
        new UnitClause(rule14.namespace, 'hasAttribute', 'R2', 'id', 'P')
      ])
    ]));
    allRules.push(rule14);

    // ==============================
    // Rule 15: HTML Collection Rules (Children)
    // ==============================
    let rule15 = new RootFormula(null, [new UnitClause(null, 'isRoot', 'R1')]);
    rule15.addNewUnitClause('and', new UnitClause(rule15.namespace, 'declareNode', 'R1'));
    rule15.addNewUnitClause('and', new UnitClause(rule15.namespace, 'declareNode', 'R2'));
    rule15.addNewUnitClause('and', new UnitClause(rule15.namespace, 'declareString', 'P'));
    rule15.addNewUnitClause('and', new UnitClause(rule15.namespace, 'length', 'getChildren(R1)', '>=', '1'));
    rule15.addNewUnitClause('and', new UnitClause(rule15.namespace, 'hasSibling', 'R1', 'R2'));
    rule15.addNewCompoundClause('and', new CompoundClause('or', [
      new CompoundClause('and', [
        new UnitClause(rule15.namespace, 'not', 'R', 'R2'),
        new UnitClause(rule15.namespace, 'not', 'hasAttribute', 'R', 'id', 'P')
      ]),
      new CompoundClause('and', [
        new UnitClause(rule15.namespace, 'R', 'R2'),
        new UnitClause(rule15.namespace, 'hasAttribute', 'R2', 'name', 'P')
      ]),
      new CompoundClause('and', [
        new UnitClause(rule15.namespace, 'not', 'R', 'R2'),
        new UnitClause(rule15.namespace, 'not', 'hasAttribute', 'R', 'name', 'P')
      ]),
      new CompoundClause('and', [
        new UnitClause(rule15.namespace, 'R', 'R2'),
        new UnitClause(rule15.namespace, 'hasAttribute', 'R2', 'id', 'P')
      ])
    ]));
    allRules.push(rule15);

    return allRules;
  }
}

export default DOMToDOM;