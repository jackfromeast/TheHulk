import { RootFormula, UnitClause, CompoundClause } from '../clause.js';
import { THEHULK_TNS1, THEHULK_TNS2, THEHULK_TNS3, THEHULK_TNS4 } from "../constants/thehulk-tag-set.js"

export class DOMToStringRule {
  constructor() {
    this.rules = {
      ...this.initializeInvokeFuncRules(),
      ...this.initializeGetFieldRules(),
      ...this.initializeBinaryOpRules(),
    };
  }

  /**
   * Initializes and returns the rules for function invocations.
   * @returns {Object} An object containing the rules for function invocations.
   */
  initializeInvokeFuncRules() {
    const rules = {};

    // Rule 17: invokeFunc - <a> or <area> with href attribute
    let rule17 = new RootFormula(null, [new UnitClause(null, 'isRoot', '$R1')]);
    rule17.addNewUnitClause('and', new UnitClause(rule17.namespace, 'declareNode', '$R1'));
    rule17.addNewUnitClause('and', new CompoundClause('or', [
      new UnitClause(rule17.namespace, 'hasTagName', '$R1', 'a'),
      new UnitClause(rule17.namespace, 'hasTagName', '$R1', 'area')
    ]));
    rule17.addNewUnitClause('and', new UnitClause(rule17.namespace, 'hasAttribute', '$R1', 'href', '$Payload'));
    rules['rule17'] = rule17;

    // Rule 18: invokeFunc - getAttribute or getAttributeNS
    let rule18 = new RootFormula(null, [new UnitClause(null, 'isRoot', '$R1')]);
    rule18.addNewUnitClause('and', new UnitClause(rule18.namespace, 'declareNode', '$R1'));
    rule18.addNewUnitClause('and', new UnitClause(rule18.namespace, 'declareString', '$P'));
    rule18.addNewUnitClause('and', new UnitClause(rule18.namespace, 'declareString', '$NS'));
    rule18.addNewCompoundClause('and', new CompoundClause('or', [
      new UnitClause(rule18.namespace, 'hasAttribute', '$R1', '$P', '$Payload'),
      new UnitClause(rule18.namespace, 'hasAttribute', '$R1', '$NS:$P', '$Payload')
    ]));
    rules['rule18'] = rule18;

    // Rule 19: invokeFunc - getAttributeNames
    let rule19 = new RootFormula(null, [new UnitClause(null, 'isRoot', '$R1')]);
    rule19.addNewUnitClause('and', new UnitClause(rule19.namespace, 'declareNode', '$R1'));
    rule19.addNewUnitClause('and', new UnitClause(rule19.namespace, 'hasAttribute', '$R1', '$Payload', '*'));
    rules['rule19'] = rule19;

    return rules;
  }

  /**
   * Initializes and returns the rules for field access.
   * @returns {Object} An object containing the rules for field access.
   */
  initializeGetFieldRules() {
    const rules = {};

    // Rule 20: getField - Base object with attribute P
    let rule20 = new RootFormula(null, [new UnitClause(null, 'isRoot', '$R1')]);
    rule20.addNewUnitClause('and', new UnitClause(rule20.namespace, 'declareNode', '$R1'));
    rule20.addNewUnitClause('and', new UnitClause(rule20.namespace, 'declareString', '$P'));
    rule20.addNewUnitClause('and', new UnitClause(rule20.namespace, 'declareConstantString', '$Payload', '$Payload'));
    rule20.addNewUnitClause('and', 
      new CompoundClause('or', [
        ...THEHULK_TNS1.map((tag) => {return new UnitClause(rule20.namespace, 'hasTagName', '$R1', tag)}),
        ...THEHULK_TNS2.map((tag) => {return new UnitClause(rule20.namespace, 'hasTagName', '$R1', tag)}),
        ...THEHULK_TNS3.map((tag) => {return new UnitClause(rule20.namespace, 'hasTagName', '$R1', tag)}),
        ...THEHULK_TNS4.map((tag) => {return new UnitClause(rule20.namespace, 'hasTagName', '$R1', tag)})
      ])
    );
    rule20.addNewUnitClause('and', new UnitClause(rule20.namespace, 'hasAttribute', '$R1', '$P', '$Payload'));
    rules['rule20'] = rule20;

    // Rule 21: getField - Base object with data-* attribute
    let rule21 = new RootFormula(null, [new UnitClause(null, 'isRoot', '$R1')]);
    rule21.addNewUnitClause('and', new UnitClause(rule21.namespace, 'declareNode', '$R1'));
    rule21.addNewUnitClause('and', new UnitClause(rule21.namespace, 'hasAttribute', '$R1', 'data-*', '$Payload'));
    rules['rule21'] = rule21;

    return rules;
  }

  /**
   * Initializes and returns the rules for binary operations.
   * @returns {Object} An object containing the rules for binary operations.
   */
  initializeBinaryOpRules() {
    const rules = {};

    // Rule 22: binaryOp - Binary + operation with <a> or <area> and href attribute
    let rule22 = new RootFormula(null, [new UnitClause(null, 'isRoot', '$R1')]);
    rule22.addNewUnitClause('and', new UnitClause(rule22.namespace, 'declareNode', '$R1'));
    rule22.addNewUnitClause('and', new CompoundClause('or', [
      new UnitClause(rule22.namespace, 'hasTagName', '$R1', 'a'),
      new UnitClause(rule22.namespace, 'hasTagName', '$R1', 'area')
    ]));
    rule22.addNewUnitClause('and', new UnitClause(rule22.namespace, 'hasAttribute', '$R1', 'href', '$Payload'));
    rules['rule22'] = rule22;

    return rules;
  }

  /**
   * Entry point for applying rules.
   * @param {String} operation 
   * @param {...any} args 
   * @returns 
   */
  apply(operation, ...args) {
    if (operation === 'getField') {
      return this.getFieldOp(...args);
    } else if (operation === 'invokeFunc') {
      return this.invokeFuncOp(...args);
    } else if (operation === 'binaryOp') {
      return this.binaryOp(...args);
    } else {
      return [];
    }
  }

  /**
   * Returns the virtual DOM element(s) for the given function invocation that can achieve DOM-to-String objective.
   * @param {*} base 
   * @param {*} offset 
   * @param {*} funcName 
   * @param {...any} args 
   * @returns {Object} List of root formulas that can be used to achieve DOM-to-String objective.
   */
  invokeFuncOp(base, offset, funcName, ...args) {
    return this.rules.invokeFunc;
  }

  /**
   * Returns the virtual DOM element(s) for the given field that can achieve DOM-to-String objective.
   * @param {*} base 
   * @param {*} offset 
   * @returns {Object} List of root formulas that can be used to achieve DOM-to-String objective.
   */
  getFieldOp(base, offset) {
    return this.rules.getField;
  }

  /**
   * Returns the virtual DOM element(s) for the given binary operation that can achieve DOM-to-String objective.
   * @param {*} base 
   * @param {*} offset 
   * @param {*} op 
   * @param {...any} args 
   * @returns {Object} List of root formulas that can be used to achieve DOM-to-String objective.
   */
  binaryOp(base, offset, op, ...args) {
    return this.rules.binaryOp;
  }
}

export default DOMToStringRule;