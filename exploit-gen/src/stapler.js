import { SymbolicDOMNode } from './symdom-node.js';
import { SymbolicDOMTree } from './symdom-tree.js';

/**
 * Staplar class
 * 
 * Given the two symbolic DOM tree, the stapler helps to staple the nodeId1 of symbolicDOMT1 to nodeId2 of symbolicDOMT2 together.
 * It will generate a new symbolic DOM tree that represents the stapled DOM Tree.
 * 
 * We assume that nodeId2 is the root node of symbolicDOMT2.
 * 
 * @param {SymbolicDOMTree} symbolicDOMT1 - symbolic DOM of the first transaction
 * @param {SymbolicDOMTree} symbolicDOMT2 - symbolic DOM of the second transaction
 * @param {String} nodeId1 - node ID of the symbolicDOMT1
 * @param {String} nodeId2 - node ID of the symbolicDOMT2
 */
export class Staplar {
  constructor(symbolicDOMT1, symbolicDOMT2, nodeId1, nodeId2) {
    this.symbolicDOMT1 = symbolicDOMT1;
    this.symbolicDOMT2 = symbolicDOMT2;
    this.nodeId1 = nodeId1;
    this.nodeId2 = nodeId2;

    // {SymbolName in symbolicDOMT2: SymbolName in symbolicDOMT1}
    this.symbolMapping = {};
  }

  /**
   * Staple the two symbolic DOM trees together.
   * 
   * 1/ Merge the constraints of nodeId1 and nodeId2 in the two symbolic DOM trees.
   * 2/ Propagate the string symbol constraints from the two symbolic DOM trees.
   * 3/ Generate the new symbolic DOM tree where nodeId1 and nodeId2 are stapled together.
   * 
   * E.g.,
   * op1: getField('document', 'x') => [SymbolicDOMTree1]
   * let symbolicNode1 = new SymbolicDOMTree();
   * symbolicNode2.declareNode('$node1');
   * symbolicNode2.addConstraint('isRoot', '$node1');
   * symbolicNode2.addConstraint('hasAttribute', '$node1', 'name', 'x');
   * symbolicNode2.addConstraint('hasTagName', '$node1', 'form');
   * 
   * OP2: getField(SymbolicDOMTree1, 'y') => [SymbolicDOMTree2]
   * let symbolicNode2 = new SymbolicDOMTree();
   * symbolicNode2.declareNode('$node1');
   * symbolicNode2.declareNode('$node2');
   * symbolicNode2.addConstraint('isRoot', '$node1');
   * symbolicNode2.addConstraint('hasChild', '$node1', '$node2');
   * symbolicNode2.addConstraint('hasTagName', '$node1', 'form');
   * symbolicNode2.addConstraint('hasTagName', '$node2', 'iframe');
   * symbolicNode2.addConstraint('hasAttribute', '$node2', 'id', 'y');
   * symbolicNode2.addConstraint('hasAttribute', '$node2', 'name', 'y');
   * 
   * Add we want staple the two symbolic DOM trees that $node1 in SymbolicDOMTree1 is stapled to $node1 in SymbolicDOMTree2.
   * stapledSymbolicNode = new SymbolicDOMTree();
   * stapledSymbolicNode.declareNode('$node1');
   * stapledSymbolicNode.declareNode('$node2');
   * stapledSymbolicNode.addConstraint('isRoot', '$node1');
   * stapledSymbolicNode.addConstraint('hasChild', '$node1', '$node2');
   * stapledSymbolicNode.addConstraint('hasTagName', '$node1', 'form');
   * stapledSymbolicNode.addConstraint('hasTagName', '$node2', 'iframe');
   * stapledSymbolicNode.addConstraint('hasAttribute', '$node1', 'name', 'x');
   * stapledSymbolicNode.addConstraint('hasAttribute', '$node2', 'id', 'y');
   * stapledSymbolicNode.addConstraint('hasAttribute', '$node2', 'name', 'y');
   * 
   * @returns {SymbolicDOMTree} The stapled symbolic DOM tree.
   */
  staple() {
    // this.symbolicDOMT2 should be the attached symbolic DOM tree, and we update the this.symbolicDOMT1 directly.
    const node1 = this.symbolicDOMT1.DOMSymbols[this.nodeId1];
    const node2 = this.symbolicDOMT2.DOMSymbols[this.nodeId2];
    
    if (!node1 || !node2) {
      throw new Error("One or both of the nodes to staple do not exist.");
    }

    this.symbolMapping = this.resolveSymbolConflicts();
    
    // Merge the type constraints of the two nodes to stapledDOMTree[this.nodeId1] first
    const sharedNodeTypes = new Set(node1.nodeTypes.filter(x => node2.nodeTypes.includes(x)));
    if (sharedNodeTypes.size === 0) {
      if (node1.nodeTypes[0] !== '*' && node2.nodeTypes[0] !== '*') {
        throw new Error("No overlapping node types. Stapling failed.");
      } else if (node1.nodeTypes[0] === '*') {
        sharedNodeTypes.add(...node2.nodeTypes);
      } else {
        sharedNodeTypes.add(...node1.nodeTypes);
      }
    }
    node1.resetTypes(Array.from(sharedNodeTypes));

    // Merge the attributes of the two nodes
    const mergedAttributes = this.mergeAttributes(node1, node2);
    node1.resetAttributes(mergedAttributes);
    node2.attributeOR.forEach((attrPair) => {
      node1.setAttributeOR(attrPair);
    });

    // Add the sibling and child nodes of node2 to node1
    this.mergeChildrenAndSiblings(node1, node2);

    // Add the constraints of node2 (which is the root) to node1
    // Need to rename the node2's symbol if it is already used in node1
    this.propagateConstraints(node1, node2);

    return this.symbolicDOMT1;
  }

  /**
   * Merge attributes from node1 and node2.
   * If the attribute of one node's value is a string symbol, and the other node's value is a fixed, then, replace the string symbol with the fixed string.
   * If the attribute of both nodes's value are fixed string, then raise the failed stapling error if the values are different.
   * If the attribute of both nodes's value are string symbols, then, merge the two string symbols to one string symbol.
   * 
   * @param {SymbolicDOMNode} node1 - The node from symbolicDOMT1.
   * @param {SymbolicDOMNode} node2 - The node from symbolicDOMT2.
   * @param {SymbolicDOMTree} stapledDOMTree - The new stapled symbolic DOM tree.
   * @returns {Object} Merged attributes.
   */
  mergeAttributes(node1, node2) {
    const mergedAttributes = {};

    const mergeAttributeValue = (attr, value1, value2) => {
      const isSymbol1 = typeof value1 === 'string' && value1.startsWith('$') && this.symbolicDOMT1.stringSymbols[value1];
      const isSymbol2 = typeof value2 === 'string' && value2.startsWith('$') && this.symbolicDOMT2.stringSymbols[value2];

      if (isSymbol1 && isSymbol2) {
        // Merge two string symbols into one (can choose one or create a new symbol)
        return value1;
      } else if (isSymbol1) {
        this.symbolicDOMT1.stringSymbols[value1] = value2;
        return value2;
      } else if (isSymbol2) {
        this.symbolicDOMT2.stringSymbols[value2] = value1;
        return value1;
      } else if (value1 === value2) {
        return value1;
      } else {
        throw new Error(`Conflict in attribute ${attr}: ${value1} vs ${value2}. Stapling failed.`);
      }
    };

    for (const [attr, value1] of Object.entries(node1.attributes)) {
      if (node2.attributes.hasOwnProperty(attr)) {
        mergedAttributes[attr] = mergeAttributeValue(attr, value1, node2.attributes[attr]);
      } else {
        mergedAttributes[attr] = value1;
      }
    }

    for (const [attr, value2] of Object.entries(node2.attributes)) {
      if (!mergedAttributes.hasOwnProperty(attr)) {
        mergedAttributes[attr] = value2;
      }
    }

    return mergedAttributes;
  }

  /**
   * Merge the children and siblings of node2 into node1.
   * 
   * @param {SymbolicDOMNode} node1 - The node from symbolicDOMT1.
   * @param {SymbolicDOMNode} node2 - The node from symbolicDOMT2.
   */
  mergeChildrenAndSiblings(node1, node2) {
    node1.children = [...node1.children, ...node2.children];

    if (this.symbolicDOMT2.topLevelSiblingNodes) {
      this.symbolicDOMT2.topLevelSiblingNodes.forEach((siblingNode) => {
        if (!node1.isRoot) {
          node1.parent.children.push(siblingNode);
        } else {
          this.symbolicDOMT1.topLevelSiblingNodes.push(siblingNode);
        }
      });
    }
  }

  /**
   * Propagate constraints from node2 to node1.
   */
  propagateConstraints() {
    if (!this.symbolicDOMT1 || !this.symbolicDOMT2) {
      throw new Error("Both symbolicDOMT1 and symbolicDOMT2 must be defined.");
    }
  
    const updatedConstraints = this.symbolicDOMT2.constraints
      .map(([command, ...args]) => {
        const updatedArgs = args.map(arg => {
          if (arg === this.nodeId2) {
            return this.nodeId1;
          } else if (this.symbolMapping[arg]) {
            return symbolMapping[arg];
          }
          return arg;
        });
  
        if (command === 'isRoot' || command === 'declareNode' || command === 'declareString' || command === 'declare') {
          return null; 
        }

        // For other constraints, we check if the constraint is already in symbolicDOMT1
        // If it is, we merge the constraints
        const existingConstraint = this.symbolicDOMT1.constraints.find(([cmd, ...rest]) => {
          return cmd === command && rest.every((arg, i) => arg === updatedArgs[i]);
        }); 
        if (existingConstraint) {
          return null; 
        }
  
        // Return the updated constraint
        return [command, ...updatedArgs];
      })
      .filter(constraint => constraint !== null);
  
    for (const constraint of updatedConstraints) {
      this.symbolicDOMT1.addConstraint(...constraint);
    }
  }

  /**
   * Resolve conflicts in DOMSymbols and stringSymbols between symbolicDOMT1 and symbolicDOMT2.
   * @returns {Object} A mapping of old symbol names to new (renamed) symbols.
   */
  resolveSymbolConflicts() {
    const symbolMapping = {};

    // Handle DOMSymbols conflicts
    for (let [key, value] of Object.entries(this.symbolicDOMT2.DOMSymbols)) {
      if (this.symbolicDOMT1.DOMSymbols[key] && key == this.nodeId2) {
        symbolMapping[key] = this.nodeId1;
      } else if (this.symbolicDOMT1.DOMSymbols[key]) {
        const newKey = `${key}_stapled`;
        symbolMapping[key] = newKey;
        this.symbolicDOMT1.DOMSymbols[newKey] = value;
      } else {
        this.symbolicDOMT1.DOMSymbols[key] = value;
      }
    }

    // Handle stringSymbols conflicts
    for (let [key, value] of Object.entries(this.symbolicDOMT2.stringSymbols)) {
      if (this.symbolicDOMT1.stringSymbols[key]) {
        const newKey = `${key}_stapled`;
        symbolMapping[key] = newKey;
        this.symbolicDOMT1.stringSymbols[newKey] = value;
      } else {
        this.symbolicDOMT1.stringSymbols[key] = value;
      }
    }

    return symbolMapping;
  }
}


let symbolicNode1 = new SymbolicDOMTree();
// symbolicNode1.declareNode('$node1');
// symbolicNode1.addConstraint('isRoot', '$node1');
// symbolicNode1.addConstraint('hasAttribute', '$node1', 'name', 'x');
// symbolicNode1.addConstraint('hasTagName', '$node1', 'form');
// symbolicNode1.declareNode('$node1');
// symbolicNode1.declareNode('$node2');
// symbolicNode1.addConstraint('isRoot', '$node1');
// symbolicNode1.addConstraint('hasSibling', '$node1', '$node2');
// symbolicNode1.addConstraint('hasTagName', '$node1', 'form');
// symbolicNode1.addConstraint('hasTagName', '$node2', 'y');
// symbolicNode1.addConstraint('hasAttribute', '$node2', 'data-x', 'y'); 
// symbolicNode1.addConstraint('hasAttribute', '$node2', 'data-z', 'y');
// symbolicNode1.addConstraint('bind', '$node1', '$1');
// symbolicNode1.addConstraint('setAttributeOR', '$node2', ["a", "b"]); 

let symbolicNode2 = new SymbolicDOMTree();
// symbolicNode2.declareNode('$node1');
// symbolicNode2.declareNode('$node2');
// symbolicNode2.addConstraint('isRoot', '$node1');
// symbolicNode2.addConstraint('hasSibling', '$node1', '$node2');
// symbolicNode2.addConstraint('hasTagName', '$node1', 'form');
// symbolicNode2.addConstraint('hasTagName', '$node2', 'iframe');
// symbolicNode2.addConstraint('hasAttribute', '$node2', 'id', 'y'); 
// symbolicNode2.addConstraint('hasAttribute', '$node2', 'name', 'y');
// symbolicNode2.addConstraint('bind', '$node1', '$1');
// symbolicNode2.addConstraint('setAttributeOR', '$node2', ["id", "name"]);  

// let stapler = new Staplar(symbolicNode1, symbolicNode2, '$node1', '$node1');
// let stapledSymbolicNode = stapler.staple();

// console.log(stapledSymbolicNode.concreteToString());