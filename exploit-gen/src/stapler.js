import { SymbolicDOMNode } from './symdom-node.js';
import { SymbolicDOMTree } from './symdom-tree.js';

/**
 * Staplar class
 * 
 * Given the two symbolic DOM tree, the stapler helps to staple the nodeId1 of symbolicDOMT1 to nodeId2 of symbolicDOMT2 together.
 * It will generate a new symbolic DOM tree that represents the stapled DOM Tree.
 * 
 * We assume that nodeId2 is the root node of symbolicDOMT2.
 * 
 * @param {SymbolicDOMTree} symbolicDOMT1 - symbolic DOM of the first transaction
 * @param {SymbolicDOMTree} symbolicDOMT2 - symbolic DOM of the second transaction
 * @param {Array<Array<nodeId1, nodeId2>>} staplePairs - The pairs of node IDs to staple together.
 */
export class Staplar {
  constructor(symbolicDOMT1, symbolicDOMT2, staplePairs) {
    this.readOnlySymbolicDOMT1 = symbolicDOMT1;
    this.readOnlySymbolicDOMT2 = symbolicDOMT2;
    this.readOnlyStaplePairs = staplePairs;

    this.symbolicDOMT1 = null;
    this.symbolicDOMT2 = null;
    this.staplePairs = [];
    this.symbolMapping = {};
  }

  /**
   * One of the nodeIds of symbolicDOMT2 in staplePairs should be the root node.
   */
  sanityCheck() {
    if (!this.symbolicDOMT1 || !this.symbolicDOMT2) {
      throw new Error("Both symbolicDOMT1 and symbolicDOMT2 must be defined.");
    }

    if (!this.staplePairs || this.staplePairs.length === 0) {
      throw new Error("staplePairs must be defined.");
    }

    if (!this.staplePairs.some(([nodeId1, nodeId2]) => nodeId2 === this.symbolicDOMT2.rootNodeId)) {
      throw new Error("One of the nodeIds of symbolicDOMT2 in staplePairs should be the root node.");
    } 
  }

  refresh() {
    this.symbolicDOMT1 = this.readOnlySymbolicDOMT1.clone();
    this.symbolicDOMT2 = this.readOnlySymbolicDOMT2.clone();
    this.staplePairs = this.readOnlyStaplePairs;
    this.symbolMapping = {};

    this.sanityCheck();
  }


  static getIdentifierFromNode(node, symbolicDOM) {
    return Object.keys(symbolicDOM.DOMSymbols).find(key => symbolicDOM.DOMSymbols[key] === node);
  }

  /**
   * Try the best to generate the possible staple pairs.
   * Based on the this.readOnly-* fields, generate the possible staple pairs.
   * @returns {Array<Array<[nodeId1, nodeId2]>>} The possible staple pairs.
   */
  generatePossibleStaplePairs() {
    const possiblePairs = [];
  
    // Helper function to get the identifier from a node
    function getIdentifierFromNode(node, symbolicDOM) {
      return Object.keys(symbolicDOM.DOMSymbols).find(key => symbolicDOM.DOMSymbols[key] === node);
    }
  
    // Helper function to check if a pair already exists in possiblePairs
    function isPairUnique(pair) {
      const pairString = JSON.stringify(pair);
      return !possiblePairs.some(existingPair => JSON.stringify(existingPair) === pairString);
    }
    
    // Try to staple the top siblings of the T2 to the sibiling of corresponding node in T1
    // Find the main pair
    const mainPair = this.readOnlyStaplePairs.find(([nodeId1, nodeId2]) => nodeId2 === this.readOnlySymbolicDOMT2.rootNodeId);
    if (!mainPair) {
      throw new Error("The root node of symbolicDOMT2 must be in the staplePairs.");
    }
    possiblePairs.push([mainPair]);
    const [mainNodeId1, mainNodeId2] = mainPair;
    const mainNode1 = this.readOnlySymbolicDOMT1.DOMSymbols[mainNodeId1];
    const mainNode2 = this.readOnlySymbolicDOMT2.DOMSymbols[mainNodeId2];

    let siblingNodes1 = [];
    let siblingNodes2 = [];
    if (mainNode1.isRoot) {
      siblingNodes1 = this.readOnlySymbolicDOMT1.topLevelSiblingNodes;
    } else {
      siblingNodes1 = mainNode1.parent?.children ? mainNode1.parent.children : [];
    }

    siblingNodes2 = this.readOnlySymbolicDOMT2.topLevelSiblingNodes;

    for (const siblingNode2 of siblingNodes2) {
      const siblingNodeId2 = getIdentifierFromNode(siblingNode2, this.readOnlySymbolicDOMT2);
      for (const siblingNode1 of siblingNodes1) {
        const siblingNodeId1 = getIdentifierFromNode(siblingNode1, this.readOnlySymbolicDOMT1);
        if (isPairUnique([siblingNodeId1, siblingNodeId2])) {
          possiblePairs.push([mainPair, [siblingNodeId1, siblingNodeId2]]);
        }
      }
    }

    // Sort the possible pairs by the number of nodes in the pair
    possiblePairs.sort((pair1, pair2) => {
      return pair2.length - pair1.length;
    });
    
    return possiblePairs;
  }

  /**
   * Try to staple the two symbolic DOM trees together.
   * @returns 
   */
  staple(){
    const possiblePairs = this.generatePossibleStaplePairs();
    // const possiblePairs = [this.readOnlyStaplePairs]
    for (const pair of possiblePairs) {
      this.refresh();
      this.staplePairs = pair;
      const result = this.tryStaple();
      if (result) {
        return result;
      }
    }
    return null;
  }

  /**
   * Staple the two symbolic DOM trees together.
   * 
   * Strategy: 
   * Try to best to merge the symbolicDOMT2 to an subtree of symbolicDOMT1.
   * E.g., If symbolicDOMT1 has nodes R1 (Root), R2, and symbolicDOMT2 has nodes R1 (Root), R2, 
   * and staplePairs = [[R1, R1]], then there are actually two possible outputs:
   * 1. Return symbolicDOMT1 has three nodes R1 (Root, merged from R1-T2 and R1-T1), R2 (from R1-T2), and R2' (from R2-T2).
   * 2. Return symbolicDOMT1 has two nodes R1 (Root, merged from R1-T2 and R1-T1), R2 (Merged from R2-T2 and R2-T1).
   * 
   * In our implementation, we will first try to merge the nodes as much as possible, if failed, we will create new nodes.
   * 
   * @returns {SymbolicDOMTree} The stapled symbolic DOM tree.
   */
  tryStaple() {
    try {
      this.symbolMapping = this.resolveSymbolConflicts();

      for (const [nodeId1, nodeId2] of this.staplePairs) {
        const node1 = this.symbolicDOMT1.DOMSymbols[nodeId1];
        const node2 = this.symbolicDOMT2.DOMSymbols[nodeId2];

        if (!node1 || !node2) {
          throw new Error("One or both of the nodes to staple do not exist.");
        }

        this.mergeNodeTypes(node1, node2);
        this.mergeAttributes(node1, node2);
        this.mergeChildren(node1, node2);

        if (node2.isRoot) {
          this.mergeTopSiblings(node1, node2);
        }
      }

      this.propagateConstraints();
  
      return this.symbolicDOMT1;
    }
    catch (e) {
      return null;
    }
  }

  mergeNodeTypes(node1, node2) {
    const sharedNodeTypes = new Set(node1.nodeTypes.filter(x => node2.nodeTypes.includes(x)));
    if (sharedNodeTypes.size === 0) {
      if (node1.nodeTypes[0] !== '*' && node2.nodeTypes[0] !== '*') {
        throw new Error("No overlapping node types. Stapling failed.");
      } else if (node1.nodeTypes[0] === '*') {
        sharedNodeTypes.add(...node2.nodeTypes);
      } else {
        sharedNodeTypes.add(...node1.nodeTypes);
      }
    }
    node1.resetTypes(Array.from(sharedNodeTypes));
  }

  /**
   * Return ture if node2 is a subset of node1 regarding the attributes and node types.
   * 
   * For example, 
   * if node1 has nodeTypes a, and node2 has nodeTypes b, then node2 is not a subset of node1.
   * if node1 has attribute a=x, and node2 has attribute a=x, then node2 is a subset of node1.
   * if node1 has attribute a=x, and node2 has attribute a=x, b=y, then node2 is not a subset of node1.
   * @param {*} node1 
   * @param {*} node2 
   * @returns 
   */
  checkOverlap(node1, node2) {
    if (node1.nodeTypes[0] === '*') {
      node1.nodeTypes = node2.nodeTypes;
    } else if (node2.nodeTypes[0] === '*') { ; } // Do nothing 
    else {
      const sharedNodeTypes = new Set(node1.nodeTypes.filter(x => node2.nodeTypes.includes(x)));
      if (sharedNodeTypes.size === 0) {
        return false;
      }
    }

    for (const [attr, value] of Object.entries(node2.attributes)) {
      if (node1.attributes[attr] !== value) {
        return false;
      }
    }

    return true;
  }

  /**
   * Merge attributes from node1 and node2.
   * If the attribute of one node's value is a string symbol, and the other node's value is a fixed, then, replace the string symbol with the fixed string.
   * If the attribute of both nodes's value are fixed string, then raise the failed stapling error if the values are different.
   * If the attribute of both nodes's value are string symbols, then, merge the two string symbols to one string symbol.
   * 
   * @param {SymbolicDOMNode} node1 - The node from symbolicDOMT1.
   * @param {SymbolicDOMNode} node2 - The node from symbolicDOMT2.
   * @param {SymbolicDOMTree} stapledDOMTree - The new stapled symbolic DOM tree.
   * @returns {Object} Merged attributes.
   */
  mergeAttributes(node1, node2) {
    const mergedAttributes = {};

    const mergeAttributeValue = (attr, value1, value2) => {
      const isSymbol1 = typeof value1 === 'string' && value1.startsWith('$') && this.symbolicDOMT1.stringSymbols[value1];
      const isSymbol2 = typeof value2 === 'string' && value2.startsWith('$') && this.symbolicDOMT2.stringSymbols[value2];

      if (isSymbol1 && isSymbol2) {
        // Merge two string symbols into one (can choose one or create a new symbol)
        return value1;
      } else if (isSymbol1) {
        this.symbolicDOMT1.stringSymbols[value1] = value2;
        return value2;
      } else if (isSymbol2) {
        this.symbolicDOMT2.stringSymbols[value2] = value1;
        return value1;
      } else if (value1 === value2) {
        return value1;
      } else {
        throw new Error(`Conflict in attribute ${attr}: ${value1} vs ${value2}. Stapling failed.`);
      }
    };

    for (const [attr, value1] of Object.entries(node1.attributes)) {
      if (node2.attributes.hasOwnProperty(attr)) {
        mergedAttributes[attr] = mergeAttributeValue(attr, value1, node2.attributes[attr]);
      } else {
        mergedAttributes[attr] = value1;
      }
    }

    for (const [attr, value2] of Object.entries(node2.attributes)) {
      if (!mergedAttributes.hasOwnProperty(attr)) {
        mergedAttributes[attr] = value2;
      }
    }

    node1.resetAttributes(mergedAttributes);
  }

  /**
   * Merge top siblings of node2 into node1.
   * If the sibling of node2 is also in the staplePairs, skip it.
   * If the sibling of node2 is not in the staplePairs, add it to the siblings of node1.
   * 
   * @param {SymbolicDOMNode} node1 - The node from symbolicDOMT1.
   * @param {SymbolicDOMNode} node2 - The node from symbolicDOMT2.
   */
  mergeTopSiblings(node1, node2) {
    if (this.symbolicDOMT2.topLevelSiblingNodes) {
      for (const siblingNode2 of this.symbolicDOMT2.topLevelSiblingNodes) {
        const isStapled = this.staplePairs.some(([nodeId1, nodeId2]) => {
          const node2Id = Object.keys(this.symbolicDOMT2.DOMSymbols).find(
            key => this.symbolicDOMT2.DOMSymbols[key] === siblingNode2
          );
          return node2Id === nodeId2;
        });

        if (!isStapled) {
          // Lazily check forall constaints
          if (this.symbolicDOMT1.forallConstraints.has(Staplar.getIdentifierFromNode(node1, this.symbolicDOMT1))) {
            let forallConstraint = this.symbolicDOMT1.forallConstraints.get(Staplar.getIdentifierFromNode(node1, this.symbolicDOMT1));
            if (forallConstraint[0] === 'Siblings') {
              if (!this.checkOverlap(siblingNode2, forallConstraint[1])) {
                throw new Error("Forall sibling constraint failed. Stapling failed.");
              }
            }
          }

          // Sibling length check
          const siblings = node1.isRoot ? this.symbolicDOMT1.topLevelSiblingNodes : node1.parent?.children;
          if (!siblings || siblings.length === 0) {
            throw new Error("No sibling of node1 in the staplePairs. Stapling failed.");
          }

          // Avoid adding the sibling if it is already in the siblings of node1
          const siblingNode1 = siblings.find(node => node.nodeUniqueId === siblingNode2.nodeUniqueId);
          if (siblingNode1) {
            continue;
          }

          if (!node1.isRoot) {
            node1.parent.children.push(siblingNode2);
          } else {
            this.symbolicDOMT1.topLevelSiblingNodes.push(siblingNode2);
          }
        }
      }
    }
  }

  /**
   * Merge the children of node2 into node1.
   * 
   * @param {SymbolicDOMNode} node1 - The node from symbolicDOMT1.
   * @param {SymbolicDOMNode} node2 - The node from symbolicDOMT2.
   */
  mergeChildren(node1, node2) {
    for (const childNode2 of node2.children) {
      const isStapled = this.staplePairs.some(([nodeId1, nodeId2]) => {
        const node2Id = Object.keys(this.symbolicDOMT2.DOMSymbols).find(
          key => this.symbolicDOMT2.DOMSymbols[key] === childNode2
        );
        return node2Id === nodeId2;
      });
  
      if (!isStapled) {
        node1.addChild(childNode2);
        childNode2.parent = node1;
      }
    }
  }

  /**
   * Propagate constraints from node2 to node1.
   */
  propagateConstraints() {
    if (!this.symbolicDOMT1 || !this.symbolicDOMT2) {
      throw new Error("Both symbolicDOMT1 and symbolicDOMT2 must be defined.");
    }
  
    const updatedConstraints = this.symbolicDOMT2.constraints
      .map(([command, ...args]) => {
        const updatedArgs = args.map(arg => {
          if (this.symbolMapping[arg]) {
            return this.symbolMapping[arg];
          }
          return arg;
        });
  
        if (command === 'isRoot') { return null; }

        // For other constraints, we check if the constraint is already in symbolicDOMT1
        // If it is, we merge the constraints
        const existingConstraint = this.symbolicDOMT1.constraints.find(([cmd, ...rest]) => {
          return cmd === command && rest.every((arg, i) => arg === updatedArgs[i]);
        }); 
        if (existingConstraint) {
          return null; 
        }
  
        // Return the updated constraint
        return [command, ...updatedArgs];
      })
      .filter(constraint => constraint !== null);
  
    for (const constraint of updatedConstraints) {
      this.symbolicDOMT1.addConstraint(...constraint);
    }
  }

  /**
   * Resolve conflicts in DOMSymbols and stringSymbols between symbolicDOMT1 and symbolicDOMT2.
   * @returns {Object} A mapping of old symbol names to new (renamed) symbols.
   */
  resolveSymbolConflicts() {
    const symbolMapping = {};

    // Handle DOMSymbols conflicts
    for (const [key, value] of Object.entries(this.symbolicDOMT2.DOMSymbols)) {
      const staplePair = this.staplePairs.find(([nodeId1, nodeId2]) => nodeId2 === key);
      if (staplePair) {
        const [nodeId1, nodeId2] = staplePair;
        symbolMapping[key] = nodeId1;
      } else if (this.symbolicDOMT1.DOMSymbols[key]) {
        const newKey = `${key}_stapled`;
        symbolMapping[key] = newKey;
        this.symbolicDOMT1.addConstraint('declareNode', newKey);
        this.symbolicDOMT1.DOMSymbols[newKey] = value;
      } else {
        this.symbolicDOMT1.addConstraint('declareNode', key);
        this.symbolicDOMT1.DOMSymbols[key] = value;
      }
    }

    // Handle stringSymbols conflicts
    for (const [key, value] of Object.entries(this.symbolicDOMT2.stringSymbols)) {
      if (this.symbolicDOMT1.stringSymbols[key]) {
        const newKey = `${key}_stapled`;
        symbolMapping[key] = newKey;
        this.symbolicDOMT1.addConstraint('declareString', newKey);
        this.symbolicDOMT1.stringSymbols[newKey] = newKey;
      } else {
        this.symbolicDOMT1.addConstraint('declareString', key);
        this.symbolicDOMT1.stringSymbols[key] = value;
      }
    }

    // Handle stringConstants conflicts
    for (const [key, value] of Object.entries(this.symbolicDOMT2.stringConstants)) {
      if (this.symbolicDOMT1.stringConstants[key]) {
        const newKey = `${key}_stapled`;
        symbolMapping[key] = newKey;
        this.symbolicDOMT1.addConstraint('declareConstantString', newKey, value);
        this.symbolicDOMT1.stringConstants[newKey] = value;
      } else {
        this.symbolicDOMT1.addConstraint('declareConstantString', key, value);
        this.symbolicDOMT1.stringConstants[key] = value;
      }
    }

    return symbolMapping;
  }
}


// let symbolicNode1 = new SymbolicDOMTree();
// symbolicNode1.declareNode('$node1');
// symbolicNode1.addConstraint('isRoot', '$node1');
// symbolicNode1.addConstraint('hasAttribute', '$node1', 'name', 'x');
// symbolicNode1.addConstraint('hasTagName', '$node1', 'form');
// symbolicNode1.declareNode('$node1');
// symbolicNode1.declareNode('$node2');
// symbolicNode1.addConstraint('isRoot', '$node1');
// symbolicNode1.addConstraint('hasSibling', '$node1', '$node2');
// symbolicNode1.addConstraint('hasTagName', '$node1', 'form');
// symbolicNode1.addConstraint('hasTagName', '$node2', 'y');
// symbolicNode1.addConstraint('hasAttribute', '$node2', 'data-x', 'y'); 
// symbolicNode1.addConstraint('hasAttribute', '$node2', 'data-z', 'y');
// symbolicNode1.addConstraint('bind', '$node1', '$1');
// symbolicNode1.addConstraint('setAttributeOR', '$node2', ["a", "b"]); 

// let symbolicNode2 = new SymbolicDOMTree();
// symbolicNode2.declareNode('$node1');
// symbolicNode2.declareNode('$node2');
// symbolicNode2.addConstraint('isRoot', '$node1');
// symbolicNode2.addConstraint('hasSibling', '$node1', '$node2');
// symbolicNode2.addConstraint('hasTagName', '$node1', 'form');
// symbolicNode2.addConstraint('hasTagName', '$node2', 'iframe');
// symbolicNode2.addConstraint('hasAttribute', '$node2', 'id', 'y'); 
// symbolicNode2.addConstraint('hasAttribute', '$node2', 'name', 'y');
// symbolicNode2.addConstraint('bind', '$node1', '$1');
// symbolicNode2.addConstraint('setAttributeOR', '$node2', ["id", "name"]);  

// let stapler = new Staplar(symbolicNode1, symbolicNode2, '$node1', '$node1');
// let stapledSymbolicNode = stapler.staple();

// console.log(stapledSymbolicNode.concreteToString());