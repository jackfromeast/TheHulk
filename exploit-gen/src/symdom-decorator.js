import { Utils } from './utils.js';
import { Rules } from "./rules/rules.js";
import { SymbolicDOMSolver } from "./symdom-solver.js"
import { UnitClause, CompoundClause, RootFormula } from './clause.js';

/**
 * The symbolic DOM decorator.
 * 
 * This class helps to decorate the TDG with the constraints in root formulas and unit clauses.
 */
export class SymbolicDOMDecorator {
  constructor(taintDependencyGraph) {
    this.taintDependencyGraph = taintDependencyGraph;
    this.ruleGenerator = new Rules();
    this.solver = new SymbolicDOMSolver();
  }

  decorate() {
    for (let contextId of this.taintDependencyGraph.objectiveMap.keys()) {
      for (let opNode of this.taintDependencyGraph.operationNodes) {
        try {
          this.attachConstraints(opNode, contextId);
        } catch (e) { ; }
      }
    }
      
  }

  /**
   * Traverse the operation nodes and attach constraints to the nodes.
   * In a top-down manner, and we save the constraint set to the constraints field of the TaintedValueNode.
   * The constraint set is a list of root formulas.
   */
  attachConstraints(operationNode, contextId) {
    // Given the operation node, (context, objective) and associated tainted value nodes,
    // we could attach the constraints to the tainted value nodes.
    if(operationNode.type === 'getField' && operationNode.getObjectives(contextId) === "Document-to-DOM") {
      this.attachGetFieldDocumentToDOM(operationNode, contextId);
    } else if(operationNode.type === 'getField' && operationNode.getObjectives(contextId) === "DOM-to-DOM") {
      this.attachGetFieldDOMToDOM(operationNode, contextId);
    } else if(operationNode.type === 'getField' && operationNode.getObjectives(contextId) === "DOM-to-String") {
      this.attachGetFieldDOMtoString(operationNode, contextId);
    } else {
      throw new Error('The operation is not supported.');
    }
  }

  attachGetFieldDocumentToDOM(operationNode, contextId) {
    if (operationNode.base.value !== "HTMLDocument") {
      throw new Error('The base of getField is not an HTMLDocument.');
    }

    let offsetName = operationNode.arguments.get('arg0').value;
    let taintedValueNode = operationNode.return;

    if (!taintedValueNode.tainted) {
      throw new Error('The tainted value node is not tainted.');
    }

    let rule05 = this.ruleGenerator.getRuleById('05');
    let rule06 = this.ruleGenerator.getRuleById('06');
    let rule07 = this.ruleGenerator.getRuleById('07');
    let rule08 = this.ruleGenerator.getRuleById('08');

    this.solver.clear()
    this.solver.addConstraint('and', new UnitClause(null, 'declareConstantString', '$P', offsetName));
    this.solver.addConstraint('and', new UnitClause(null, 'bind', '$R1', '$'+taintedValueNode.id));
    this.solver.addConstraint('and', new CompoundClause('or', [rule05, rule06, rule07, rule08]));
    let constraints = this.solver.reduceToDNFRootFormulasOnly();

    taintedValueNode.attachConstraints(contextId, constraints);
  }

  attachGetFieldDOMToDOM(operationNode, contextId) {
    if (!operationNode.base.tainted) {
      throw new Error('The base of getField is not tainted.');
    }

    if (!operationNode.return.tainted) {
      throw new Error('The tainted value node is not tainted.');
    }

    let offsetName = operationNode.arguments.get('arg0').value;
    let parentTaintedValueNode = operationNode.base;
    let retTaintedValueNode = operationNode.return;

    // TODO: Add other rules.
    let rule16 = this.ruleGenerator.getRuleById('16');

    this.solver.clear()
    this.solver.addConstraint('and', new UnitClause(null, 'bind', '$R1', '$'+parentTaintedValueNode.id));
    this.solver.addConstraint('and', new UnitClause(null, 'bind', '$R2', '$'+retTaintedValueNode.id));
    this.solver.addConstraint('and', new CompoundClause('or', [rule16]));
    let constraints = this.solver.reduceToDNFRootFormulasOnly();

    retTaintedValueNode.attachConstraints(contextId, constraints);
  }


  attachGetFieldDOMtoString(operationNode, contextId) {
    if (!operationNode.base.tainted) {
      throw new Error('The base of getField is not tainted.');
    }

    if (!operationNode.return.tainted) {
      throw new Error('The tainted value node is not tainted.');
    }

    let offsetName = operationNode.arguments.get('arg0').value;
    let parentTaintedValueNode = operationNode.base;
    let retTaintedValueNode = operationNode.return;

    // TODO: Add other rules.
    let rule20 = this.ruleGenerator.getRuleById('20');

    this.solver.clear()
    this.solver.addConstraint('and', new UnitClause(null, 'declareConstantString', '$P', offsetName));
    this.solver.addConstraint('and', new UnitClause(null, 'bind', '$R1', '$'+parentTaintedValueNode.id));
    // this.solver.addConstraint('and', new UnitClause(null, 'bind', '$Payload', '$'+retTaintedValueNode.id));
    this.solver.addConstraint('and', rule20);
    let constraints = this.solver.reduceToDNFRootFormulasOnly();

    retTaintedValueNode.attachConstraints(contextId, constraints);
  }
}