import { THETHING_TS1, THETHING_TS2, THETHING_TS3, THETHING_TS4, THETHING_TS5, THETHING_TS6 } from '../src/constants/thething.js';
import {SymbolicDOMTree} from './symbolic-dom-tree.js'
export class ruleMerge {
    constructor(Rules1, symbolicDOMT2, nodeId1, nodeId2) {
      this.Rules1 = Rules1;
      this.Rules2 = Rules2;
      this.nodeId1 = nodeId1;
      this.nodeId2 = nodeId2;
    }

    confilict(rule1, rule2){

    }

    checkSibling(){
        const hasSibilingRules2 = this.Rules2.filter(rule => rule[0] === 'hasSibiling');
        const hasSibilingRules1 = this.Rules1.filter(rule => rule[0] === 'hasSibiling');
        if (hasSibilingRules2.length!=hasSibilingRules1.length){
            throw new Error(`[Conflict] inconsistent hasSibiling.`);
        }
        // compare the rules?
        else{
            // normal merge (remove the duplicated ones)
        }
        return true
    }

    merge() {
        // if the nodeid are not same, replace in rule2 
        if (this.nodeId1!=this.nodeId2){
            this.Rules2 = this.Rules2.map(rule =>
                rule.map(item => (item === this.nodeId2 ? this.nodeId1 : item))
            );
        }
        var res = true;

        // check sibling
        this.checkSibling();

        // merge
        // Merge Rules1 and Rules2 into a single set (removing duplicates)
        var mergedRules = new Set([
            ...Rules1.map(rule => JSON.stringify(rule)), 
            ...Rules2.map(rule => JSON.stringify(rule))
        ]);

        // Convert back to array format
        var uniqueRules = Array.from(mergedRules).map(rule => JSON.parse(rule));


        if (res){
            return uniqueRules;
        }

    }

    
}

function or(...conditions) {
    return { operator: 'OR', conditions };
}


function mergeDOMNodes(preNode, postNode){
    // merge the result to the preNode
    // step1: check each attribute, see if there is conflict
    if (postNode.attributes){
        for (const attrName in postNode.attributes){
            if (attrName in preNode.attributes){
                if (preNode.attributes[attrName]!=postNode.attributes[attrName]){
                    throw new Error(`Conflict attributes: ${attrName}`);
                }
            }
            else{
                preNode.attributes[attrName] = postNode.attributes[attrName];
            }
        }
    }
    // step2: check types
    var resultTypes = [];
    if (preNode.nodeTypes[0]=='anything'){
        resultTypes = postNode.nodeTypes;
    }
    else if (postNode.nodeTypes[0]=='anything'){
        resultTypes = preNode.nodeTypes;
    }
    else if (preNode.nodeTypes!=postNode.nodeTypes){
        // get the common types between them
        for (const type of preNode.nodeTypes){
            if (type in postNode.nodeTypes){
                resultTypes.push(type);
            }
        }
        if (!resultTypes.length){
            throw new Error(`All conflict types`);
        }
    }
    preNode.nodeTypes = resultTypes;
    // step3: check children recursively, not sure
    preNode.children = preNode.children.concat(postNode.children);
    // return preNode;
}

// for $2, merge C3 and C4
function mergeDOMTrees(pre, post){
    for (const variable in pre.match){
        if (post.match.hasOwnProperty(variable)){
            console.log('match hit!')
            console.log('variable:', variable);
            console.log('pre node:', pre.match[variable]);
            console.log('post node:', post.match[variable]);
            console.log('=====================');
            // merge them!
            // see the common nodes
            mergeDOMNodes(pre.DOMSymbols[pre.match[variable]], post.DOMSymbols[post.match[variable]]);
        }
    }
    pre.printTree();
}

function and (...conditions) {
    return conditions.flat(); // Combine all rule sets into a single array
}


function ruleToSymDOMTree(rules){
    let tree = new SymbolicDOMTree();
    rules.forEach(([method, ...args]) => {
        if (method=='declareNode'){
            tree.declareNode(args[0]);
        }
        else if (method=='declareConstantString'){
            tree.declareConstantString(args[0], args[1]);
        }
        else if (method=='declareMatch'){
            tree.declareMatch(args[0], args[1]);
        }
        else if (method=='declareString'){
            tree.declareString(args[0]);
        }        
        else{
            tree.addConstraint(method, ...args);
        }
    });
    return tree;
}


// ======= start of Constraints 1, 2, 3, 4
// ======= C1
// C1 prefix
var C1Pre = [
    ['declareNode', '$node1'],
    ['declareMatch', '$node1', '$1'], // such rule is used to identify the match the DOM tree to a variable
    ['declareConstantString', '$P', 'script']
];

// 5
var atomic5 = [
    ['isRoot', '$node1'],
    ['hasAttribute', '$node1', 'name', '$P'],
    // ['hasType', '$node1', THETHING_TS2]
    ['hasType', '$node1', ['iframe', 'form']]
];

// 7 
var atomic71 = [  
    ['isRoot', '$node1'],
    ['declareNode', '$node2'],
    ['hasSibiling', '$node1', '$node2'],
    // 7-1
    // ['hasType', '$node1', THETHING_TS2],
    ['hasType', '$node1', ['iframe', 'form']],
    ['hasAttribute', '$node1', 'name', '$P'],
    // ['hasType', '$node2', THETHING_TS2],
    ['hasType', '$node2', ['iframe', 'form']],
    ['hasAttribute', '$node2', 'name', '$P']
];

var atomic72 = [
    ['isRoot', '$node1'],
    ['declareNode', '$node2'],
    ['hasSibiling', '$node1', '$node2'],
    // 7-2
    ['hasType', '$node1', 'object'],
    ['hasAttribute', '$node1','id', '$P'],
    ['hasType', '$node2', 'object'],
    ['hasAttribute', '$node2','id', '$P']
];
    


// ===== C2
var C2 = [
    ['declareNode', '$node1'],
    ['declareMatch', '$node1', '$1'],
    ['isRoot', '$node1'],
    ['declareNode', '$node2'],
    ['hasSibiling', '$node1', '$node2']
];


// In the paper, we have: C1Pre and (atomic5 or atomic71 or atomic72) 
// we expect the output to be three root nodes, each has different constraints
// the root node can have no sibling, or have sibling
// console.log(and(C1Pre, atomic71))

// var tree1 = ruleToSymDOMTree(and(C1Pre, atomic5));
// console.log(tree1.concreteToString());

// var tree2 = ruleToSymDOMTree(and(C1Pre, atomic71));
// console.log(tree2.concreteToString());

// var tree3 = ruleToSymDOMTree(and(C1Pre, atomic72));
// console.log(tree3.concreteToString());


// let us start from botton
// $3 must be a string
// $2 is a DOM, we start from $2
// ========== C3
var C3 = [
    ['declareNode', '$node1'],
    ['declareNode', '$node2'],
    ['isRoot', '$node1'],
    ['declareMatch', '$node1', '$1'], 
    ['declareMatch', '$node2', '$2'],
    ['hasSibiling', '$node1', '$node2']
];

// ========== C4
var C4pre = [
    ['declareNode', '$node1'],
    ['declareMatch', '$node1', '$2'], 
    ['declareConstantString', '$P', 'textContent']
];


var atomic20 = [
    ['isRoot', '$node1'],
    // ['hasType', '$node1', THETHING_TS*],
    ['hasType', '$node1', ["a", "abbr"]],
    ['declareString', '$payload'],
    ['hasAttribute', '$node1', '$P', '$payload']
];


// ======= start of trees 1, 2, 3, 4

var tree4 = ruleToSymDOMTree(and(C4pre, atomic20));
tree4.printTree();
// console.log("\ntree4 concreteToString\n========================");
// console.log(tree4.concreteToString());

var tree3 = ruleToSymDOMTree(C3);
tree3.printTree();
// console.log("\ntree3 concreteToString\n========================");
// console.log(tree3.concreteToString());

// mergeDOMTrees would merge the latter to the first
mergeDOMTrees(tree3, tree4);
// console.log("\ntree3 after merge with tree4\n========================");
// console.log(tree3.concreteToString());

var tree2 = ruleToSymDOMTree(C2);
console.log(tree2.concreteToString());
mergeDOMTrees(tree2, tree3);
console.log("\ntree2 after merge with tree3\n========================");
console.log(tree2.concreteToString());
