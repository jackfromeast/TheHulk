import { THETHING_TS1, THETHING_TS2, THETHING_TS3, THETHING_TS4, THETHING_TS5, THETHING_TS6 } from '../src/constants/thething.js';
import {SymbolicDOMTree} from './symbolic-dom-tree.js'

/**
 * merge preNode and postNode, the result is saved in preNode
 * 
 * @param {SymbolicDOMNode} preNode - 
 * @param {SymbolicDOMNode} postNode - 
 */
function mergeDOMNodes(preNode, postNode){
    // step1: check each attribute, see if there is conflict
    if (postNode.attributes){
        for (const attrName in postNode.attributes){
            if (attrName in preNode.attributes){
                if (preNode.attributes[attrName]!=postNode.attributes[attrName]){
                    throw new Error(`Conflict attributes: ${attrName}`);
                }
            }
            else{
                preNode.attributes[attrName] = postNode.attributes[attrName];
            }
        }
    }
    // step2: check types
    var resultTypes = [];
    if (preNode.nodeTypes[0]=='*'){
        resultTypes = postNode.nodeTypes;
    }
    else if (postNode.nodeTypes[0]=='*'){
        resultTypes = preNode.nodeTypes;
    }
    else if (preNode.nodeTypes!=postNode.nodeTypes){
        // get the common types between them
        for (const type of preNode.nodeTypes){
            if (postNode.nodeTypes.includes(type)){
                resultTypes.push(type);
            }
        }
        if (!resultTypes.length){
            throw new Error(`Conflict types`);
        }
    }
    preNode.nodeTypes = resultTypes;
    // step3: check children recursively, not sure
    preNode.children = preNode.children.concat(postNode.children);
    // return preNode;
}

/**
 * merge pre and post DOM Trees, the result is saved in pre
 * 
 * @param {SymbolicDOMTree} pre - 
 * @param {SymbolicDOMTree} post - 
 *  * @param {boolean} checkSibling - if it is merging the topmost constraints, check siblings number
 */
function mergeDOMTrees(pre, post, checkSibling=false){
    var siblingMerged = false;
    if (checkSibling){
        if (pre.topLevelSiblingNodes.length!=post.topLevelSiblingNodes.length){
            throw new Error(`Sibling number conflict at first stage`);
        }
    }
    for (const variable in pre.match){
        if (post.match.hasOwnProperty(variable)){
            console.log('Same variable binding hit!')
            console.log('Variable:', variable);
            console.log('Pre node:', pre.match[variable]);
            console.log('Post node:', post.match[variable]);
            console.log('\n');
            // merge nodes bound to same variable
            mergeDOMNodes(pre.DOMSymbols[pre.match[variable]], post.DOMSymbols[post.match[variable]]);
            // take care of thier siblings
            if (!siblingMerged){
                if (!pre.topLevelSiblingNodes.length){
                    pre.topLevelSiblingNodes = post.topLevelSiblingNodes;
                }
                else if (!post.topLevelSiblingNodes.length){
                    post.topLevelSiblingNodes = pre.topLevelSiblingNodes;
                }
                else if (pre.topLevelSiblingNodes.length>1 && post.topLevelSiblingNodes.length>1){
                    throw new Error(`More than one sibling case not implemented!`);
                }
                // this only applies to the case where there is only one sibling
                else{
                    mergeDOMNodes(pre.topLevelSiblingNodes[0], post.topLevelSiblingNodes[0]);
                }
            }
        }
    }
}

/**
 * combine contraints *pre* and *other constraints*, note all constraints are "and"ed together
 * 
 */
function and (...conditions) {
    return conditions.flat(); // Combine all rule sets into a single array
}

/**
 * from texts of rules to SymbolicDOMTree, for future use
 * 
 * @param {[[string1, string2], [string3, string4]]} rules - denoting the constraints
 */
function ruleToSymDOMTree(rules){
    let tree = new SymbolicDOMTree();
    rules.forEach(([method, ...args]) => {
        if (method=='declareNode'){
            tree.declareNode(args[0]);
        }
        else if (method=='declareConstantString'){
            tree.declareConstantString(args[0], args[1]);
        }
        else if (method=='declareMatch'){
            tree.declareMatch(args[0], args[1]);
        }
        else if (method=='declareString'){
            tree.declareString(args[0]);
        }        
        else{
            tree.addConstraint(method, ...args);
        }
    });
    return tree;
}

/**
 * start of definition of constraints
 */
// ========== C1
var C1Pre = [
    ['declareNode', '$node1'],
    ['declareMatch', '$node1', '$1'], // such rule is used to identify the match the DOM tree to a variable
    ['declareConstantString', '$P', 'script']
];

var atomic5 = [
    ['isRoot', '$node1'],
    ['hasAttribute', '$node1', 'name', '$P'],
    // ['hasType', '$node1', THETHING_TS2]
    ['hasType', '$node1', ['iframe', 'form']]
];

var atomic71 = [  
    ['isRoot', '$node1'],
    ['declareNode', '$node2'],
    ['hasSibling', '$node1', '$node2'],
    // 7-1
    // ['hasType', '$node1', THETHING_TS2],
    ['hasType', '$node1', ['iframe', 'form']],
    ['hasAttribute', '$node1', 'name', '$P'],
    // ['hasType', '$node2', THETHING_TS2],
    ['hasType', '$node2', ['iframe', 'form']],
    ['hasAttribute', '$node2', 'name', '$P']
];

var atomic72 = [
    ['isRoot', '$node1'],
    ['declareNode', '$node2'],
    ['hasSibling', '$node1', '$node2'],
    // 7-2
    ['hasType', '$node1', 'object'],
    ['hasAttribute', '$node1','id', '$P'],
    ['hasType', '$node2', 'object'],
    ['hasAttribute', '$node2','id', '$P']
];
    
var C2 = [
    ['declareNode', '$node1'],
    ['declareMatch', '$node1', '$1'],
    ['isRoot', '$node1'],
    ['declareNode', '$node2'],
    ['hasSibling', '$node1', '$node2']
];

var C3 = [
    ['declareNode', '$node1'],
    ['declareNode', '$node2'],
    ['isRoot', '$node1'],
    ['declareMatch', '$node1', '$1'], 
    ['declareMatch', '$node2', '$2'],
    ['hasSibling', '$node1', '$node2']
];

var C4pre = [
    ['declareNode', '$node1'],
    ['declareMatch', '$node1', '$2'], 
    ['declareConstantString', '$P', 'textContent']
];

var atomic20 = [
    ['isRoot', '$node1'],
    // ['hasType', '$node1', THETHING_TS*],
    ['hasType', '$node1', ["a", "abbr", "iframe", "form"]],
    ['declareString', '$payload'],
    ['hasAttribute', '$node1', '$P', '$payload']
];


/**
 * start of trees 1, 2, 3, 4 and their mergings
 */
var tree4 = ruleToSymDOMTree(and(C4pre, atomic20));

var tree3 = ruleToSymDOMTree(C3);
mergeDOMTrees(tree3, tree4);

var tree2 = ruleToSymDOMTree(C2);
mergeDOMTrees(tree2, tree3);

var tree15 = ruleToSymDOMTree(and(C1Pre, atomic5));
// mergeDOMTrees(tree15, tree2, true);
// console.log("\n tree15 after merge with tree2\n========================");
// console.log(tree15.concreteToString());

var tree171 = ruleToSymDOMTree(and(C1Pre, atomic71));
console.log(`Merging tree171 with tree2...`);
mergeDOMTrees(tree171, tree2, true);
console.log("tree171 after merge with tree2\n========================");
console.log(tree171.concreteToString());

var tree172 = ruleToSymDOMTree(and(C1Pre, atomic72));
console.log(`Merging tree172 with tree2...`);
mergeDOMTrees(tree172, tree2, true);
console.log("tree172 after merge with tree2\n========================");
console.log(tree172.concreteToString());
