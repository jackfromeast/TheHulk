export class UnitClause {
  constructor(namespace=null, verb="Unknown", ...args) {
    this.namespace = namespace;
    this.verb = verb;
    this.content = [verb, ...args];
    this.literal = this.resolveLiteral(verb, args);
  }

  /**
   * Resolves the literal of the unit clause based on
   * its verb and arguments.
   * 
   * For different verbs, the arguments may have different meanings.
   */
  resolveLiteral(verb, args) {
    // TODO
  }

  print() {
    return `${this.namespace?this.namespace:"_"}.${this.verb}(${this.content.slice(1).join(", ")})`;
  }
}

/**
 * Represents a compound clause, which combines one or more clauses
 * with a logical operator (e.g., 'and', 'or', 'not').
 */
export class CompoundClause {
  /**
   * @param {string} operator - 'and', 'or', or 'not'
   * @param {Array<UnitClause|CompoundClause>} clauses - the clauses being combined
   */
  constructor(operator, clauses) {
    this.operator = operator;
    this.clauses = clauses;
  }

  andNewClause(clause) {
    if (this.operator !== "and") {
      throw new Error(`Cannot add clause to a non-AND compound clause.`);
    }
    this.clauses.push(clause);
  }

  orNewClause(clause) {
    if (this.operator !== "or") {
      throw new Error(`Cannot add clause to a non-OR compound clause.`);
    }
    this.clauses.push(clause);
  }

  print(indent = 0) {
    const indentation = "  ".repeat(indent);
    if (this instanceof RootFormula) {
      console.log(`${indentation}[RootFormula]`);
    }
    if (this.clauses.length === 1 && this.clauses[0] instanceof CompoundClause) {
      this.clauses[0].print(indent);
      return;
    }
    console.log(`${indentation}(${this.operator}`);
    for (const clause of this.clauses) {
      if (clause instanceof CompoundClause) {
        clause.print(indent + 1);
      } else if (clause instanceof UnitClause) {
        console.log(`${indentation}  ${clause.verb}(${clause.content.join(", ")})`);
      } else {
        console.log(`${indentation}  UnknownClause`);
      }
    }
    console.log(`${indentation})`);
  }
}

/**
 * A root formula is a **conjunction** of clauses that contains exactly one `isRoot` clause.
 * This class extends `CompoundClause` but enforces the "only one isRoot" rule.
 */
export class RootFormula extends CompoundClause {
  /**
   * @param {string} namespace - A namespace identifier
   * @param  {...(UnitClause|CompoundClause)} clauses - The clauses in this formula
   */
  constructor(namespace, ...clauses) {
    super("and", clauses); // A root formula is, by definition, a conjunction
    this.namespace = namespace;
    this.isRootFormula = true;

    // Ensure exactly one isRoot clause
    const rootCount = this.countIsRootClauses(this);
    if (rootCount !== 1) {
      throw new Error(
        `A root formula must contain exactly one 'isRoot' clause, but found ${rootCount}.`
      );
    }
  }

  /**
   * Counts the number of `isRoot` clauses in a formula.
   * @param {CompoundClause} formula
   * @returns {number}
   */
  countIsRootClauses(clause) {
    if (clause instanceof UnitClause) {
      // If the verb is 'isRoot', count it
      return clause.verb === "isRoot" ? 1 : 0;
    } else if (clause instanceof CompoundClause) {
      // Sum all occurrences within subclauses
      return clause.clauses.reduce(
        (acc, sub) => acc + this.countIsRootClauses(sub),
        0
      );
    }
    return 0;
  }

  /**
   * Adds a new UnitClause to this root formula by wrapping the new clause
   * in the operator provided. (For example, operator="or" will embed
   * the new clause in a CompoundClause("or", [...]).)
   *
   * After adding, we re-check that there's still exactly one isRoot.
   *
   * @param {string} operator - 'and', 'or', or 'not'
   * @param {UnitClause} unit - the new unit clause to add
   */
  addNewUnitClause(operator, unit) {
    if (operator === "and") {
      // Since RootFormula is already an AND, just push the new clause.
      this.clauses.push(unit);
    } else if (operator === "or") {
      // Wrap the new unit in an OR subclause and add it
      this.clauses.push(new CompoundClause("or", [unit]));
    } else if (operator === "not") {
      // Wrap the new unit in a NOT subclause
      this.clauses.push(new CompoundClause("not", [unit]));
    } else {
      throw new Error(`Unsupported operator: ${operator}`);
    }

    // Re-check that there's exactly one 'isRoot' in the entire formula
    const rootCount = this.countIsRootClauses(this);
    if (rootCount !== 1) {
      throw new Error(
        `A root formula must contain exactly one 'isRoot' clause. Found ${rootCount} after adding a new clause.`
      );
    }
  }
}

/**
 * A convenient interface (static methods) to build compound clauses
 * without manually creating CompoundClause each time.
 */
export class ClauseBuilder {
  /**
   * Combines multiple clauses with logical AND.
   * @param  {...(UnitClause|CompoundClause)} clauses
   * @returns {CompoundClause}
   */
  static and(...clauses) {
    return new CompoundClause("and", clauses);
  }

  /**
   * Combines multiple clauses with logical OR.
   * @param  {...(UnitClause|CompoundClause)} clauses
   * @returns {CompoundClause}
   */
  static or(...clauses) {
    return new CompoundClause("or", clauses);
  }

  /**
   * Negates a single clause with logical NOT.
   * @param {(UnitClause|CompoundClause)} clause
   * @returns {CompoundClause}
   */
  static not(clause) {
    return new CompoundClause("not", [clause]);
  }
}