import { Utils } from "./utils.js";

export class UnitClause {
  constructor(namespace=null, verb="Unknown", ...args) {
    this.namespace = namespace;
    this.verb = verb;
    this.content = [verb, ...args];
    this.literal = this.resolveLiteral(verb, args);
  }

  /**
   * Resolves the literal of the unit clause based on
   * its verb and arguments.
   * 
   * For different verbs, the arguments may have different meanings.
   */
  resolveLiteral(verb, args) {
    // TODO
  }

  print() {
    return `${this.namespace?this.namespace:"_"}.${this.verb}(${this.content.slice(1).join(", ")})`;
  }

  clone() {
    return new UnitClause(this.namespace, this.verb, ...this.content.slice(1));
  }
}

/**
 * Represents a compound clause, which combines one or more clauses
 * with a logical operator (e.g., 'and', 'or', 'not').
 */
export class CompoundClause {
  /**
   * @param {string} operator - 'and', 'or', or 'not'
   * @param {Array<UnitClause|CompoundClause>} clauses - the clauses being combined
   */
  constructor(operator, clauses) {
    this.operator = operator;
    if (!(clauses instanceof Array)) {
      clauses = [clauses];
    }
    this.clauses = clauses;
  }

  andNewClause(clause) {
    if (this.operator !== "and") {
      throw new Error(`Cannot add clause to a non-AND compound clause.`);
    }
    this.clauses.push(clause);
  }

  orNewClause(clause) {
    if (this.operator !== "or") {
      throw new Error(`Cannot add clause to a non-OR compound clause.`);
    }
    this.clauses.push(clause);
  }

  print(indent = 0) {
    const indentation = "  ".repeat(indent);
    if (this instanceof RootFormula) {
      console.log(`${indentation}[RootFormula]`);
    }
    if (this.clauses.length === 1 && this.clauses[0] instanceof CompoundClause) {
      this.clauses[0].print(indent);
      return;
    }
    console.log(`${indentation}(${this.operator}`);
    for (const clause of this.clauses) {
      if (clause instanceof CompoundClause) {
        clause.print(indent + 1);
      } else if (clause instanceof UnitClause) {
        console.log(`${indentation}  ${clause.verb}(${clause.content.join(", ")})`);
      } else {
        console.log(`${indentation}  UnknownClause`);
      }
    }
    console.log(`${indentation})`);
  }

  clone() {
    const clonedClauses = this.clauses.map((c) => c.clone());
    return new CompoundClause(this.operator, clonedClauses);
  }

  /**
   * Flattens the root formula into a single-level CNF. 
   */
  flatten() {
    function flattenHelper(clause) {
      if (clause instanceof UnitClause) {
        return clause;
      } else if (clause instanceof CompoundClause) {
        let newFlatClause;
        if (clause instanceof RootFormula) {
          newFlatClause = new RootFormula(clause.namespace, [], true);
        } else{
          newFlatClause = new CompoundClause(clause.operator, []);
        }

        let subClauses = clause.clauses.map((c) => flattenHelper(c));
        
        for (const subClause of subClauses) {
          if (subClause instanceof CompoundClause && subClause.operator === clause.operator) {
            newFlatClause.clauses.push(...subClause.clauses);
          } else {
            newFlatClause.clauses.push(subClause);
          }
        }

        return newFlatClause;
      }
    }

    return flattenHelper(this);
  }

  hasRootFormula() {
    for (const clause of this.clauses) {
      if (clause instanceof RootFormula) {
        return true;
      } else if (clause instanceof CompoundClause) {
        if (clause.hasRootFormula()) {
          return true;
        }
      }
    }
  }

  unwrap() {
    return this;
  }
}

/**
 * A root formula is a **conjunction** of clauses that contains exactly one `isRoot` clause.
 * This class extends `CompoundClause` but enforces the "only one isRoot" rule.
 */
export class RootFormula extends CompoundClause {
  /**
   * @param {string} namespace - A namespace identifier
   * @param {Array<UnitClause|CompoundClause>} clauses - The clauses in this formula
   */
  constructor(namespace=undefined, clauses=[], lazyInit=false) {
    super("and", clauses); // A root formula is, by definition, a conjunction
    this.namespace = namespace ? namespace : Utils.generateUniqueId();
    this.isRootFormula = true;
    this.clonedFrom = null;
    this.isFlattenCNF = false;

    // Ensure exactly one isRoot clause
    if (!lazyInit){
      const rootCount = this.countIsRootClauses(this);
      if (rootCount !== 1) {
        throw new Error(
          `A root formula must contain exactly one 'isRoot' clause, but found ${rootCount}.`
        );
      }
    }
  }

  /**
   * Counts the number of `isRoot` clauses in a formula.
   * @param {CompoundClause} formula
   * @returns {number}
   */
  countIsRootClauses(clause) {
    if (clause instanceof UnitClause) {
      // If the verb is 'isRoot', count it
      return clause.verb === "isRoot" ? 1 : 0;
    } else if (clause instanceof CompoundClause) {
      // Sum all occurrences within subclauses
      return clause.clauses.reduce(
        (acc, sub) => acc + this.countIsRootClauses(sub),
        0
      );
    }
    return 0;
  }

  /**
   * Adds a new UnitClause to this root formula by wrapping the new clause
   * in the operator provided. (For example, operator="or" will embed
   * the new clause in a CompoundClause("or", [...]).)
   *
   * After adding, we re-check that there's still exactly one isRoot.
   *
   * @param {string} operator - 'and', 'or', or 'not'
   * @param {UnitClause} unit - the new unit clause to add
   */
  addNewUnitClause(operator, unit) {
    if (unit.namespace !== this.namespace) {
      unit.namespace = this.namespace;
    }

    if (operator === "and") {
      // Since RootFormula is already an AND, just push the new clause.
      this.clauses.push(unit);
    } else if (operator === "or") {
      // Wrap the new unit in an OR subclause and add it
      this.clauses.push(new CompoundClause("or", [unit]));
    } else if (operator === "not") {
      // Wrap the new unit in a NOT subclause
      this.clauses.push(new CompoundClause("not", [unit]));
    } else {
      throw new Error(`Unsupported operator: ${operator}`);
    }

    // Re-check that there's exactly one 'isRoot' in the entire formula
    const rootCount = this.countIsRootClauses(this);
    if (rootCount !== 1) {
      throw new Error(
        `A root formula must contain exactly one 'isRoot' clause. Found ${rootCount} after adding a new clause.`
      );
    }
  }

  /**
   * Adds a new CompoundClause to this root formula
   * @returns 
   */
  addNewCompoundClause(operator, compound) {
    if (operator === "and") {
      if (compound.operator === "and") {
        this.clauses.push(...compound.clauses);
      } else {
        this.clauses.push(compound);
      }
    }
  }

  /**
   * Checks if the root formula is already in a flattened CNF form.
   */
  checkFlattenCNF() {
    if (this.operator !== "and") {
      return false;
    }

    for (const clause of this.clauses) {
      if (clause instanceof CompoundClause) {
       return false;
      }
    }

    return true;
  }

  clone() {
    const newNamespace = Utils.generateUniqueId();
    const clonedClauses = this.clauses.map((c) => c.clone());
    const clonedRoot = new RootFormula(newNamespace, clonedClauses);
    clonedRoot.clonedFrom = this;
    return clonedRoot;
  }

  unwrap() { 
    return new CompoundClause("and", this.clauses);
  }

  /**
   * Make flatten operation root-formula-preserving.
   */
  flatten() {
    let flattened = super.flatten();
    return new RootFormula(this.namespace, flattened.clauses);
  }
}

/**
 * A convenient interface (static methods) to build compound clauses
 * without manually creating CompoundClause each time.
 */
export class ClauseBuilder {
  /**
   * Combines multiple clauses with logical AND.
   * @param  {...(UnitClause|CompoundClause)} clauses
   * @returns {CompoundClause}
   */
  static and(...clauses) {
    return new CompoundClause("and", clauses);
  }

  /**
   * Combines multiple clauses with logical OR.
   * @param  {...(UnitClause|CompoundClause)} clauses
   * @returns {CompoundClause}
   */
  static or(...clauses) {
    return new CompoundClause("or", clauses);
  }

  /**
   * Negates a single clause with logical NOT.
   * @param {(UnitClause|CompoundClause)} clause
   * @returns {CompoundClause}
   */
  static not(clause) {
    return new CompoundClause("not", [clause]);
  }
}