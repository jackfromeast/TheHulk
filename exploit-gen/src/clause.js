import { Utils } from "./utils.js";
import { SymbolicDOMTree } from "./symdom-tree.js"
export class UnitClause {
  /**
   * @param {string|null} namespace - The namespace of the clause (default: null).
   * @param {string} verb - The verb representing the clause action.
   * @param {...any} args - Additional arguments related to the verb.
   */
  constructor(namespace=null, verb="Unknown", ...args) {
    this.namespace = namespace;
    this.verb = verb;
    this.content = [verb, ...args];
    this.literal = this.resolveLiteral(verb, args);
  }

  /**
   * Resolves the literal of the unit clause based on
   * its verb and arguments.
   * 
   * For different verbs, the arguments may have different meanings.
   */
  resolveLiteral(verb, args) {
    // TODO
  }

  print() {
    return `${this.namespace?this.namespace:"_"}.${this.verb}(${this.content.slice(1).join(", ")})`;
  }

  clone() {
    return new UnitClause(this.namespace, this.verb, ...this.content.slice(1));
  }
}

/**
 * Represents a compound clause, which combines one or more clauses
 * with a logical operator (e.g., 'and', 'or', 'not').
 */
export class CompoundClause {
  /**
   * @param {string} operator - 'and', 'or', or 'not'
   * @param {Array<UnitClause|CompoundClause>} clauses - the clauses being combined
   */
  constructor(operator, clauses) {
    this.operator = operator;
    if (!(clauses instanceof Array)) {
      clauses = [clauses];
    }
    this.clauses = clauses;
  }

  andNewClause(clause) {
    if (this.operator !== "and") {
      throw new Error(`Cannot add clause to a non-AND compound clause.`);
    }
    this.clauses.push(clause);
  }

  orNewClause(clause) {
    if (this.operator !== "or") {
      throw new Error(`Cannot add clause to a non-OR compound clause.`);
    }
    this.clauses.push(clause);
  }

  print(indent = 0) {
    const indentation = "  ".repeat(indent);
    if (this instanceof RootFormula) {
      console.log(`${indentation}[RootFormula]`);
    }
    if (this.clauses.length === 1 && this.clauses[0] instanceof CompoundClause) {
      this.clauses[0].print(indent);
      return;
    }
    console.log(`${indentation}(${this.operator}`);
    for (const clause of this.clauses) {
      if (clause instanceof CompoundClause) {
        clause.print(indent + 1);
      } else if (clause instanceof UnitClause) {
        console.log(`${indentation}  ${clause.verb}(${clause.content.join(", ")})`);
      } else {
        console.log(`${indentation}  UnknownClause`);
      }
    }
    console.log(`${indentation})`);
  }

  /**
   * Creates a deep copy of the unit clause.
   * @returns {UnitClause} - A new instance of UnitClause with the same values.
   */
  clone() {
    const clonedClauses = this.clauses.map((c) => c.clone());
    return new CompoundClause(this.operator, clonedClauses);
  }

  /**
   * Flattens nested compound clauses of the same operator into a single-level clause.
   * @returns {CompoundClause} - A flattened version of the compound clause.
   */
  flatten() {
    function flattenHelper(clause) {
      if (clause instanceof UnitClause) {
        return clause;
      } else if (clause instanceof CompoundClause) {
        let newFlatClause;
        if (clause instanceof RootFormula) {
          newFlatClause = new RootFormula(clause.namespace, [], true);
        } else{
          newFlatClause = new CompoundClause(clause.operator, []);
        }

        let subClauses = clause.clauses.map((c) => flattenHelper(c));
        
        for (const subClause of subClauses) {
          if (subClause instanceof CompoundClause && subClause.operator === clause.operator) {
            newFlatClause.clauses.push(...subClause.clauses);
          } else {
            newFlatClause.clauses.push(subClause);
          }
        }

        return newFlatClause;
      }
    }

    return flattenHelper(this);
  }

  hasRootFormula() {
    for (const clause of this.clauses) {
      if (clause instanceof RootFormula) {
        return true;
      } else if (clause instanceof CompoundClause) {
        if (clause.hasRootFormula()) {
          return true;
        }
      }
    }
  }

  unwrap() {
    return this;
  }
}

/**
 * A root formula is a **conjunction** of clauses that contains exactly one `isRoot` clause.
 * This class extends `CompoundClause` but enforces the "only one isRoot" rule.
 */
export class RootFormula extends CompoundClause {
  /**
   * @param {string} namespace - A namespace identifier
   * @param {Array<UnitClause|CompoundClause>} clauses - The clauses in this formula
   */
  constructor(namespace=undefined, clauses=[], lazyInit=false) {
    super("and", clauses); // A root formula is, by definition, a conjunction
    this.namespace = namespace ? namespace : Utils.generateUniqueId();
    this.isRootFormula = true;
    this.clonedFrom = null;
    this.isFlattenCNF = false;

    // Ensure exactly one isRoot clause
    if (!lazyInit){
      const rootCount = this.countIsRootClauses(this);
      if (rootCount !== 1) {
        throw new Error(
          `A root formula must contain exactly one 'isRoot' clause, but found ${rootCount}.`
        );
      }
    }
  }

  /**
   * Counts the number of `isRoot` clauses in a formula.
   * @param {CompoundClause} formula
   * @returns {number}
   */
  countIsRootClauses(clause) {
    if (clause instanceof UnitClause) {
      // If the verb is 'isRoot', count it
      return clause.verb === "isRoot" ? 1 : 0;
    } else if (clause instanceof CompoundClause) {
      // Sum all occurrences within subclauses
      return clause.clauses.reduce(
        (acc, sub) => acc + this.countIsRootClauses(sub),
        0
      );
    }
    return 0;
  }

  /**
   * Adds a new UnitClause to this root formula by wrapping the new clause
   * in the operator provided. (For example, operator="or" will embed
   * the new clause in a CompoundClause("or", [...]).)
   *
   * After adding, we re-check that there's still exactly one isRoot.
   *
   * @param {string} operator - 'and', 'or', or 'not'
   * @param {UnitClause} unit - the new unit clause to add
   */
  addNewUnitClause(operator, unit) {
    if (unit.namespace !== this.namespace) {
      unit.namespace = this.namespace;
    }

    if (operator === "and") {
      this.clauses.push(unit);
    } else if (operator === "or") {
      this.clauses.push(new CompoundClause("or", [unit]));
    } else if (operator === "not") {
      this.clauses.push(new CompoundClause("not", [unit]));
    } else {
      throw new Error(`Unsupported operator: ${operator}`);
    }

    // Re-check that there's exactly one 'isRoot' in the entire formula
    const rootCount = this.countIsRootClauses(this);
    if (rootCount !== 1) {
      throw new Error(
        `A root formula must contain exactly one 'isRoot' clause. Found ${rootCount} after adding a new clause.`
      );
    }
  }

  /**
   * Adds a new CompoundClause to this root formula
   * @returns 
   */
  addNewCompoundClause(operator, compound) {
    if (operator === "and") {
      if (compound.operator === "and") {
        this.clauses.push(...compound.clauses);
      } else {
        this.clauses.push(compound);
      }
    }
  }

  /**
   * Checks if the root formula is already in a flattened CNF form.
   */
  checkFlattenCNF() {
    if (this.operator !== "and") {
      return false;
    }

    for (const clause of this.clauses) {
      if (clause instanceof CompoundClause) {
       return false;
      }
    }

    return true;
  }

  clone() {
    const newNamespace = Utils.generateUniqueId();
    const clonedClauses = this.clauses.map((c) => c.clone());
    const clonedRoot = new RootFormula(newNamespace, clonedClauses);
    clonedRoot.clonedFrom = this;
    return clonedRoot;
  }

  unwrap() { 
    return new CompoundClause("and", this.clauses);
  }

  /**
   * Make flatten operation root-formula-preserving.
   */
  flatten() {
    let flattened = super.flatten();
    return new RootFormula(this.namespace, flattened.clauses);
  }
  sortRules(rules){
    // put isRoot behind declare node
    // Separate elements that contain 'isRoot'
    let isRootElements = rules.filter(item => item.includes('isRoot'));
    let noRootElements = rules.filter(item => !item.includes('isRoot'));
    if (isRootElements.length != 1){
      throw new Error('There must be exactly one isRoot clause in the root formula.');
    }

    const validFirstItems = ['declare', 'declareConstantString', 'declareString'];
    // Separate arrays into two groups
    const priorityArrays = [];
    const otherArrays = [];
    
    noRootElements.forEach(arr => {
        if (arr.length > 0 && validFirstItems.includes(arr[0])) {
            priorityArrays.push(arr);
        } else {
            otherArrays.push(arr);
        }
    });
    
    // Merge them with 'isRoot' elements at the back
    let reorderedRules = [...priorityArrays, ...isRootElements, ...otherArrays];
    return reorderedRules;
  }
  /**
   * Generates a symbolic DOM tree from the root formula. All clauses are connected with "and".
   * 
   * @returns {SymbolicDOMTree}
   */
  toSymbolicDOMTree() {
    let rules = [];
    for (let clause of this.clauses){
      rules.push(clause.content);
    }
    let tree = new SymbolicDOMTree();
    let reorderedRules = this.sortRules(rules);
    console.log(reorderedRules);
    reorderedRules.forEach(([method, ...args]) => {
        if (method=='declare'){
            tree.declareNode(args[0]);
        }
        else if (method=='declareConstantString'){
            tree.declareConstantString(args[0], args[1]);
        }
        else if (method=='bind'){
            tree.declareBind(args[0], args[1]);
        }
        else if (method=='declareString'){
            tree.declareString(args[0]);
        }        
        else{
            tree.addConstraint(method, ...args);
        }
    });
    return tree;
  }
}

/**
 * A convenient interface (static methods) to build compound clauses
 * without manually creating CompoundClause each time.
 */
export class ClauseBuilder {
  /**
   * Combines multiple clauses with logical AND.
   * @param  {...(UnitClause|CompoundClause)} clauses
   * @returns {CompoundClause}
   */
  static and(...clauses) {
    return new CompoundClause("and", clauses);
  }

  /**
   * Combines multiple clauses with logical OR.
   * @param  {...(UnitClause|CompoundClause)} clauses
   * @returns {CompoundClause}
   */
  static or(...clauses) {
    return new CompoundClause("or", clauses);
  }

  /**
   * Negates a single clause with logical NOT.
   * @param {(UnitClause|CompoundClause)} clause
   * @returns {CompoundClause}
   */
  static not(clause) {
    return new CompoundClause("not", [clause]);
  }
}