import { JSDOM } from 'jsdom';
import { SymbolicDOMNode } from './symbolic-dom-node.js';
import { Utils } from "./utils.js";
import { h, create } from 'virtual-dom';
import toHTML from 'vdom-to-html';

/**
 * The exploit DOM tree holder.
 * 
 * The class object represents the symbolic DOM tree that satisfies the imposed constraints for the exploit.
 * Note that, the DOMClobberingExp = a set of possible DOM trees that satisfy the constraints.
 * 
 */
export class SymbolicDOMTree {
  constructor() {
    this.constraints = [];
    this.DOMSymbols = {};
    this.stringSymbols = {};
    this.stringConstants = {};
    // match is attached at SymbolicDOMTree level because SymbolicDOMTree has one-to-one map to variables
    this.match = {};

    this.rootNode = null;

    // The lower-level sibling nodes can be set as children of shared parent nodes.
    this.topLevelSibilingNodes = [];
  }

  printTree(){
    console.log("SymbolicDOMTree");
    console.log("========================");
    console.log("constraints:");
    console.log(this.constraints);
    console.log("match to variable:");
    console.log(this.match);
    console.log("stringSymbols");
    console.log(this.stringSymbols);
    console.log("stringConstants");
    console.log(this.stringConstants);
  }

  /**
   * Declares a new DOM node with a specific type.
   * If nodeType is "*", it will consider all possible node types.
   * @param {string} nodeType - The type of the DOM node (e.g., 'div', 'iframe', or '*').
   * @param {string} nodeId - The unique ID for the node (for internal reference). The ID should be unique within the tree.
   */
  declareNode(nodeIdentifier) {
    if (this.DOMSymbols[nodeIdentifier]) {
      throw new Error(`Node with identifier ${nodeIdentifier} already exists.`);
    } else if (!nodeIdentifier.startsWith('$')) {
      throw new Error(`Node identifier ${nodeIdentifier} should start with '$'.`);
    }
    this.DOMSymbols[nodeIdentifier] = new SymbolicDOMNode(['anything']);   
  }

  /**
   * Declares a new string symbol.
   * @param {string} stringIdentifier - The unique ID for the string (for internal reference).
   */
  declareString(stringIdentifier) {
    if (this.stringSymbols[stringIdentifier]) {
      throw new Error(`String with identifier ${stringIdentifier} already exists.`);
    } else if (!stringIdentifier.startsWith('$')) {
      throw new Error(`Node identifier ${nodeIdentifier} should start with '$'.`);
    }

    // this.stringSymbols[stringIdentifier] = Symbol();
    this.stringSymbols[stringIdentifier] = stringIdentifier;
  }

  declareConstantString(stringIdentifier, stringValue) {
    if (this.stringConstants[stringIdentifier]) {
      throw new Error(`String constant with identifier ${stringIdentifier} already exists.`);
    } else if (!stringIdentifier.startsWith('$')) {
      throw new Error(`String constant identifier ${stringIdentifier} should start with '$'.`);
    }

    this.stringConstants[stringIdentifier] = stringValue;
  }

  declareMatch(nodeIdentifier, variableIdentifier) {
    if (this.match[nodeIdentifier]) {
      throw new Error(`DOM tree ${nodeIdentifier} is already matched to ${this.match[nodeIdentifier]}.`);
    } else if (!nodeIdentifier.startsWith('$')) {
      throw new Error(`Identifier ${nodeIdentifier} should start with '$'.`);
    }

    this.match[variableIdentifier] = nodeIdentifier;
  }


  /**
   * Adds a constraint to the symbolic DOM tree.
   * @param {string} command - The constraint command (e.g., 'isRoot').
   * @param  {...any} args - Arguments for the command.
   */
  addConstraint(command, ...args) {
    switch (command) {
      case 'isRoot': 
        this.setAsRoot(args[0]);
        this.constraints.push([command, ...args]);
        break;
      
      case 'hasAttribute':
        this.hasAttribute(args[0], args[1], args[2]);
        this.constraints.push([command, ...args]);
        break;
      
      case 'setAttributeOR':
        this.setAttributeOR(args[0], args[1]);
        this.constraints.push([command, ...args]);
        break;
      
      case 'hasType':
        this.hasType(args[0], args[1]);
        this.constraints.push([command, ...args]);
        break;
      
      case 'hasChild':
        this.hasChild(args[0], args[1]);
        this.constraints.push([command, ...args]);
        break;
      
      case 'hasSibiling':
        this.hasSibiling(args[0], args[1]);
        this.constraints.push([command, ...args]);
        break;

      default:
        throw new Error(`Unknown command: ${command}`);
    }
  }

  /**
   * Sets the specified node as the root node.
   * @param {string} nodeIdentifier - The unique ID for the node.
   */
  setAsRoot(nodeIdentifier) {
    if (!this.DOMSymbols[nodeIdentifier]) {
      throw new Error(`Node with identifier ${nodeIdentifier} does not exist.`);
    }

    // If a root node already exists, unmark it as root
    if (this.rootNode) {
      this.rootNode.isRoot = false;
    }

    // Set the new root node
    const node = this.DOMSymbols[nodeIdentifier];
    node.setAsRoot();
    this.rootNode = node;
  }

  checkFromString(value){
    if (value.startsWith('$')){
      var tmp = this.stringSymbols[value];
      var tmpConstant = this.stringConstants[value];
      if (!tmp && !tmpConstant){
        throw new Error(`A string ${value} is used before definition.`);
      }
      else{
        if (tmp){
          value = tmp;
        }
        else if(tmpConstant){
          value = tmpConstant;
        }
      }
    }
    return value
  }
  /**
   * Adds an attribute to the specified node.
   * 
   * @param {string} nodeIdentifier - The unique ID for the node.
   * @param {string} attributeName - The name of the attribute.
   * @param {string} attributeValue - The value of the attribute.
   */
  hasAttribute(nodeIdentifier, attributeName, attributeValue) {
    if (!this.DOMSymbols[nodeIdentifier]) {
      throw new Error(`Node with identifier ${nodeIdentifier} does not exist.`);
    }

    const node = this.DOMSymbols[nodeIdentifier];
    attributeName = this.checkFromString(attributeName);
    attributeValue = this.checkFromString(attributeValue);
    node.setAttribute(attributeName, attributeValue);
  }

  setAttributeOR(nodeIdentifier, attributePairs) {
    if (!this.DOMSymbols[nodeIdentifier]) {
      throw new Error(`Node with identifier ${nodeIdentifier} does not exist.`);
    }

    const node = this.DOMSymbols[nodeIdentifier];
    node.setAttributeOR(attributePairs);
  }

  /**
   * Adds a type to the specified node.
   * 
   * @param {string} nodeIdentifier - The unique ID for the node.
   * @param {string} nodeType - The type of the node.
   */
  hasType(nodeIdentifier, nodeType) {
    if (!this.DOMSymbols[nodeIdentifier]) {
      throw new Error(`Node with identifier ${nodeIdentifier} does not exist.`);
    }

    const node = this.DOMSymbols[nodeIdentifier];

    // We support multiple types for a node.
    if (Array.isArray(nodeType)) {
      nodeType.forEach(type => node.setType(type));
    } else {
      node.setType(nodeType);
    }
  }

  /**
   * Adds a child to the specified node.
   * 
   * @param {string} parentNodeIdentifier - The unique ID for the parent node.
   * @param {string} childNodeIdentifier - The unique ID for the child node.
   */
  hasChild(parentNodeIdentifier, childNodeIdentifier) {
    if (!this.DOMSymbols[parentNodeIdentifier]) {
      throw new Error(`Node with identifier ${parentNodeIdentifier} does not exist.`);
    }

    if (!this.DOMSymbols[childNodeIdentifier]) {
      throw new Error(`Node with identifier ${childNodeIdentifier} does not exist.`);
    }

    const parentNode = this.DOMSymbols[parentNodeIdentifier];
    const childNode = this.DOMSymbols[childNodeIdentifier];
    parentNode.addChild(childNode);
    childNode.parent = parentNode;
  }

  /**
   * Adds a sibiling to the specified node.
   * 
   * @param {string} siblingNodeIdentifier - The unique ID for the sibling node.
   * @param {string} parentNodeIdentifier - The unique ID for the parent node.
   */
  hasSibiling(parentNodeIdentifier, siblingNodeIdentifier) {
    if (!this.DOMSymbols[siblingNodeIdentifier]) {
      throw new Error(`Node with identifier ${siblingNodeIdentifier} does not exist.`);
    }

    if (!this.DOMSymbols[parentNodeIdentifier]) {
      throw new Error(`Node with identifier ${parentNodeIdentifier} does not exist.`);
    }

    const siblingNode = this.DOMSymbols[siblingNodeIdentifier];
    const parentNode = this.DOMSymbols[parentNodeIdentifier];

    if (parentNode.isRoot) {
      this.topLevelSibilingNodes.push(siblingNode);
    } else if (parentNode.parent) {
      parentNode.addSibiling(siblingNode);
    } else {
      throw new Error(`Parent node ${parentNodeIdentifier} does not have a parent.`);
    }
  }

  /**
   * Generates the exploit DOM tree.
   * @returns {Array<string>} - An array of HTML strings representing the possible DOM trees.
   */
  concreteToString() {
    let rootVNodeList = this.rootNode.concreteToVNode();
    if (!this.rootNode.nodeTypes.length) {
      // this.rootNode['nodeTypes'] = ['anything'];
      this.rootNode['nodeTypes'] = ['anything']; 
      rootVNodeList = this.rootNode.concreteToVNode();
    }
    const siblingVNodeCombinations = this.topLevelSibilingNodes.map(sibling => sibling.concreteToVNode());
    function cartesianProduct(arrays) {
        return arrays.reduce((acc, array) => {
            return acc.flatMap(d => array.map(e => [...d, e]));
        }, [[]]);
    }

    const allCombinations = cartesianProduct([rootVNodeList, ...siblingVNodeCombinations]);
    const htmlStrings = allCombinations.map(vnodeCombination => {
      return vnodeCombination.map(vnode => { return toHTML(vnode); }).join('\n');
    });

    return htmlStrings;
  }
}

// let symbolicDOMTree = new SymbolicDOMTree();
// // symbolicDOMTree.declareNode('$node1');
// symbolicDOMTree.declareNode('$node2');
// symbolicDOMTree.declareString('$payload');
// symbolicDOMTree.addConstraint('isRoot', '$node2');
// // symbolicDOMTree.addConstraint('hasSibiling', '$node1', '$node2');
// // symbolicDOMTree.addConstraint('hasType', '$node1', ['a', 'area']);
// symbolicDOMTree.addConstraint('hasType', '$node2', ['a', 'area']);
// // symbolicDOMTree.addConstraint('hasAttribute', '$node1', 'id', 'MathJax');
// // symbolicDOMTree.addConstraint('hasAttribute', '$node2', 'id', 'MathJax');
// // symbolicDOMTree.addConstraint('hasAttribute', '$node2', 'name', 'root');
// symbolicDOMTree.addConstraint('hasAttribute', '$node2', 'href', '$payload');

// console.log(symbolicDOMTree.concreteToString());