import { JSDOM } from 'jsdom';
import { SymbolicDOMNode } from './symbolic-dom-node.js';

/**
 * The exploit DOM tree holder.
 * 
 * The class object represents the symbolic DOM tree that satisfies the imposed constraints for the exploit.
 * Note that, the DOMClobberingExp = a set of possible DOM trees that satisfy the constraints.
 * 
 */
export class SymbolicDOMTree {
  constructor() {
    this.constraints = [];
    this.DOMSymbols = {};
    this.stringSymbols = {};

    this.rootNode = null;
  }

  /**
   * Declares a new DOM node with a specific type.
   * If nodeType is "*", it will consider all possible node types.
   * @param {string} nodeType - The type of the DOM node (e.g., 'div', 'iframe', or '*').
   * @param {string} nodeId - The unique ID for the node (for internal reference). The ID should be unique within the tree.
   */
  declareNode(nodeIdentifier) {
    if (this.DOMSymbols[nodeIdentifier]) {
      throw new Error(`Node with identifier ${nodeIdentifier} already exists.`);
    }
    this.DOMSymbols[nodeIdentifier] = new SymbolicDOMNode();   
  }

  /**
   * Declares a new string symbol.
   * @param {string} stringIdentifier - The unique ID for the string (for internal reference).
   */
  declareString(stringIdentifier) {
    if (this.stringSymbols[stringIdentifier]) {
      throw new Error(`String with identifier ${stringIdentifier} already exists.`);
    }

    this.stringSymbols[stringIdentifier] = Symbol();
  }

  /**
   * Adds a constraint to the symbolic DOM tree.
   * @param {string} command - The constraint command (e.g., 'isRoot').
   * @param  {...any} args - Arguments for the command.
   */
  addConstraint(command, ...args) {
    switch (command) {
      case 'isRoot': 
        this.setAsRoot(args[0]);
        this.constraints.push([command, ...args]);
        break;

      default:
        throw new Error(`Unknown command: ${command}`);
    }
  }

  /**
   * Sets the specified node as the root node.
   * @param {string} nodeIdentifier - The unique ID for the node.
   */
  setAsRoot(nodeIdentifier) {
    if (!this.DOMSymbols[nodeIdentifier]) {
      throw new Error(`Node with identifier ${nodeIdentifier} does not exist.`);
    }

    // If a root node already exists, unmark it as root
    if (this.rootNode) {
      this.rootNode.isRoot = false;
    }

    // Set the new root node
    const node = this.DOMSymbols[nodeIdentifier];
    node.setAsRoot();
    this.rootNode = node;
  }

  /**
   * Generates the exploit DOM tree.
   */
  concrete() {
    debugger;
  }
}

let symbolicDOMTree = new SymbolicDOMTree();
symbolicDOMTree.declareNode('node1');
symbolicDOMTree.declareNode('node2');
symbolicDOMTree.addConstraint('isRoot', 'node1');
symbolicDOMTree.concrete();