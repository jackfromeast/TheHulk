import { JSDOM } from 'jsdom';
import { SymbolicDOMNode } from './symbolic-dom-node.js';
import { Utils } from "./utils.js";
import { h, create } from 'virtual-dom';
import toHTML from 'vdom-to-html';

/**
 * The exploit DOM tree holder.
 * 
 * The class object represents the symbolic DOM tree that satisfies the imposed constraints for the exploit.
 * Note that, the DOMClobberingExp = a set of possible DOM trees that satisfy the constraints.
 * 
 */
export class SymbolicDOMTree {
  constructor() {
    this.constraints = [];
    this.DOMSymbols = {};
    this.stringSymbols = {};

    this.rootNode = null;

    // The lower-level sibling nodes can be set as children of shared parent nodes.
    this.topLevelSibilingNodes = [];
  }

  /**
   * Declares a new DOM node with a specific type.
   * If nodeType is "*", it will consider all possible node types.
   * @param {string} nodeType - The type of the DOM node (e.g., 'div', 'iframe', or '*').
   * @param {string} nodeId - The unique ID for the node (for internal reference). The ID should be unique within the tree.
   */
  declareNode(nodeIdentifier) {
    if (this.DOMSymbols[nodeIdentifier]) {
      throw new Error(`Node with identifier ${nodeIdentifier} already exists.`);
    } else if (!nodeIdentifier.startsWith('$')) {
      throw new Error(`Node identifier ${nodeIdentifier} should start with '$'.`);
    }
    this.DOMSymbols[nodeIdentifier] = new SymbolicDOMNode();   
  }

  /**
   * Declares a new string symbol.
   * @param {string} stringIdentifier - The unique ID for the string (for internal reference).
   */
  declareString(stringIdentifier) {
    if (this.stringSymbols[stringIdentifier]) {
      throw new Error(`String with identifier ${stringIdentifier} already exists.`);
    } else if (!stringIdentifier.startsWith('$')) {
      throw new Error(`Node identifier ${nodeIdentifier} should start with '$'.`);
    }

    this.stringSymbols[stringIdentifier] = Symbol();
  }

  /**
   * Adds a constraint to the symbolic DOM tree.
   * @param {string} command - The constraint command (e.g., 'isRoot').
   * @param  {...any} args - Arguments for the command.
   */
  addConstraint(command, ...args) {
    switch (command) {
      case 'isRoot': 
        this.setAsRoot(args[0]);
        this.constraints.push([command, ...args]);
        break;
      
      case 'hasAttribute':
        this.hasAttribute(args[0], args[1], args[2]);
        this.constraints.push([command, ...args]);
        break;
      
      case 'hasType':
        this.hasType(args[0], args[1]);
        this.constraints.push([command, ...args]);
        break;
      
      case 'hasChild':
        this.hasChild(args[0], args[1]);
        this.constraints.push([command, ...args]);
        break;
      
      case 'hasSibiling':
        this.hasSibiling(args[0], args[1]);
        this.constraints.push([command, ...args]);
        break;

      default:
        throw new Error(`Unknown command: ${command}`);
    }
  }

  /**
   * Sets the specified node as the root node.
   * @param {string} nodeIdentifier - The unique ID for the node.
   */
  setAsRoot(nodeIdentifier) {
    if (!this.DOMSymbols[nodeIdentifier]) {
      throw new Error(`Node with identifier ${nodeIdentifier} does not exist.`);
    }

    // If a root node already exists, unmark it as root
    if (this.rootNode) {
      this.rootNode.isRoot = false;
    }

    // Set the new root node
    const node = this.DOMSymbols[nodeIdentifier];
    node.setAsRoot();
    this.rootNode = node;
  }

  /**
   * Adds an attribute to the specified node.
   * 
   * @param {string} nodeIdentifier - The unique ID for the node.
   * @param {string} attributeName - The name of the attribute.
   * @param {string} attributeValue - The value of the attribute.
   */
  hasAttribute(nodeIdentifier, attributeName, attributeValue) {
    if (!this.DOMSymbols[nodeIdentifier]) {
      throw new Error(`Node with identifier ${nodeIdentifier} does not exist.`);
    }

    const node = this.DOMSymbols[nodeIdentifier];
    if (this.stringSymbols[attributeValue]) {
      attributeValue = "*"; // A declared string symbol represents any string value.
    }

    node.setAttribute(attributeName, attributeValue);
  }

  /**
   * Adds a type to the specified node.
   * 
   * @param {string} nodeIdentifier - The unique ID for the node.
   * @param {string} nodeType - The type of the node.
   */
  hasType(nodeIdentifier, nodeType) {
    if (!this.DOMSymbols[nodeIdentifier]) {
      throw new Error(`Node with identifier ${nodeIdentifier} does not exist.`);
    }

    const node = this.DOMSymbols[nodeIdentifier];
    node.setType(nodeType);
  }

  /**
   * Adds a child to the specified node.
   * 
   * @param {string} parentNodeIdentifier - The unique ID for the parent node.
   * @param {string} childNodeIdentifier - The unique ID for the child node.
   */
  hasChild(parentNodeIdentifier, childNodeIdentifier) {
    if (!this.DOMSymbols[parentNodeIdentifier]) {
      throw new Error(`Node with identifier ${parentNodeIdentifier} does not exist.`);
    }

    if (!this.DOMSymbols[childNodeIdentifier]) {
      throw new Error(`Node with identifier ${childNodeIdentifier} does not exist.`);
    }

    const parentNode = this.DOMSymbols[parentNodeIdentifier];
    const childNode = this.DOMSymbols[childNodeIdentifier];
    parentNode.addChild(childNode);
    childNode.parent = parentNode;
  }

  /**
   * Adds a sibiling to the specified node.
   * 
   * @param {string} siblingNodeIdentifier - The unique ID for the sibling node.
   * @param {string} parentNodeIdentifier - The unique ID for the parent node.
   */
  hasSibiling(parentNodeIdentifier, siblingNodeIdentifier) {
    if (!this.DOMSymbols[siblingNodeIdentifier]) {
      throw new Error(`Node with identifier ${siblingNodeIdentifier} does not exist.`);
    }

    if (!this.DOMSymbols[parentNodeIdentifier]) {
      throw new Error(`Node with identifier ${parentNodeIdentifier} does not exist.`);
    }

    const siblingNode = this.DOMSymbols[siblingNodeIdentifier];
    const parentNode = this.DOMSymbols[parentNodeIdentifier];

    if (parentNode.isRoot) {
      this.topLevelSibilingNodes.push(siblingNode);
    } else if (parentNode.parent) {
      parentNode.addSibiling(siblingNode);
    } else {
      throw new Error(`Parent node ${parentNodeIdentifier} does not have a parent.`);
    }
  }

  /**
   * Generates the exploit DOM tree.
   * @returns {Array<string>} - An array of HTML strings representing the possible DOM trees.
   */
  concreteToString() {
    const rootVNodeList = this.rootNode.concreteToVNode();

    const siblingVNodeCombinations = this.topLevelSibilingNodes.map(sibling => sibling.concreteToVNode());
    function cartesianProduct(arrays) {
        return arrays.reduce((acc, array) => {
            return acc.flatMap(d => array.map(e => [...d, e]));
        }, [[]]);
    }

    const allCombinations = cartesianProduct([rootVNodeList, ...siblingVNodeCombinations]);
    const htmlStrings = allCombinations.map(vnodeCombination => {
      return vnodeCombination.map(vnode => { return toHTML(vnode); }).join('\n');
    });

    return htmlStrings;
  }
}

let symbolicDOMTree = new SymbolicDOMTree();
symbolicDOMTree.declareNode('$node1');
symbolicDOMTree.declareNode('$node2');
symbolicDOMTree.declareString('$Payload');
symbolicDOMTree.addConstraint('isRoot', '$node1');
symbolicDOMTree.addConstraint('hasSibiling', '$node1', '$node2');
symbolicDOMTree.addConstraint('hasType', '$node1', 'a');
symbolicDOMTree.addConstraint('hasType', '$node2', 'a');
// or
symbolicDOMTree.addConstraint('hasType', '$node1', 'area');
symbolicDOMTree.addConstraint('hasType', '$node2', 'area');
symbolicDOMTree.addConstraint('hasAttribute', '$node1', 'id', 'MathJax');
symbolicDOMTree.addConstraint('hasAttribute', '$node2', 'id', 'MathJax');
symbolicDOMTree.addConstraint('hasAttribute', '$node2', 'name', 'root');
symbolicDOMTree.addConstraint('hasAttribute', '$node2', 'href', '$Payload');

console.log(symbolicDOMTree.concreteToString());