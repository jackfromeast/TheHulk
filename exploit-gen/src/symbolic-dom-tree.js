import { JSDOM } from 'jsdom';
import { SymbolicDOMNode } from './symbolic-dom-node.js';
import { Utils } from "./utils.js";
import { h, create } from 'virtual-dom';
import toHTML from 'vdom-to-html';
import { UnitClause, CompoundClause, ClauseBuilder, RootFormula } from './clause.js';

/**
 * The exploit DOM tree holder.
 * 
 * The class object represents the symbolic DOM tree that satisfies the imposed constraints for the exploit.
 * SymbolicDOMTree represents a root formula (only contains one root node) and a set of constraints.
 * 
 * lazyConstraints is a set of constraints that are not checked until a new node is added to the tree.
 * For example, forall(getSiblings(R1), tempCompundClause) is a lazy constraint.
 * We first add one R2 as R1's sibling and add tempCompundClause to R2.
 * If R2 is not enough or new nodes are added to the tree, we will check the tempCompundClause towards them.
 */
export class SymbolicDOMTree {
  constructor() {
    this.id = Symbol();
    this.constraints = null;
    this.lazyConstraints = null;
    this.DOMSymbols = {};
    this.stringSymbols = {};

    this.rootNode = null;

    // The lower-level sibling nodes can be set as children of shared parent nodes.
    this.topLevelSibilingNodes = [];
  }

  /**
   * Declares a new DOM node with a specific type.
   * If nodeType is "*", it will consider all possible node types.
   * @param {string} nodeType - The type of the DOM node (e.g., 'div', 'iframe', or '*').
   * @param {string} nodeId - The unique ID for the node (for internal reference). The ID should be unique within the tree.
   */
  declareNode(nodeIdentifier) {
    if (this.DOMSymbols[nodeIdentifier]) {
      throw new Error(`Node with identifier ${nodeIdentifier} already exists.`);
    }
    this.DOMSymbols[nodeIdentifier] = new SymbolicDOMNode();   
  }

  /**
   * Declares a new string symbol.
   * @param {string} stringIdentifier - The unique ID for the string (for internal reference).
   */
  declareString(stringIdentifier) {
    if (this.stringSymbols[stringIdentifier]) {
      throw new Error(`String with identifier ${stringIdentifier} already exists.`);
    }

    this.stringSymbols[stringIdentifier] = Symbol();
  }

  /**
   * Adds a constraint to the symbolic DOM tree.
   * @param {string} operator - The operator for the constraint. and, or, not.
   * @param {UnitClause|CompoundClause} constraint - The constraint to add.
   * 
   */
  addConstraint(operator, constraint) {
    if (this.constraints == null) {
      this.constraints = constraint;
      return;
    }

    if (this.constraints instanceof UnitClause) {
      this.constraints = new CompoundClause(operator, [this.constraints, constraint]);
      return;
    }

    if (this.constraints instanceof CompoundClause && this.constraints.operator === operator) {
      this.constraints.andNewClause(constraint);
    } else {
      this.constraints = new CompoundClause(operator, [this.constraints, constraint]);
    }
  }

  getRootFormula() {
    if (this.constraints instanceof CompoundClause) {
      return new RootFormula(this.id, this.constraints);
    } else {
      throw new Error(`Invalid constraint type: ${this.constraints}`);
    }
  }

  /**
   * Adds a lazy constraint to the symbolic DOM tree.
   */
  addLazyConstraint(operator, constraint) {
    // Not implemented yet.
  }

  /**
   * Sets the specified node as the root node.
   * @param {string} nodeIdentifier - The unique ID for the node.
   */
  setAsRoot(nodeIdentifier) {
    if (!this.DOMSymbols[nodeIdentifier]) {
      throw new Error(`Node with identifier ${nodeIdentifier} does not exist.`);
    }

    // If a root node already exists, unmark it as root
    if (this.rootNode) {
      this.rootNode.isRoot = false;
    }

    // Set the new root node
    const node = this.DOMSymbols[nodeIdentifier];
    node.setAsRoot();
    this.rootNode = node;
  }

  /**
   * Adds an attribute to the specified node.
   * 
   * @param {string} nodeIdentifier - The unique ID for the node.
   * @param {string} attributeName - The name of the attribute.
   * @param {string} attributeValue - The value of the attribute.
   */
  hasAttribute(nodeIdentifier, attributeName, attributeValue) {
    if (!this.DOMSymbols[nodeIdentifier]) {
      throw new Error(`Node with identifier ${nodeIdentifier} does not exist.`);
    }

    const node = this.DOMSymbols[nodeIdentifier];
    node.setAttribute(attributeName, attributeValue);
  }

  setAttributeOR(nodeIdentifier, attributePairs) {
    if (!this.DOMSymbols[nodeIdentifier]) {
      throw new Error(`Node with identifier ${nodeIdentifier} does not exist.`);
    }

    const node = this.DOMSymbols[nodeIdentifier];
    node.setAttributeOR(attributePairs);
  }

  /**
   * Adds a type to the specified node.
   * 
   * @param {string} nodeIdentifier - The unique ID for the node.
   * @param {string} nodeType - The type of the node.
   */
  hasType(nodeIdentifier, nodeType) {
    if (!this.DOMSymbols[nodeIdentifier]) {
      throw new Error(`Node with identifier ${nodeIdentifier} does not exist.`);
    }

    const node = this.DOMSymbols[nodeIdentifier];

    // We support multiple types for a node.
    if (Array.isArray(nodeType)) {
      nodeType.forEach(type => node.setType(type));
    } else {
      node.setType(nodeType);
    }
  }

  /**
   * Adds a child to the specified node.
   * 
   * @param {string} parentNodeIdentifier - The unique ID for the parent node.
   * @param {string} childNodeIdentifier - The unique ID for the child node.
   */
  hasChild(parentNodeIdentifier, childNodeIdentifier) {
    if (!this.DOMSymbols[parentNodeIdentifier]) {
      throw new Error(`Node with identifier ${parentNodeIdentifier} does not exist.`);
    }

    if (!this.DOMSymbols[childNodeIdentifier]) {
      throw new Error(`Node with identifier ${childNodeIdentifier} does not exist.`);
    }

    const parentNode = this.DOMSymbols[parentNodeIdentifier];
    const childNode = this.DOMSymbols[childNodeIdentifier];
    parentNode.addChild(childNode);
    childNode.parent = parentNode;
  }

  /**
   * Adds a sibiling to the specified node.
   * 
   * @param {string} siblingNodeIdentifier - The unique ID for the sibling node.
   * @param {string} parentNodeIdentifier - The unique ID for the parent node.
   */
  hasSibiling(parentNodeIdentifier, siblingNodeIdentifier) {
    if (!this.DOMSymbols[siblingNodeIdentifier]) {
      throw new Error(`Node with identifier ${siblingNodeIdentifier} does not exist.`);
    }

    if (!this.DOMSymbols[parentNodeIdentifier]) {
      throw new Error(`Node with identifier ${parentNodeIdentifier} does not exist.`);
    }

    const siblingNode = this.DOMSymbols[siblingNodeIdentifier];
    const parentNode = this.DOMSymbols[parentNodeIdentifier];

    if (parentNode.isRoot) {
      this.topLevelSibilingNodes.push(siblingNode);
    } else if (parentNode.parent) {
      parentNode.addSibiling(siblingNode);
    } else {
      throw new Error(`Parent node ${parentNodeIdentifier} does not have a parent.`);
    }
  }

  /**
   * Generates the exploit DOM tree.
   * @returns {Array<string>} - An array of HTML strings representing the possible DOM trees.
   */
  concreteToString() {
    const rootVNodeList = this.rootNode.concreteToVNode();

    const siblingVNodeCombinations = this.topLevelSibilingNodes.map(sibling => sibling.concreteToVNode());
    function cartesianProduct(arrays) {
        return arrays.reduce((acc, array) => {
            return acc.flatMap(d => array.map(e => [...d, e]));
        }, [[]]);
    }

    const allCombinations = cartesianProduct([rootVNodeList, ...siblingVNodeCombinations]);
    const htmlStrings = allCombinations.map(vnodeCombination => {
      return vnodeCombination.map(vnode => { return toHTML(vnode); }).join('\n');
    });

    return htmlStrings;
  }
}

// let symbolicDOMTree = new SymbolicDOMTree();
// symbolicDOMTree.declareNode('$node1');
// symbolicDOMTree.declareNode('$node2');
// symbolicDOMTree.declareString('$payload');
// symbolicDOMTree.addConstraint('isRoot', '$node1');
// symbolicDOMTree.addConstraint('hasSibiling', '$node1', '$node2');
// symbolicDOMTree.addConstraint('hasType', '$node1', ['a', 'area']);
// symbolicDOMTree.addConstraint('hasType', '$node2', ['a', 'area']);
// symbolicDOMTree.addConstraint('hasAttribute', '$node1', 'id', 'MathJax');
// symbolicDOMTree.addConstraint('hasAttribute', '$node2', 'id', 'MathJax');
// symbolicDOMTree.addConstraint('hasAttribute', '$node2', 'name', 'root');
// symbolicDOMTree.addConstraint('hasAttribute', '$node2', 'href', '$payload');

// console.log(symbolicDOMTree.concreteToString());