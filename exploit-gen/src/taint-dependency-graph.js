import { Utils } from './utils.js';
import { SymbolicDOMTree } from './symdom-tree.js';

/**
 * Taint Dependency Graph
 * 
 * A graph-based program slicing with concrete values of the taint trace.
 * 
 * We use context to represents differnet modeling of exploitation under the same TDG.
 * A operationNode could has different context for different objectives, therefore,
 * each TaintedValueNode could be attached with different SymbolicTree objects.
 * 
 * @param {Array[Object]} taintTrace - A list of taint propagation operations.
 */
export class TaintDependencyGraph {
  constructor(taintTrace) {
    this.rawTrace = taintTrace;
    this.operationNodes = [];
    this.taintedValueNodes = [];
    this.context = [];
    this.buildGraph();
  }

  /**
   * Builds the graph from the taint trace.
   * The graph consists of OperationNodes and ValueNodes (TaintedValueNodes).
   * 
   * TODO: Currently, we don't support operations that have multiple tainted values, aka. MultiTaintPropOperation
   */
  buildGraph() {
    let previousNode = null;

    // Iterate the raw trace from back to front
    for (let i = this.rawTrace.length - 1; i >= 0; i--) {
      const taintOperation = this.rawTrace[i];

      // Create a new empty operation node
      const operationNode = new OperationNode(taintOperation);

      // Determine the tainted value nodes of the current operation node
      let currentTaintedValueNode = null;
      if (taintOperation.indicator === "base") {
        operationNode.base = new TaintedValueNode(taintOperation.base);
        currentTaintedValueNode = operationNode.base;
      } else {
        operationNode.base = new ValueNode(taintOperation.base);
      }

      for (let index = 0; index < taintOperation.arguments.length; index++) {
        if (taintOperation.indicator === `arg${index}`) {
          operationNode.arguments.set(`arg${index}`, new TaintedValueNode(taintOperation.arguments[index]));
          currentTaintedValueNode = operationNode.arguments.get(`arg${index}`);
        } else {
          operationNode.arguments.set(`arg${index}`, new ValueNode(taintOperation.arguments[index]));
        }
      }

      if (previousNode) {
        previousNode.return = currentTaintedValueNode;
        previousNode.nextOperation = operationNode;
      }

      this.operationNodes.push(operationNode);
      if (currentTaintedValueNode !== null) {
        this.taintedValueNodes.push(currentTaintedValueNode);
      }
      previousNode = operationNode;
    }
  }

  /**
   * Attaches objectives to the operation nodes based on the generated objective map.
   * 
   * @param {Map} objectiveMap - A map of objectives for each operation node under different contexts.
   */
  attachObjectives(objectiveMap) {
    for (const [contextId, objectives] of objectiveMap) {
      for (let index = 0; index < objectives.length; index++) {
        const operationNode = this.operationNodes[index];
        const objective = objectives[index];

        if (operationNode) {
          operationNode.addObjective(contextId, objective.objectives);
        }

        if (operationNode.base instanceof TaintedValueNode && !operationNode.base.getSymbolicDOM(contextId)) {
          operationNode.base.attachSymbolicDOM(contextId, new SymbolicDOMTree());
        }

        for (const [argKey, argNode] of operationNode.arguments.entries()) {
          if (argNode instanceof TaintedValueNode && !argNode.getSymbolicDOM(contextId)) {
            argNode.attachSymbolicDOM(contextId, new SymbolicDOMTree());
          }
        }

        if (operationNode.return instanceof TaintedValueNode && !operationNode.return.getSymbolicDOM(contextId)) {
          operationNode.return.attachSymbolicDOM(contextId, new SymbolicDOMTree());
        }
      }
    }
  }

  /**
   * Attaches objectives to the operation nodes.
   * Five types of objectives:
   * - "Document-to-DOM"
   * - "Window-to-DOM"
   * - "DOM-to-DOM"
   * - "DOM-to-String"
   * - "String-to-String"
   * 
   * Rules:
   * 1/ All the operation nodes under the same context should cover the four stages (two are optional) sequentially.
   *    "Document-to-DOM"/"Window-to-DOM" -> "DOM-to-DOM" -> "DOM-to-String" -> "String-to-String"
   *    "Document-to-DOM"/"Window-to-DOM" -> "DOM-to-String" -> "String-to-String"
   *    "Document-to-DOM"/"Window-to-DOM" -> "DOM-to-String"
   * 2/ Only certain operation nodes can achieve the objectives.
   *    - Document-to-DOM"/"Window-to-DOM: getField, VarRef
   *    - DOM-to-DOM: getField
   *    - DOM-to-String: getField, BinaryOps:+, InvokeFunc
   * 
   * @returns {Map} A map of objectives for each operation node under different context.
   */
  modelObjectives() {
    const objectiveMap = new Map();

    // Top-down to generate objectives & diverge contexts
    let currentContext = "context1";
    objectiveMap.set(currentContext, []);
    let contextCounter = 1;
    let contextQueue = [{ id: currentContext, currentStage: "Initial", index: -1}];

    while (contextQueue.length > 0) {
      const currentContextObj = contextQueue.shift();
      let { id, currentStage, index} = currentContextObj;

      index = index + 1;
      if (index >= this.operationNodes.length) {
        continue;
      }
      const nodeType = this.operationNodes[index].type;

      let nextStages = [];
      if (index === 0) {
        nextStages = this.operationNodes[0].base.value === "HTMLDocument" ?  ["Document-to-DOM"] : ["Window-to-DOM"];
      } else {
        nextStages = this.getNextStage(currentStage, nodeType);
      }

      if (nextStages.length === 0) {
        continue;
      }
    
      objectiveMap.get(id).push({ node: nodeType, objectives: nextStages[0]});
      contextQueue.push({ id, currentStage: nextStages[0], index: index});
      
      for (let i = 1; i < nextStages.length; i++) {
        const newContextId = `context${++contextCounter}`;

        // Copy the existing objectives to the new context
        objectiveMap.set(newContextId, objectiveMap.get(id).slice(0, -1));
        objectiveMap.get(newContextId).push({ node: nodeType, objectives: nextStages[i]});

        contextQueue.push({ id: newContextId, currentStage: nextStages[i], index: index});
      }
    }

    // Check & Clean up
    // 1/ The objectives should cover all the stages
    // 2/ Each operation node should have one objective
    let renamedContextCounter = 1;
    const renamedObjectiveMap = new Map();

    for (const [contextId, objectives] of objectiveMap) {
      const coveredStages = new Set(objectives.map(obj => obj.objectives));
      const hasDocumentOrWindow = coveredStages.has("Document-to-DOM") || coveredStages.has("Window-to-DOM");
      const hasDomToString = coveredStages.has("DOM-to-String");

      if (!hasDocumentOrWindow || !hasDomToString ||
         (objectives.length !== this.operationNodes.length))
      {
        objectiveMap.delete(contextId);
      } else {
        const newContextId = `context${renamedContextCounter++}`;
        renamedObjectiveMap.set(newContextId, objectives);
      }
    }

    return renamedObjectiveMap;
  }

  // Operations that are valid for each stage
  validOperations = {
    "Document-to-DOM": ["getField", "VarRef"],
    "Window-to-DOM": ["getField", "VarRef"],
    "DOM-to-DOM": ["getField"],
    "DOM-to-String": ["getField", "BinaryOps:+", "InvokeFunc"],
    "String-to-String": ["BinaryOps:+"],
  };

  /**
   * Determines the next valid stages based on the current stage and the node type.
   * Filters stages from the stage map using the valid operations for the given node type.
   *
   * @param {string} currentStage - The current stage of the operation.
   * @param {string} nodeType - The type of the node to evaluate against valid operations.
   * @returns {Array<string>} - An array of valid next stages for the given node type.
   */
  getNextStage(currentStage, nodeType) {
    // Map defining possible transitions between stages
    const stageMap = {
      "Initial": ["Document-to-DOM", "Window-to-DOM"],
      "Document-to-DOM": ["DOM-to-DOM", "DOM-to-String"],
      "Window-to-DOM": ["DOM-to-DOM", "DOM-to-String"],
      "DOM-to-DOM": ["DOM-to-DOM", "DOM-to-String"],
      "DOM-to-String": ["String-to-String"],
      "String-to-String": ["String-to-String"],
    };

    const potentialNextStages = stageMap[currentStage] || [];

    const validNextStages = potentialNextStages.filter((stage) => {
      return this.validOperations[stage]?.includes(nodeType);
    });

    return validNextStages.length > 0 ? validNextStages : [];
  }

  /**
   * Prints the graph in a readable format.
   */
  printGraph() {
    console.log("Taint Dependency Graph:");
    console.log("========================");

    for (const node of this.operationNodes) {
      console.log(`Operation: ${node.type}`);
      console.log(`  Raw Data: ${JSON.stringify(node.rawData)}`);
      console.log(`  Base: ${node.base ? `${node.base.type} ${node.base.value}` : "null"}`);
      console.log("  Arguments:");
      for (const [key, arg] of node.arguments.entries()) {
        console.log(`    ${key}: ${arg.type} ${arg.value}`);
      }
      console.log(`  Return: ${node.return ? `${node.return.type} ${node.return.value}` : "null"}`);
      console.log(`  Next Operation: ${node.nextOperation ? node.nextOperation.type : "null"}`);

      console.log("  Objectives:");
      for (const [context, objectives] of node.objectives.entries()) {
        console.log(`    Context: ${context}`);
        console.log(`    Objectives: ${objectives}`);
      }
      console.log("------------------------");
    }

    console.log("Tainted Value Nodes:");
    console.log("========================");
    for (const node of this.taintedValueNodes) {
      console.log(`  Tainted Value: ${node.type} ${node.value}`);
      console.log("  Context Tags:");
      for (const [context, symdom] of node.contextTags.entries()) {
        console.log(`    Context: ${context}`);
        console.log(`    SymDOM: ${JSON.stringify(symdom)}`);
      }
    }
  }
}

class OperationNode {
  constructor(taintOperation) {
    this.rawData = taintOperation;
    this.type = taintOperation.operation;
    this.objectives = new Map();
    this.base = null;
    this.arguments = new Map();
    this.return = null;
    this.nextOperation = null;
  }

  /**
   * Attaches an objective to the operation node for a specific context.
   * @param {string} contextId - The context name (e.g., context1, context2).
   * @param {string} objective - The objective to attach.
   */
  addObjective(contextId, objective) {
    this.objectives.set(contextId, objective);
  }

  /**
   * Retrieves the objectives for a specific context.
   * @param {string} contextId - The context name.
   * @returns {Array<string>} Objectives for the context.
   */
  getObjectives(contextId) {
    return this.objectives.get(contextId) || [];
  }
}

class ValueNode {
  constructor(value) {
    this.rawData = value;
    this.tainted = false;
    const { type:t, value:v } = this.parseValue(value);
    this.type = t;
    this.value = v;
  }

  /**
   * Parses the input value into its type and value.
   *
   * Examples:
   * - "[object Window]" -> { type: "Window", value: "Object" }
   * - "[object HTMLDivElement]" -> { type: "HTMLDivElement", value: "Object" }
   * - "HELLOWORLD" -> { type: "String", value: "HELLOWORLD" }
   * - 123 -> { type: "Number", value: 123 }
   * - null -> { type: "Null", value: null }
   * - undefined -> { type: "Undefined", value: undefined }
   *
   * @param {any} value - The value to parse.
   * @returns {Object} An object containing the parsed type and value.
   */
  parseValue(value) {
    if (value === "null") {
      return { type: "Null", value: value };
    }
    if (value === undefined) {
      return { type: "Undefined", value: value };
    }
    if (!isNaN(value)) {
      return { type: "Number", value: value };
    }
    if (value === "true" || value === "false") {
      return { type: "Boolean", value: value };
    }
    if (value.startsWith("[object ")) {
      let objectValue = value.slice(8, -1);
      return { type: "Object", value: objectValue };
    }
    if (typeof value === "string") {
      return { type: "String", value: value };
    }
    return { type: "Unknown", value: value };
  }
}

/**
 * Represents a tainted value in the taint trace.
 * Each TaintedValueNode should eventually be concretized to a DOM node.
 *
 * @param {any} value - The value of the tainted node.
 */
class TaintedValueNode extends ValueNode {
  constructor(value) {
    super(value);
    this.tainted = true;
    this.constraints = new Map(); // Map<contextId, Array<SymbolicDOMTree>>
  }

  /**
   * Attaches a tag to the tainted value node for a specific context.
   * @param {string} contextId - The context name (e.g., "context1", "context1").
   * @param {any} tag - The tag or metadata to associate with the context.
   */
  attachSymbolicDOM(contextId, symdom) {
    if (!this.constraints.has(contextId)) {
      this.constraints.set(contextId, []);
    }

    this.constraints.get(contextId).push(symdom);
  }

  /**
   * Retrieves the tag for a specific context.
   * @param {string} context - The context name.
   * @returns {any} The tag associated with the context, or null if none exists.
   */
  getSymbolicDOM(contextId) {
    return this.constraints.get(contextId) || [];
  }
}


// Debugging Purpose
// let taintTraces = Utils.readTaintFlows("/home/jackfromeast/Desktop/TheHulk/tasks/run-taint-tracking-dom-clobbering-collection/output/TAINT-TRACKING-DOM-CLOBBERING-COLLECTION-TEST-01-23-16-15/localhost/10282a687e/crawler/taintflows.json");
// const graph = new TaintDependencyGraph(taintTraces[0]);
// graph.attachObjectives(graph.modelObjectives());
// graph.printGraph();