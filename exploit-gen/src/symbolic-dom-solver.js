import { SymbolicDOMTree } from "./symbolic-dom-tree.js";
import { SymbolicDOMTheory } from "./symbolic-dom-theory.js";
import { ClauseBuilder, UnitClause, CompoundClause, RootFormula } from "./clause.js";

/**
 * Represents the symbolic DOM solver. 
 * This class helps represent and reduce constraints to a set of possible symbolic DOM trees.
 *
 * Constraints are expressed as a first-order logic formula composed of unit clauses.
 * A unit clause is a clause that contains exactly one literal.
 * A root formula is a conjunction of unit clauses that contains exactly one isRoot clause.
 * Note that, literal in each unit clause has its own namespace base on which root formula it belongs to.
 */
export class SymbolicDOMSolver {
  constructor() {
    this.rawConstraints = null;
    this.rootFormulas = new Map();
  }

  /**
   * Adds a and constraint to the solver.
   * @param {UnitClause|CompoundClause} constraint - The constraint to add.
   */
  andNewConstraintRaw(verb, ...args) {
    let newUnitClause = new UnitClause(null, verb, ...args); 
    this.andNewConstraint(newUnitClause);
  }

  /**
   * Adds a new and constraint to the solver.
   * @param {*} unitClause 
   */
  andNewConstraint(unitClause) {
    if (!this.rawConstraints) {
      this.rawConstraints = unitClause;
    } else {
      this.rawConstraints = ClauseBuilder.and(this.rawConstraints, unitClause);
    }
  }

  /**
   * Recursively checks and adds a compound constraint.
   * @param {CompoundClause} clauses - The compound clause to add.
   */
  andNewConstraintCompound(clauses) {
    if (!(clauses instanceof CompoundClause)) {
      throw new Error("Expected a CompoundClause instance.");
    }

    const processClause = (clause) => {
      if (clause instanceof RootFormula) {
        if (!this.rootFormulas.has(clause.namespace)) {
          this.rootFormulas.set(clause.namespace, RootFormula);
        }
      } else if (clause instanceof CompoundClause) {
        for (const subClause of clause.clauses) {
          processClause(subClause);
        }
      }
    };
    
    processClause(clauses);
    this.andNewConstraint(clauses);
  }

  /**
   * Add a new root formula to the solver.
   * The constraint is wrapped in a SymbolicDOMTree object, which can be accessed through symDOMTree.constraints.
   * @param {SymbolicDOMTree} symDOMTree 
   */
  andNewRootFormula(symDOMTree) {
    const rootFormula = new RootFormula(symDOMTree.id, symDOMTree.constraints);
    this.rootFormulas.set(symDOMTree.id, [rootFormula, symDOMTree]);

    if (!this.rawConstraints) {
      this.rawConstraints = rootFormula;
    } else {
      this.rawConstraints = ClauseBuilder.and(this.rawConstraints, rootFormula);
    }
  }
  
  /**
   * Make sure the current constraints are in Disjunctive Normal Form (DNF) of root formulas with unit clauses.
   */
  DNFCheck() {
    return true;
  }

  /**
   * Reduce the raw constraints to disjunctive normal form of root formulas.
   */
  reduceToDNF() {
    if (!this.rawConstraints || this.rawConstraints instanceof UnitClause) {
      return;
    }
  
    // If all clauses are root formulas, no reduction is needed
    const containsNonRoot = (clause) => {
      if (clause instanceof RootFormula) {
        return false;
      } else if (clause instanceof CompoundClause) {
        return clause.clauses.some(containsNonRoot);
      }
      return true;
    };
  
    if (!containsNonRoot(this.rawConstraints)) {
      return;
    }
  
    // Convert to Disjunctive Normal Form (DNF) recursively
    const convertToDNF = (clause) => {
      // Traverse the tree to the leaves and apply the distributive law
      let newClause = distributeAndOverOrOneStep(clause);
      
      if (newClause === clause) {
        return newClause;
      }

      for (let i = 0; i < newClause.clauses.length; i++) {
        newClause.clauses[i] = convertToDNF(newClause.clauses[i]);
      }

      return newClause;
    };

    // X and (Y or Z) => (X and Y) or (X and Z)
    const distributeAndOverOrOneStep = (clause) => {
      if (!(clause instanceof CompoundClause) || clause.operator != 'and' || clause.isRootFormula) {
        return clause;
      }

      // Pick one OR compound clause from its clauses
      // If not, then there is no OR clause to distribute over
      const orClause = clause.clauses.find(clause => clause instanceof CompoundClause && clause.operator == 'or');
      if (!orClause) {
        return clause;
      }

      let newClauses = [];
      let otherClauses = clause.clauses.filter(clause => clause !== orClause);
      if (otherClauses.length > 1) {
        otherClauses = new CompoundClause('and', otherClauses);
      } else {
        otherClauses = otherClauses[0];
      }

      for (let orSubClause of orClause.clauses) {
        if (orSubClause.isRootFormula) {
          orSubClause = orSubClause.clone();
        }
        const newAndClause = new CompoundClause('and', [otherClauses, orSubClause]);
        newClauses.push(newAndClause);
      }

      return new CompoundClause('or', newClauses);
    };

    return convertToDNF(this.rawConstraints);
  }

  /**
   * Reduce the constraints to DNF form of root formulas.
   */
  reduceToDNFRootFormulasOnly() {
    let reducedConstraints = this.reduceToDNF();
    if (!this.DNFCheck(reducedConstraints)) {
      return;
    }
    
    // Assume the current formula looks like (a and b and X) or (a and b and Y)
    // Merge every compound clause that has a root formula and unit clauses
    return this._findAndMerge(reducedConstraints);
  }

  _findAndMerge(clause) {
    if (clause instanceof UnitClause || clause instanceof RootFormula) {
      return clause;
    }

    // For compound clauses, only handle the (a and/or b and/or X) case
    // If all the clause.clauses are unit clauses with one root formula, then merge them
    let rootFormulas = clause.clauses.filter(clause => clause instanceof RootFormula);
    let nonRootClauses = clause.clauses.filter(clause => !(clause instanceof RootFormula));
    if (rootFormulas.length > 1) {
      throw new Error("Multiple root formulas found in a compound clause.");
    }
    
    let mergedNonRootClauses = [];
    for (let otherClause of nonRootClauses) {
      mergedNonRootClauses.push(this._findAndMerge(otherClause));
    }

    // Handle the case where there is only one root formula and multiple unit clauses
    if (rootFormulas.length === 1) {
      let rootFormula = rootFormulas[0];
      for (let otherClause of mergedNonRootClauses) {
        if (otherClause instanceof UnitClause) {
          if (clause.operator === 'and') {
            rootFormula = this.andOperatorBetweenRootAndUnit(rootFormula, otherClause.clone());
          } else if (clause.operator === 'or') {
            rootFormula = this.orOperatorBetweenRootAndUnit(rootFormula, otherClause.clone());
          }
        } else if (!otherClause.hasRootFormula()) {
          if (clause.operator === 'and') {
            rootFormula = this.andOperatorBetweenRootAndNonRootCompound(rootFormula, otherClause.clone());
          } else if (clause.operator === 'or') {
            rootFormula = this.orOperatorBetweenRootAndNonRootCompound(rootFormula, otherClause.clone());
          }
        }
      }
      return rootFormula;
    }

    return new CompoundClause(clause.operator, mergedNonRootClauses);
  }

  /**
   * Merge the constraints between the root and unit clauses.
   * 
   * @param {RootFormula} rootFormula - The root formula to merge with.
   * @param {UnitClause} unitClause - The unit clause to merge with.
   */
  andOperatorBetweenRootAndUnit(rootFormula, unitClause) {
    if (SymbolicDOMTheory.andOperatorBetweenRootAndUnit(rootFormula, unitClause)){
      console.log("No Conflict detected between the root and the unit.");
      rootFormula.addNewUnitClause('and', unitClause);
    }

    return rootFormula;
  }

  /**
   * Merge the constraints between the root and non-root compound clauses (No Root Formula Nested).
   */
  andOperatorBetweenRootAndNonRootCompound(rootFormula, compound) {
    if (SymbolicDOMTheory.andOperatorBetweenRootAndNonRootCompound(rootFormula, compound)) {
      console.log("No Conflict detected between the root and the compound.");
      rootFormula.addNewCompoundClause('and', compound); // Treat the compound as a unit clause
    }

    return rootFormula;
  }

  /**
   * Merge the constraints between the root and non-root compound clauses (No Root Formula Nested).
   */
  orOperatorBetweenRootAndNonRootCompound(rootFormula, compound) {
    // Ignore the unit clause for or operator
    return rootFormula;
  }

  /**
   * Merge the constraints between the root and unit clauses.
   * 
   * @param {RootFormula} rootFormula - The root formula to merge with.
   * @param {UnitClause} unitClause - The unit clause to merge with.
   */
  orOperatorBetweenRootAndUnit(rootFormula, unitClause) {
    // Ignore the unit clause for or operator
    return rootFormula;
  }
}
