import { SymbolicDOMTree } from "./symbolic-dom-tree.js";
import { ClauseBuilder, UnitClause, CompoundClause, RootFormula } from "./clause.js";

/**
 * Represents the symbolic DOM solver. 
 * This class helps represent and reduce constraints to a set of possible symbolic DOM trees.
 *
 * Constraints are expressed as a first-order logic formula composed of unit clauses.
 * A unit clause is a clause that contains exactly one literal.
 * A root formula is a conjunction of unit clauses that contains exactly one isRoot clause.
 * Note that, literal in each unit clause has its own namespace base on which root formula it belongs to.
 */
export class SymbolicDOMSolver {
  constructor() {
    this.rawConstraints = null;
    this.rootFormulas = new Map();
  }

  /**
   * Adds a and constraint to the solver.
   * @param {UnitClause|CompoundClause} constraint - The constraint to add.
   */
  andNewConstraintRaw(verb, ...args) {
    let newUnitClause = new UnitClause(null, verb, ...args); 
    this.andNewConstraint(newUnitClause);
  }

  /**
   * Adds a new and constraint to the solver.
   * @param {*} unitClause 
   */
  andNewConstraint(unitClause) {
    if (!this.rawConstraints) {
      this.rawConstraints = unitClause;
    } else {
      this.rawConstraints = ClauseBuilder.and(this.rawConstraints, unitClause);
    }
  }

  /**
   * Recursively checks and adds a compound constraint.
   * @param {CompoundClause} clauses - The compound clause to add.
   */
  andNewConstraintCompound(clauses) {
    if (!(clauses instanceof CompoundClause)) {
      throw new Error("Expected a CompoundClause instance.");
    }

    const processClause = (clause) => {
      if (clause instanceof RootFormula) {
        if (!this.rootFormulas.has(clause.namespace)) {
          this.rootFormulas.set(clause.namespace, RootFormula);
        }
      } else if (clause instanceof CompoundClause) {
        for (const subClause of clause.clauses) {
          processClause(subClause);
        }
      }
    };
    
    processClause(clauses);
    this.andNewConstraint(clauses);
  }

  /**
   * Add a new root formula to the solver.
   * The constraint is wrapped in a SymbolicDOMTree object, which can be accessed through symDOMTree.constraints.
   * @param {SymbolicDOMTree} symDOMTree 
   */
  andNewRootFormula(symDOMTree) {
    const rootFormula = new RootFormula(symDOMTree.id, symDOMTree.constraints);
    this.rootFormulas.set(symDOMTree.id, [rootFormula, symDOMTree]);

    if (!this.rawConstraints) {
      this.rawConstraints = rootFormula;
    } else {
      this.rawConstraints = ClauseBuilder.and(this.rawConstraints, rootFormula);
    }
  }

  /**
   * Reduce the raw constraints to disjunctive normal form of root formulas.
   */
  reduceConstraints() {
    if (!this.rawConstraints || this.rawConstraints instanceof UnitClause) {
      return;
    }
  
    // If all clauses are root formulas, no reduction is needed
    const containsNonRoot = (clause) => {
      if (clause instanceof RootFormula) {
        return false;
      } else if (clause instanceof CompoundClause) {
        return clause.clauses.some(containsNonRoot);
      }
      return true;
    };
  
    if (!containsNonRoot(this.rawConstraints)) {
      return;
    }
  
    // Convert to Disjunctive Normal Form (DNF) recursively
    const convertToDNF = (clause) => {
      // Traverse the tree to the leaves and apply the distributive law
      let newClause = distributeAndOverOrOneStep(clause);
      
      if (newClause === clause) {
        return newClause;
      }

      for (let i = 0; i < newClause.clauses.length; i++) {
        newClause.clauses[i] = convertToDNF(newClause.clauses[i]);
      }

      return newClause;
    };

    // X and (Y or Z) => (X and Y) or (X and Z)
    const distributeAndOverOrOneStep = (clause) => {
      if (!(clause instanceof CompoundClause) || clause.operator != 'and' || clause.isRootFormula) {
        return clause;
      }

      // Pick one OR compound clause from its clauses
      // If not, then there is no OR clause to distribute over
      const orClause = clause.clauses.find(clause => clause instanceof CompoundClause && clause.operator == 'or');
      if (!orClause) {
        return clause;
      }

      // Distribute the AND clause over the OR clause
      let newClauses = [];
      let otherClauses = clause.clauses.filter(clause => clause !== orClause);
      if (otherClauses.length > 1) {
        otherClauses = new CompoundClause('and', otherClauses);
      } else {
        otherClauses = otherClauses[0];
      }

      for (const orSubClause of orClause.clauses) {
        const newAndClause = new CompoundClause('and', [otherClauses, orSubClause]);
        newClauses.push(newAndClause);
      }

      return new CompoundClause('or', newClauses);
    };

    return convertToDNF(this.rawConstraints);
  }
}
