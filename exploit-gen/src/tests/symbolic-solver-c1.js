import { SymbolicDOMSolver } from "../symbolic-dom-solver.js"
import { SymbolicDOMTree } from "../symbolic-dom-tree.js"
import { UnitClause, CompoundClause, ClauseBuilder, RootFormula } from '../clause.js';

let solver = new SymbolicDOMSolver();

// ===== Rule 05 Start =====
let rule05 = new RootFormula(null, [new UnitClause(null, 'isRoot', 'R1')]);
rule05.addNewUnitClause('and', new UnitClause(rule05.namespace, 'hasTagName', 'R1', 'TNS2'));
rule05.addNewUnitClause('and', new UnitClause(rule05.namespace, 'hasAttribute', 'R1', 'name', 'P'));
rule05.addNewUnitClause('and', new UnitClause(rule05.namespace, 'declare', 'R1'));
rule05.addNewUnitClause('and', new UnitClause(rule05.namespace, 'declare', 'P'));
// ===== Rule 05 End =====

// ===== Rule 07 Start =====
let rule07 = new RootFormula(null, [new UnitClause(null, 'isRoot', 'R1')]);
rule07.addNewUnitClause('and', new UnitClause(rule07.namespace, 'declare', 'R1'));
rule07.addNewUnitClause('and', new UnitClause(rule07.namespace, 'declare', 'P'));
rule07.addNewUnitClause('and', new UnitClause(rule07.namespace, 'length(getSiblings)', 'R1', '>=', '1'));

// For the forall(getSiblings(R1), tempCompundClause) clause
// We first add the following constraints to the symbolic DOM tree
// Then, we add the forall(getSiblings(R1), tempCompundClause) to the lazyConstraints of symbolic DOM tree
// which will only checked when there is new node added to the symbolic DOM tree
let branchClause1 = new CompoundClause('and', [new UnitClause(rule07.namespace, 'hasTagName', 'R2', 'TNS2'), new UnitClause(rule07.namespace, 'hasAttribute', 'R2', 'name', 'P')]);
let branchClause2 = new CompoundClause('and', [new UnitClause(rule07.namespace, 'hasTagName', 'R2', 'object'), new UnitClause(rule07.namespace, 'hasAttribute', 'R2', 'id', 'P')]);
let tempCompoundClause = new CompoundClause('or', [branchClause1, branchClause2]);
rule07.addNewCompoundClause('and', tempCompoundClause);
rule07.addNewUnitClause('and', new UnitClause(rule07.namespace, 'hasSibling', 'R1', 'R2'));
rule07.addNewUnitClause('and', new UnitClause(rule07.namespace, 'forall', 'getSiblings(R1)', 'tempCompoundClause'));
// ===== Rule 07 End =====


// ===== Rule C1 Start =====
solver.addConstraint('and', new UnitClause(null, 'Bind', 'R1', '$1'));
solver.addConstraint('and', new UnitClause(null, 'Equal', 'P', 'scripts'));
solver.addConstraint('and', new CompoundClause('and', [rule05, rule07]));
// ===== Rule C1 End =====

solver.rawConstraints.print();
console.log("==========")
solver.reduceToDNFRootFormulasOnly();
solver.store("C1", solver.DNFTypeRootFormulas);
solver.clear();

// ===== Rule C2 Start =====
// ===== Rule C2 End =====

// ===== Rule C3 Start =====
// ===== Rule C3 End =====

// ===== Rule C4 Start =====
// ===== Rule C4 End =====

// let finals = solver.mergeStoredConstraintSet("ALL");
// for (let i = 0; i < finals.length; i++) {
//   finals[i].print();
// }