import { SymbolicDOMSolver } from "../symbolic-dom-solver.js"
import { SymbolicDOMTree } from "../symbolic-dom-tree.js"
import { UnitClause, CompoundClause, ClauseBuilder } from '../clause.js';

let solver = new SymbolicDOMSolver();

// ===== Rule 05 Start =====
let tree05 = new SymbolicDOMTree();
tree05.declareNode('R1');
tree05.declareString('P');
tree05.addConstraint('and', new UnitClause(tree05.id, 'isRoot', 'R1'));
tree05.addConstraint('and', new UnitClause(tree05.id, 'hasTagName', 'R1', 'TNS2'));
tree05.addConstraint('and', new UnitClause(tree05.id, 'hasAttribute', 'R1', 'name', 'P'));
// ===== Rule 05 End =====

// ===== Rule 07 Start =====
let tree07 = new SymbolicDOMTree();
tree07.declareNode('R1');
tree07.declareString('P');
tree07.addConstraint('and', new UnitClause(tree07.id, 'isRoot', 'R1'));
tree07.addConstraint('and', new UnitClause(tree07.id, 'length(getSiblings)', 'R1', '>=', '1'));

// For the forall(getSiblings(R1), tempCompundClause) clause
// We first add the following constraints to the symbolic DOM tree
// Then, we add the forall(getSiblings(R1), tempCompundClause) to the lazyConstraints of symbolic DOM tree
// which will only checked when there is new node added to the symbolic DOM tree
let branchClause1 = new CompoundClause('and', [new UnitClause(tree07.id, 'hasTagName', 'R2', 'TNS2'), new UnitClause(tree07.id, 'hasAttribute', 'R2', 'name', 'P')]);
let branchClause2 = new CompoundClause('and', [new UnitClause(tree07.id, 'hasTagName', 'R2', 'object'), new UnitClause(tree07.id, 'hasAttribute', 'R2', 'id', 'P')]);
let tempCompoundClause = new CompoundClause('or', [branchClause1, branchClause2]);
tree07.declareNode('R2');
tree07.addConstraint('and', new UnitClause(tree07.id, 'hasSibling', 'R1', 'R2'));
tree07.addConstraint('and', tempCompoundClause);
tree07.addLazyConstraint('forall(getSiblings(R1), tempCompoundClause)');
// ===== Rule 07 End =====


// ===== Rule C1 Start =====
// solver.andNewConstraintRaw('Bind', 'R1', '$1')
// solver.andNewConstraintRaw('Equal', 'P', 'scripts')
// // // solver.andNewConstraint(new CompoundClause('or', [new UnitClause(null, 'Bind', 'R1', '$1'), new UnitClause(null, 'Equal', 'P', 'scripts')]));
// solver.andNewConstraintCompound(new CompoundClause('or', [tree05.getRootFormula(), tree07.getRootFormula()]));
// ===== Rule C1 End =====


// // ===== Rule C3 Start =====
let treeC3 = new SymbolicDOMTree();
treeC3.declareNode('R1');
treeC3.declareNode('R2');
treeC3.addConstraint('and', new UnitClause(treeC3.id, 'isRoot', 'R1'));
treeC3.addConstraint('and', new UnitClause(treeC3.id, 'Bind', 'R1', '$1'));
treeC3.addConstraint('and', new UnitClause(treeC3.id, 'Bind', 'R2', '$2'));
treeC3.addConstraint('and', new UnitClause(treeC3.id, 'hasSibling', 'R1', 'R2'));
solver.andNewRootFormula(treeC3);
// ===== Rule C3 End =====

// ===== Rule C4 Start =====
let treeC4 = new SymbolicDOMTree();
treeC4.declareNode('R1');
treeC4.addConstraint('and', new UnitClause(treeC4.id, 'Bind', 'R1', '$2'));
treeC4.addConstraint('and', new UnitClause(treeC4.id, 'Equal', 'P', 'textContent'));
// ===== Rule 20 Start =====
treeC4.addConstraint('and', new UnitClause(treeC4.id, 'isRoot', 'R1'));
treeC4.addConstraint('and', new UnitClause(treeC4.id, 'hasTagName', 'R1', 'TNS*'));
treeC4.addConstraint('and', new UnitClause(treeC4.id, 'hasAttribute', 'R1', 'P', 'Payload'));
// ===== Rule 20 End =====
solver.andNewRootFormula(treeC4);
// // ====== Rule C4 End =====



solver.rawConstraints.print();
console.log("==========")
let reducedConstraints = solver.reduceToDNFRootFormulasOnly();
reducedConstraints.print();