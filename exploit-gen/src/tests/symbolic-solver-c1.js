import { SymbolicDOMSolver } from "../symdom-solver.js"
import { SymbolicDOMTree } from "../symdom-tree.js"
import { Staplar } from "../stapler.js";
import { THEHULK_TNS1, THEHULK_TNS2, THEHULK_TNS3, THEHULK_TNS4 } from "../constants/thehulk-tag-set.js"
import { UnitClause, CompoundClause, ClauseBuilder, RootFormula } from '../clause.js';

let solver = new SymbolicDOMSolver();

// ===== Rule 05 Start =====
let rule05 = new RootFormula(null, [new UnitClause(null, 'isRoot', '$R1')]);
rule05.addNewUnitClause('and', new CompoundClause('or', THEHULK_TNS2.map(tag => new UnitClause(rule05.namespace, 'hasTagName', '$R1', tag))));
rule05.addNewUnitClause('and', new UnitClause(rule05.namespace, 'hasAttribute', '$R1', 'name', '$P'));
rule05.addNewUnitClause('and', new UnitClause(rule05.namespace, 'declare', '$R1'));
// ===== Rule 05 End =====

// ===== Rule 07 Start =====
let rule07 = new RootFormula(null, [new UnitClause(null, 'isRoot', '$R1')]);
rule07.addNewUnitClause('and', new UnitClause(rule07.namespace, 'declare', '$R1'));
rule07.addNewUnitClause('and', new UnitClause(rule07.namespace, 'declare', '$P'));
rule07.addNewUnitClause('and', new UnitClause(rule07.namespace, 'length(getSiblings)', '$R1', '>=', '1'));

// For the forall(getSiblings(R1), CompundClause) clause
// We first add the following constraints to the symbolic DOM tree
// Then, we add the forall(getSiblings(R1), CompundClause) to the lazyConstraints of symbolic DOM tree
// which will only checked when there is new node added to the symbolic DOM tree
let branchClause07_1 = new CompoundClause('and', [
  new CompoundClause('or', THEHULK_TNS2.map(tag => new UnitClause(rule07.namespace, 'hasTagName', '$R2', tag))), 
  new UnitClause(rule07.namespace, 'hasAttribute', '$R2', 'name', 'P')
]);
let branchClause07_2 = new CompoundClause('and', [
  new UnitClause(rule07.namespace, 'hasTagName', '$R2', 'object'), 
  new UnitClause(rule07.namespace, 'hasAttribute', '$R2', 'id', '$P')
]);
rule07.addNewCompoundClause('and', new CompoundClause('or', [branchClause07_1, branchClause07_2]));
rule07.addNewUnitClause('and', new UnitClause(rule07.namespace, 'hasSibling', '$R1', '$R2'));
rule07.addNewUnitClause('and', new UnitClause(rule07.namespace, 'forall', 'getSiblings(R1)', '$R2'));
// ===== Rule 07 End =====



// ===== Rule C4pre Start =====
solver.addConstraint('and', new UnitClause(null, 'declare', '$R1'));
solver.addConstraint('and', new UnitClause(null, 'bind', '$R1', '$2'));
solver.addConstraint('and', new UnitClause(null, 'declareConstantString', '$P', 'textContent'));
// ===== Rule C4pre end =====

// ===== Rule 20 Start =====
let rule20 = new RootFormula(null, [new UnitClause(null, 'isRoot', '$R1')]);
rule20.addNewUnitClause('and', 
  new CompoundClause('or', [
    ...THEHULK_TNS1.map((tag) => {return new UnitClause(rule20.namespace, 'hasTagName', '$R1', tag)}),
    ...THEHULK_TNS2.map((tag) => {return new UnitClause(rule20.namespace, 'hasTagName', '$R1', tag)}),
    ...THEHULK_TNS3.map((tag) => {return new UnitClause(rule20.namespace, 'hasTagName', '$R1', tag)}),
    ...THEHULK_TNS4.map((tag) => {return new UnitClause(rule20.namespace, 'hasTagName', '$R1', tag)})
  ])
);
// rule20.addNewUnitClause('and', new UnitClause(rule20.namespace, 'hasTagName', '$R1', 'TNS1'));
rule20.addNewUnitClause('and', new UnitClause(rule20.namespace, 'declareString', '$Payload'));
rule20.addNewUnitClause('and', new UnitClause(rule20.namespace, 'hasAttribute', '$R1', '$P', '$Payload'));
// ===== Rule 20 End =====
solver.addConstraint('and', rule20);
solver.store("C4", solver.reduceToDNFRootFormulasOnly());
solver.clear();
// ===== Rule C4 End =====


// ===== Rule C3 Start =====
let ruleC3 = new RootFormula(null, [new UnitClause(null, 'isRoot', '$R1')]);
ruleC3.addNewUnitClause('and', new UnitClause(ruleC3.namespace, 'declare', '$R1'));
ruleC3.addNewUnitClause('and', new UnitClause(ruleC3.namespace, 'declare', '$R2'));
ruleC3.addNewUnitClause('and', new UnitClause(ruleC3.namespace, 'hasSibling', '$R1', '$R2'));
solver.addConstraint('and', new UnitClause(null, 'bind', '$R1', '$1'));
solver.addConstraint('and', new UnitClause(null, 'bind', '$R2', '$2'));

solver.addConstraint('and', ruleC3);
var tmpRoots = solver.reduceToDNFRootFormulasOnly();
// now we have C3 in tmpRoots, C4 in solver.storedConstraintSet, merge them!
solver.mergeStoredRootsWithOutside(tmpRoots);
solver.store("C3", solver.DNFTypeRootFormulas);
solver.clear();
// ===== Rule C3 End =====


// ===== Rule C2 Start =====

// ===== Rule C2 End =====


// // ===== Rule C1 Start =====
solver.addConstraint('and', new UnitClause(null, 'declareConstantString', '$P', 'scripts'));
solver.addConstraint('and', new UnitClause(null, 'bind', '$R1', '$1'));
solver.addConstraint('and', new CompoundClause('or', [rule05, rule07]));
solver.reduceToDNFRootFormulasOnly();
solver.mergeStoredRootsWithOutside(tmpRoots);
solver.clear();
// ===== Rule C1 End =====

solver.rawConstraints.print();
console.log("==========")
solver.store("C1", solver.reduceToDNFRootFormulasOnly());
solver.clear();





// let finals = solver.mergeStoredConstraintSet("ALL");
// for (let i = 0; i < finals.length; i++) {
//   finals[i].print();
// }