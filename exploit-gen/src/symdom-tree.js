import { Utils } from "./utils.js";
import toHTML from 'vdom-to-html';
import { SymbolicDOMNode } from './symdom-node.js';
import { UnitClause, CompoundClause, ClauseBuilder, RootFormula } from './clause.js';
import { THETHING_TS1, THETHING_TS2, THETHING_TS4, THETHING_TS5, THETHING_TS6 } from './constants/thething.js';

/**
 * The exploit DOM tree holder.
 * 
 * The class object represents the symbolic DOM tree that satisfies the imposed constraints for the exploit.
 * SymbolicDOMTree represents a root formula (only contains one root node) and a set of constraints.
 * 
 * lazyConstraints is a set of constraints that are not checked until a new node is added to the tree.
 * For example, forall(getSiblings(R1), tempCompundClause) is a lazy constraint.
 * We first add one R2 as R1's sibling and add tempCompundClause to R2.
 * If R2 is not enough or new nodes are added to the tree, we will check the tempCompundClause towards them.
 * 
 * Make sure that the nodes in topLevelSiblingNodes and rootNode are all pointers to the nodes in DOMSymbols.
 */
export class SymbolicDOMTree {
  constructor() {
    this.id = Utils.generateUniqueIdForTree();
    this.constraints = [];
    this.lazyConstraints = [];
    this.DOMSymbols = {};
    this.stringSymbols = {};
    this.stringConstants = {};
    this.bind = {};

    this.rootNode = null;
    this.rootNodeId = null;

    this.forallConstraints = new Map();

    // The lower-level sibling nodes can be set as children of shared parent nodes.
    this.topLevelSiblingNodes = [];
  }

  getIdentifierFromNode(node) {
    return Object.keys(this.DOMSymbols).find(key => this.DOMSymbols[key] === node);
  }

  /**
   * Declares a new DOM node with a specific type.
   * If nodeType is "*", it will consider all possible node types.
   * @param {string} nodeType - The type of the DOM node (e.g., 'div', 'iframe', or '*').
   * @param {string} nodeId - The unique ID for the node (for internal reference). The ID should be unique within the tree.
   */
  declareNode(nodeIdentifier) {
    if (this.DOMSymbols[nodeIdentifier]) {
      // throw new Error(`Node with identifier ${nodeIdentifier} already exists.`);
      return;
    }
    this.DOMSymbols[nodeIdentifier] = new SymbolicDOMNode();
  }

  /**
   * Declares a new string symbol.
   * @param {string} stringIdentifier - The unique ID for the string (for internal reference).
   */
  declareString(stringIdentifier) {
    if (this.stringSymbols[stringIdentifier] && this.stringSymbols[stringIdentifier]!==stringIdentifier) {
      throw new Error(`String with identifier ${stringIdentifier} already exists.`);
    }

    this.stringSymbols[stringIdentifier] = stringIdentifier;
  }

  declareConstantString(stringIdentifier, stringValue) {
    if (this.stringConstants[stringIdentifier]) {
      throw new Error(`String constant with identifier ${stringIdentifier} already exists.`);
    } else if (!stringIdentifier.startsWith('$')) {
      throw new Error(`String constant identifier ${stringIdentifier} should start with '$'.`);
    }

    this.stringConstants[stringIdentifier] = stringValue;
  }

  declareBind(nodeIdentifier, variableIdentifier) {
    if (this.bind[nodeIdentifier]) {
      throw new Error(`DOM tree ${nodeIdentifier} is already matched to ${this.bind[nodeIdentifier]}.`);
    } else if (!nodeIdentifier.startsWith('$')) {
      throw new Error(`Identifier ${nodeIdentifier} should start with '$'.`);
    }

    this.bind[variableIdentifier] = nodeIdentifier;
  }

  /**
   * Adds a constraint to the symbolic DOM tree.
   * @param {string} operator - The operator for the constraint. and, or, not.
   * @param {UnitClause|CompoundClause} constraint - The constraint to add.
   * 
   */
  addConstraint(command, ...args) {
    switch (command) {
      case 'isRoot': 
        this.setAsRoot(args[0]);
        this.constraints.push([command, ...args])
        break;
      
      case 'declareNode':
        this.declareNode(args[0]);
        this.constraints.push([command, ...args])
        break;
      
      case 'declareConstantString':
        this.declareConstantString(args[0], args[1]);
        this.constraints.push([command, ...args])
        break;
      
      case 'bind':
        this.declareBind(args[0], args[1]);
        this.constraints.push([command, ...args])
        break;
      
      case 'declareString':
        this.declareString(args[0]);
        this.constraints.push([command, ...args])
        break;

      case 'hasAttribute':
        this.hasAttribute(args[0], args[1], args[2]);
        this.constraints.push([command, ...args])
        break;
      
      case 'setAttributeOR':
        this.setAttributeOR(args[0], args[1]);
        this.constraints.push([command, ...args])
        break;
      
      case 'hasTagName':
        this.hasTagName(args[0], args[1]);
        this.constraints.push([command, ...args])
        break;
      
      case 'hasChild':
        this.hasChild(args[0], args[1]);
        this.constraints.push([command, ...args])
        break;
      
      case 'hasSibling':
        this.hasSibling(args[0], args[1]);
        this.constraints.push([command, ...args])
        break;

      case 'forall':
        this.forall(args[0], args[1], args[2]);
        this.constraints.push([command, ...args])

      default:
        return;
        // throw new Error(`Unknown command: ${command}`);
    }
  }

  getRootFormula() {
    if (this.constraints instanceof CompoundClause) {
      return new RootFormula(this.id, this.constraints);
    } else {
      throw new Error(`Invalid constraint type: ${this.constraints}`);
    }
  }

  /**
   * Adds a lazy constraint to the symbolic DOM tree.
   */
  addLazyConstraint(operator, constraint) {
    // Not implemented yet.
  }

  /**
   * Sets the specified node as the root node.
   * @param {string} nodeIdentifier - The unique ID for the node.
   */
  setAsRoot(nodeIdentifier) {
    if (!this.DOMSymbols[nodeIdentifier]) {
      throw new Error(`Node with identifier ${nodeIdentifier} does not exist.`);
    }

    // If a root node already exists, unmark it as root
    if (this.rootNode) {
      this.rootNode.isRoot = false;
    }

    // Set the new root node
    const node = this.DOMSymbols[nodeIdentifier];
    node.setAsRoot();
    this.rootNode = node;
    this.rootNodeId = nodeIdentifier;
  }

  checkFromString(value){
    if (value.startsWith('$')){
      var tmp = this.stringSymbols[value];
      var tmpConstant = this.stringConstants[value];
      if (!tmp && !tmpConstant){
        throw new Error(`A string ${value} is used before definition.`);
      }
      else{
        if(tmpConstant){
          value = tmpConstant;
        } else if (tmp){
          value = tmp;
        }
      }
    }
    return value
  }

  /**
   * Adds an attribute to the specified node.
   * 
   * @param {string} nodeIdentifier - The unique ID for the node.
   * @param {string} attributeName - The name of the attribute.
   * @param {string} attributeValue - The value of the attribute.
   */
  hasAttribute(nodeIdentifier, attributeName, attributeValue) {
    if (!this.DOMSymbols[nodeIdentifier]) {
      throw new Error(`Node with identifier ${nodeIdentifier} does not exist.`);
    }

    const node = this.DOMSymbols[nodeIdentifier];
    attributeName = this.checkFromString(attributeName);
    attributeValue = this.checkFromString(attributeValue);
    node.setAttribute(attributeName, attributeValue);
  }

  setAttributeOR(nodeIdentifier, attributePairs) {
    if (!this.DOMSymbols[nodeIdentifier]) {
      throw new Error(`Node with identifier ${nodeIdentifier} does not exist.`);
    }

    const node = this.DOMSymbols[nodeIdentifier];
    node.setAttributeOR(attributePairs);
  }

  /**
   * Adds a type to the specified node.
   * 
   * @param {string} nodeIdentifier - The unique ID for the node.
   * @param {string} nodeType - The type of the node.
   */
  hasTagName(nodeIdentifier, nodeType) {
    if (!this.DOMSymbols[nodeIdentifier]) {
      throw new Error(`Node with identifier ${nodeIdentifier} does not exist.`);
    }

    const node = this.DOMSymbols[nodeIdentifier];
    if (nodeType=='TNS1'){
      nodeType = [...THETHING_TS1];
    }
    // We support multiple types for a node.
    if (Array.isArray(nodeType)) {
      nodeType.forEach(type => node.setType(type));
    } else {
      node.setType(nodeType);
    }
  }

  /**
   * Adds a child to the specified node.
   * 
   * @param {string} parentNodeIdentifier - The unique ID for the parent node.
   * @param {string} childNodeIdentifier - The unique ID for the child node.
   */
  hasChild(parentNodeIdentifier, childNodeIdentifier) {
    if (!this.DOMSymbols[parentNodeIdentifier]) {
      throw new Error(`Node with identifier ${parentNodeIdentifier} does not exist.`);
    }

    if (!this.DOMSymbols[childNodeIdentifier]) {
      throw new Error(`Node with identifier ${childNodeIdentifier} does not exist.`);
    }

    const parentNode = this.DOMSymbols[parentNodeIdentifier];
    const childNode = this.DOMSymbols[childNodeIdentifier];
    parentNode.addChild(childNode);
    childNode.parent = parentNode;
  }

  /**
   * Adds a sibling to the specified node.
   * 
   * @param {string} siblingNodeIdentifier - The unique ID for the sibling node.
   * @param {string} parentNodeIdentifier - The unique ID for the parent node.
   */
  hasSibling(parentNodeIdentifier, siblingNodeIdentifier) {
    if (!this.DOMSymbols[siblingNodeIdentifier]) {
      throw new Error(`Node with identifier ${siblingNodeIdentifier} does not exist.`);
    }

    if (!this.DOMSymbols[parentNodeIdentifier]) {
      throw new Error(`Node with identifier ${parentNodeIdentifier} does not exist.`);
    }

    const siblingNode = this.DOMSymbols[siblingNodeIdentifier];
    const parentNode = this.DOMSymbols[parentNodeIdentifier];

    if (parentNode.isRoot) {
      this.topLevelSiblingNodes.push(siblingNode);
    } else if (parentNode.parent) {
      parentNode.addSibling(siblingNode);
    } else {
      throw new Error(`Parent node ${parentNodeIdentifier} does not have a parent.`);
    }
  }

  /**
   * Add a forall constraint to the symbolic DOM tree.
   * 
   * @param {string} nodeIdentifier1 - The unique ID for the first node.
   * @param {string} relation - The relation between the two nodes.
   * @param {string} examplerNodeIdentifier - The unique ID for the second node.
   */
  forall(nodeIdentifier1, relation, examplerNodeIdentifier) {
    if (!this.DOMSymbols[nodeIdentifier1]) {
      throw new Error(`Node with identifier ${siblingNodeIdentifier} does not exist.`);
    }

    if (!this.DOMSymbols[examplerNodeIdentifier]) {
      throw new Error(`Node with identifier ${examplerNodeIdentifier} does not exist.`);
    }

    this.examplarNode = this.DOMSymbols[examplerNodeIdentifier];
    this.forallConstraints.set(nodeIdentifier1, [relation, this.examplarNode.clone()]);
  }

  /**
   * Generates the exploit DOM tree.
   * @returns {Array<string>} - An array of HTML strings representing the possible DOM trees.
   */
  concreteToString() {
    const rootVNodeList = this.rootNode.concreteToVNode();

    const siblingVNodeCombinations = this.topLevelSiblingNodes.map(sibling => sibling.concreteToVNode());
    function cartesianProduct(arrays) {
        return arrays.reduce((acc, array) => {
            return acc.flatMap(d => array.map(e => [...d, e]));
        }, [[]]);
    }

    const allCombinations = cartesianProduct([rootVNodeList, ...siblingVNodeCombinations]);
    const htmlStrings = allCombinations.map(vnodeCombination => {
      return vnodeCombination.map(vnode => { return toHTML(vnode); }).join('\n');
    });

    return htmlStrings;
  }

  /**
   * Clones the symbolic DOM tree.
   * @returns {SymbolicDOMTree} - A new instance of the cloned symbolic
   */
  clone() {
    const clonedTree = new SymbolicDOMTree();
    clonedTree.id = Utils.generateUniqueIdForTree();
    clonedTree.constraints = this.constraints.map(constraint => [...constraint]);
    clonedTree.lazyConstraints = this.lazyConstraints.map(constraint => [...constraint]);
    clonedTree.DOMSymbols = {};
    for (const key in this.DOMSymbols) {
      if (this.DOMSymbols.hasOwnProperty(key)) {
        clonedTree.DOMSymbols[key] = this.DOMSymbols[key].clone();
      }
    }
    clonedTree.stringSymbols = { ...this.stringSymbols };
    clonedTree.stringConstants = { ...this.stringConstants };
    clonedTree.bind = { ...this.bind };
    clonedTree.forallConstraints = new Map(this.forallConstraints);

    // Find the cloned nodes from the cloned DOMSymbols
    if (this.rootNode) {
      const rootNodeId = Object.keys(this.DOMSymbols).find(
        key => this.DOMSymbols[key] === this.rootNode
      );
      if (rootNodeId) {
        clonedTree.rootNode = clonedTree.DOMSymbols[rootNodeId];
        clonedTree.rootNodeId = this.rootNodeId;
      }
    }
  
    clonedTree.topLevelSiblingNodes = this.topLevelSiblingNodes.map(siblingNode => {
      const siblingNodeId = Object.keys(this.DOMSymbols).find(
        key => this.DOMSymbols[key] === siblingNode
      );
      if (siblingNodeId) {
        return clonedTree.DOMSymbols[siblingNodeId];
      }
      return null;
    }).filter(node => node !== null);
  
    return clonedTree;
  }
}