import { Utils } from "./utils.js";
import { h, create } from 'virtual-dom';
import toHTML from 'vdom-to-html';
/**
 * The symbolic DOM node.
 * 
 * We should be able to define its type, attributes, and children nodes.
 * It is symbolic, meaning it represents a set of possible DOM nodes that satisfy the constraints.
 * 
 * @param {Array[string]} nodeTypes - The possible types of the node.
 * @param {Object<AttributeName:String>} attributes - The attributes of the node.
 * @param {Array[SymbolicDOMNode]} children - The children of the node.
 */
export class SymbolicDOMNode {
  constructor(nodeTypes='*', attributes='*', children='*', isRoot=false) {
    this.nodeUniqueId = Utils.generateUniqueIdForNode();
    this.nodeTypes = nodeTypes === '*' ? ['*'] : nodeTypes; // initialize nodeTypes to ['*']
    this.attributes = attributes === '*' ? {} : attributes;
    this.children = children === '*' ? [] : children;
    this.parent = null;
    this.isRoot = isRoot;

    this.attributeOR = []; // Attributes that are either-or: [ [attr1, attr2], [attr3, attr4] ]
  }

  setAsRoot() {
    this.isRoot = true;
  }

  addChild(childNode) {
    this.children.push(childNode);
  }

  addSibling(siblingNode) {
    this.parent.children.push(siblingNode);
  }

  setAttribute(attributeName, attributeValue) {
    this.attributes[attributeName] = attributeValue;
  }

  /**
   * Adds an either-or attribute pair.
   * @param {Array<String>} attributePairs 
   */
  setAttributeOR(attributePairs) {
    this.attributeOR.push(attributePairs);
  }

  /**
   * 
   * @param {String} nodeType
   */
  setType(nodeType) {
    if (this.nodeTypes[0] == '*') {
      this.nodeTypes = [];
    } 
    if (!this.nodeTypes.includes(nodeType)) {
      this.nodeTypes.push(nodeType);
    }
  }

  resetTypes(newTypes) {
    this.nodeTypes = newTypes;
  }

  resetAttributes(newAttributes) {
    this.attributes = newAttributes;
  }

  /**
   * Generates the virtual DOM node based on the symbolic representation.
   * You should assume the function retruns a set of possible virtual DOM nodes that satisfy current constraints.
   * 
   * @returns {Array<VNode>} - The virtual DOM element(s).
   */
  concreteToVNode() {
    let possibleNodes = this.nodeTypes !== '*' ? this.nodeTypes : Utils.getAllElementTypes();
  
    function cartesianProduct(arrays) {
      return arrays.reduce((acc, array) => {
        return acc.flatMap(d => array.map(e => [...d, e]));
      }, [[]]);
    }
  
    function generateAttributeCombinations(attributes, attributeOR) {
      const combinations = [];
  
      function helper(currentAttributes, remainingOR) {
        if (remainingOR.length === 0) {
          combinations.push(currentAttributes);
          return;
        }
  
        const [firstOR, ...restOR] = remainingOR;
        firstOR.forEach(option => {
          const newAttributes = { ...currentAttributes };
          newAttributes[option] = attributes[option];
          helper(newAttributes, restOR);
        });
      }
  
      helper({}, attributeOR);
      return combinations.length > 0 ? combinations : [attributes];
    }
  
    // Create a copy of the attributes and strip out those in attributeOR
    const baseAttributes = { ...this.attributes };
    this.attributeOR.forEach(pair => {
      pair.forEach(attr => {
        delete baseAttributes[attr];
      });
    });
  
    const attributeCombinations = generateAttributeCombinations(this.attributes, this.attributeOR);
  
    const childrenCombinations = cartesianProduct(this.children.map(child => child.concreteToVNode()));
  
    const elements = possibleNodes.map(nodeType => {
      const tagName = nodeType === nodeType.toLowerCase() ? nodeType : Utils.getNodeTag(nodeType);
  
      return attributeCombinations.flatMap(attributes =>
        childrenCombinations.map(children => {
          let allAttr = { ...baseAttributes, ...attributes };
          if (allAttr["textContent"]) {
            return h(tagName, { ...baseAttributes, ...attributes }, [allAttr['textContent'], ...children])
          }else { 
            return h(tagName, { ...baseAttributes, ...attributes }, children)
          }
      })
      );
    });
  
    return elements.flat(1);
  }

  /**
   * Converts the virtual DOM node to a string representing the HTML.
   * @returns {string} - The HTML string.
   */
  concreteToString() {
    const vNode = this.concreteToVNode();

    if (Array.isArray(vNode)) {
      return vNode.map(node => toHTML(node));
    } else {
      return toHTML(vNode);
    }
  }

  clone() {
    const clonedNode = new SymbolicDOMNode(
      Array.isArray(this.nodeTypes) ? [...this.nodeTypes] : this.nodeTypes,
      this.attributes === '*' ? '*' : { ...this.attributes },
      this.children === '*' ? '*' : this.children.map(child => child.clone()),
      this.isRoot
    );
  
    clonedNode.parent = this.parent;
    clonedNode.attributeOR = this.attributeOR.map(pair => [...pair]);
    clonedNode.nodeUniqueId = Utils.generateUniqueIdForNode();
  
    return clonedNode;
  }
}


// const symbolicNode = new SymbolicDOMNode('*', '*', '*');
// const htmlString = symbolicNode.concreteToString();

// console.log(htmlString);  