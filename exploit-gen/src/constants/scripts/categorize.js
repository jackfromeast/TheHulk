import { DOM_NODE_STANDARD } from '../dom-node-standard.js';
import { DOM_NODE_TAG_MAP } from '../dom-node-to-tag.js';
import fs from 'fs';

let tagSetId = 0;
const tagSets = {};

function mapTagsAndGroupReflectAttributes(data, tagMap) {
  const attributeToTags = {};
  const output = {};

  for (const [tag, details] of Object.entries(data)) {
    if (!tagMap[tag]) {
      continue;
    }
    const realTag = tagMap[tag];
    details.reflectAttributesDOMString.forEach(attr => {
      if (!attributeToTags[attr]) {
        attributeToTags[attr] = [];
      }
      attributeToTags[attr].push(realTag);
    });
  }

  const sharedAttributes = {};
  const uniqueAttributes = {};

  for (const [attr, tags] of Object.entries(attributeToTags)) {
    if (tags.length > 1) {
      const key = handleTagSet(tags);
      if (!sharedAttributes[key]) {
        sharedAttributes[key] = [];
      }
      sharedAttributes[key].push(attr);
    } else {
      const tag = handleTagSet(tags)[0];
      if (!uniqueAttributes[tag]) {
        uniqueAttributes[tag] = [];
      }
      uniqueAttributes[tag].push(attr);
    }
  }

  for (const [tag, attrs] of Object.entries(uniqueAttributes)) {
    output[tag] = [attrs];
  }

  for (const [combinedTags, attrs] of Object.entries(sharedAttributes)) {
    output[combinedTags] = [attrs];
  }

  return output;
}

function handleTagSet(tags) {
  tags.sort();
  
  // Check if an identical tag set already exists
//   for (const [key, existingTags] of Object.entries(tagSets)) {
//     if (arraysEqual(tags, existingTags)) {
//       return [key];
//     }
//   }

  // If no existing tag set is found, create a new one
//   if (tags.length > 20) {
//     const tagSetName = `TNS${tagSetId++}`;
//     tagSets[tagSetName] = tags;
//     return [tagSetName];
//   }

  return tags;
}

function arraysEqual(arr1, arr2) {
  if (arr1.length !== arr2.length) return false;
  for (let i = 0; i < arr1.length; i++) {
    if (arr1[i] !== arr2[i]) return false;
  }
  return true;
}

function generateSpecificRow(tags1, attributes1, tags2 = [], attributes2 = []) {
    const tags1Formatted = tags1.join(",\\xspace ") + "\\xspace";
    const tags2Formatted = tags2.length > 0 ? tags2.join(",\\xspace ") + "\\xspace" : "";
    const attributes1Formatted = attributes1.join(",\\xspace ") + "\\xspace";
    const attributes2Formatted = attributes2.length > 0 ? attributes2.join(",\\xspace ") + "\\xspace" : "";
    
    return `\\tiny ${attributes1Formatted} & \\tiny ${tags1Formatted} & & \\tiny ${attributes2Formatted} & \\tiny ${tags2Formatted} \\\\ \n\\cmidrule{1-2} \\cmidrule{4-5}`;
  }

function generateTable(data) {
  let table = "";
  const keys = Object.keys(data);

  for (let i = 0; i < keys.length; i += 2) {
    const key1 = keys[i];
    const key2 = keys[i + 1];

    const tags1 = key1.split(",");
    const attributes1 = data[key1][0];

    let tags2 = [];
    let attributes2 = [];

    if (key2) {
      tags2 = key2.split(",");
      attributes2 = data[key2][0];
    }

    table += generateSpecificRow(tags1, attributes1, tags2, attributes2) + "\n";
  }

  return table;
}

const result = mapTagsAndGroupReflectAttributes(DOM_NODE_STANDARD, DOM_NODE_TAG_MAP);

// Save the tag sets to a separate file for reference
fs.writeFileSync('../tag-sets.json', JSON.stringify(tagSets, null, 2));

// Save the appendix table result
fs.writeFileSync('../appendix-table-dom2string.json', JSON.stringify(result, null, 2));

console.log(generateTable(result));
console.log(tagSets);