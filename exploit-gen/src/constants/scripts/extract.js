import fs from 'fs';
import path from 'path';

const directoryPath = '../webidl';

const DOM_NODE_STANDARD = {};
const MIXINS = {};

function parseWebIDL(content) {
  const tagNameMatch = content.match(/interface (\w+)(?:\s*:\s*(\w+))?/);
  const tagName = tagNameMatch ? tagNameMatch[1] : null;
  const parentTagName = tagNameMatch ? tagNameMatch[2] : null;

  const attributesDOMString = new Set();
  const reflectAttributesDOMString = new Set();
  const apis = new Set();
  const includes = [];

  const lines = content.split('\n');
  let currentMixin = null;

  lines.forEach(line => {
    line = line.trim();

    // Handle attributes (DOMString and USVString)
    const attrMatch = line.match(/attribute (DOMString|USVString) (\w+);/);
    if (attrMatch) {
      const [_, type, attrName] = attrMatch;
      const isReflect = line.includes('Reflect');

      if (type === 'DOMString') {
        attributesDOMString.add(attrName);
        if (isReflect) {
          reflectAttributesDOMString.add(attrName);
        }
      } else if (type === 'USVString') {
        attributesDOMString.add(attrName);
        if (isReflect) {
          reflectAttributesDOMString.add(attrName);
        }
      }
    }

    // Handle APIs
    const apiMatch = line.match(/(DOMString|USVString) (\w+)\(/);
    if (apiMatch) {
      apis.add(apiMatch[2]);
    }

    // Handle includes
    const includesMatch = line.match(/(\w+) includes (\w+);/);
    if (includesMatch) {
      includes.push(includesMatch[2]);
    }

    // Handle mixins
    const mixinMatch = line.match(/interface mixin (\w+)/);
    if (mixinMatch) {
      currentMixin = mixinMatch[1];
      MIXINS[currentMixin] = { attributesDOMString: new Set(), apis: new Set() };
    } else if (currentMixin) {
      // Collect attributes and APIs for the mixin
      const mixinAttrMatch = line.match(/attribute (DOMString|USVString) (\w+);/);
      const mixinApiMatch = line.match(/(DOMString|USVString) (\w+)\(/);
      if (mixinAttrMatch) {
        MIXINS[currentMixin].attributesDOMString.add(mixinAttrMatch[2]);
        if (line.includes('Reflect')) {
          reflectAttributesDOMString.add(mixinAttrMatch[2]);
        }
      } else if (mixinApiMatch) {
        MIXINS[currentMixin].apis.add(mixinApiMatch[2]);
      }

      // End of mixin if the line does not match attribute or API
      if (!mixinAttrMatch && !mixinApiMatch) {
        currentMixin = null;
      }
    }
  });

  return {
    tagName,
    parentTagName,
    attributesDOMString: Array.from(attributesDOMString),
    reflectAttributesDOMString: Array.from(reflectAttributesDOMString),
    apis: Array.from(apis),
    includes
  };
}

function applyInheritance(DOM_NODE_STANDARD, MIXINS) {
  const nodeAttributes = ['nodeValue', 'textContent'];

  for (const [tagName, data] of Object.entries(DOM_NODE_STANDARD)) {
    let currentParent = data.parentTagName;
    while (currentParent) {
      const parentData = DOM_NODE_STANDARD[currentParent];
      if (parentData) {
        // Inherit attributes and APIs
        data.attributesDOMString = [...new Set([...parentData.attributesDOMString, ...data.attributesDOMString])];
        data.reflectAttributesDOMString = [...new Set([...parentData.reflectAttributesDOMString, ...data.reflectAttributesDOMString])];
        data.apis = [...new Set([...parentData.apis, ...data.apis])];
        currentParent = parentData.parentTagName;
      } else {
        currentParent = null;
      }
    }

    // Apply mixins
    data.includes.forEach(mixin => {
      if (MIXINS[mixin]) {
        data.attributesDOMString = [...new Set([...MIXINS[mixin].attributesDOMString, ...data.attributesDOMString])];
        data.reflectAttributesDOMString = [...new Set([...MIXINS[mixin].attributesDOMString, ...data.reflectAttributesDOMString])];
        data.apis = [...new Set([...MIXINS[mixin].apis, ...data.apis])];
      }
    });

    // Add nodeValue and textContent to all elements that inherit from Node
    if (tagName === 'Node' || data.parentTagName === 'Node') {
      data.attributesDOMString = [...new Set([...data.attributesDOMString, ...nodeAttributes])];
      data.reflectAttributesDOMString = [...new Set([...data.reflectAttributesDOMString, ...nodeAttributes])];
    }
  }
}

fs.promises.readdir(directoryPath)
  .then(files => {
    return Promise.all(
      files.filter(file => path.extname(file) === '.webidl').map(file => {
        const filePath = path.join(directoryPath, file);
        return fs.promises.readFile(filePath, 'utf-8')
          .then(content => {
            const { tagName, parentTagName, attributesDOMString, reflectAttributesDOMString, apis, includes } = parseWebIDL(content);
            if (tagName) {
              DOM_NODE_STANDARD[tagName] = {
                parentTagName: parentTagName || null,
                attributesDOMString,
                reflectAttributesDOMString,
                apis,
                includes
              };
            }
          });
      })
    );
  })
  .then(() => {
    applyInheritance(DOM_NODE_STANDARD, MIXINS);

    fs.promises.writeFile('../dom-node-standard.js', 'const DOM_NODE_STANDARD = ' + JSON.stringify(DOM_NODE_STANDARD, null, 2) + ';\n export { DOM_NODE_STANDARD };')
      .then(() => console.log('DOM_NODE_STANDARD has been written to dom-node-standard.js'))
      .catch(err => console.error('Error writing DOM_NODE_STANDARD:', err));
  })
  .catch(err => console.error('Error processing files:', err));
