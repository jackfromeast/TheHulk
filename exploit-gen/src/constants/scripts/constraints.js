/**
 * This file is used to generate the constraints used in Table 1 of the paper.
 * This is based on the thething-markups/dom-clobbering-markups-fc.csv file.
 */

import fs from 'fs';
import csv from 'csv-parser';
import { Parser } from 'json2csv';
import { time } from 'console';

const MARKUPS_PATH = '../thething-markups/dom-clobbering-markups-fc.csv';
const globalTagSets = {};
var tagSetCounter = 1;

/**
 * This function filters out the rows based on the clobbered column.
 * 
 * @param {Array<Object>} the csv data.
 * @param {Array<pattern>} the column to filter out, e.g., ['window.x', 'window.x.x', 'window.x.y'].
 * @returns {Array<Object>} - The filtered data.
 */
function findAll(data, clobbered){
  return data.filter(row => clobbered.includes(row['clobbered']));
}

/**
 * Read the CSV file.
 * @param {string} filePath - The path to the CSV file.
 * @returns {Promise<Array<Object>>} - A promise that resolves to an array of objects representing the CSV data.
 */
function readCSV(filePath) {
  return new Promise((resolve, reject) => {
      const data = [];

      fs.createReadStream(filePath)
          .pipe(csv())
          .on('data', (row) => {
              data.push(row);
          })
          .on('end', () => {
              resolve(data);
          })
          .on('error', (error) => {
              reject(error);
          });
  });
}

function save(data, outputFilePath){
  const json2csvParser = new Parser();
  const csvOutput = json2csvParser.parse(data);

  fs.writeFile(outputFilePath, csvOutput, (err) => {
    if (err) {
      console.error('Error writing to file:', err);
    } else {
      console.log(`Filtered data has been written to ${outputFilePath}`);
    }
  });
}

/**
 * This function clusters the rows based on the specified columns and then aggregates the rows
 * within each cluster by creating sets (TNSs) to store unique tags from the merged columns.
 * If a TNS only has one element, the element itself is used instead of the TNS.
 * 
 * @param {Array<Object>} data - The CSV data.
 * @param {Array<string>} tags - The columns whose values are to be aggregated into sets.
 * @param {Array<string>} columns - The columns to check for similarity (to decide clustering).
 * @returns {Array<Object>} - The aggregated rows with tag sets replaced by TNSs or single elements.
 */
function aggregatedRows(data, tags, columns) {
  const clusters = {};

  // Cluster rows based on the columns
  data.forEach(row => {
    const clusterKey = columns.map(col => row[col]).join('|');
    if (!clusters[clusterKey]) {
      clusters[clusterKey] = [];
    }
    clusters[clusterKey].push(row);
  });

  const aggregated = [];
  const tagSets = [];

  Object.keys(clusters).forEach((clusterKey) => {
    const clusterRows = clusters[clusterKey];

    // Step 1: Cluster the tag2 column based on tag1
    const tag1ToTag2 = {};
    clusterRows.forEach(row => {
      const tag1 = row[tags[0]];
      const tag2 = row[tags[1]];

      if (!tag1ToTag2[tag1]) {
        tag1ToTag2[tag1] = new Set();
      }
      tag1ToTag2[tag1].add(tag2);
    });

    // Step 2: Merge the tags in the same cluster
    const mergedTags = {};
    Object.keys(tag1ToTag2).forEach(tag1 => {
      const tag2Set = Array.from(tag1ToTag2[tag1]).sort().join('|');
      if (!mergedTags[tag2Set]) {
        mergedTags[tag2Set] = new Set();
      }
      mergedTags[tag2Set].add(tag1);
    });

    // Step 3: Generate or reuse TNSs and create the final rows
    Object.keys(mergedTags).forEach(tag2Set => {
      const tag1Set = Array.from(mergedTags[tag2Set]);
      let tnsNameTag1, tnsNameTag2;

      // Determine or create TNS for tag1Set
      if (tag1Set.length === 1) {
        tnsNameTag1 = tag1Set[0];
      } else {
        const tag1SetString = tag1Set.sort().join('|');
        if (globalTagSets[tag1SetString]) {
          tnsNameTag1 = globalTagSets[tag1SetString];
        } else {
          tnsNameTag1 = `TNS${tagSetCounter++}`;
          globalTagSets[tag1SetString] = tnsNameTag1;
          tagSets.push({ [tnsNameTag1]: tag1Set });
        }
      }

      // Determine or create TNS for tag2Set
      const tag2Array = Array.from(tag1ToTag2[tag1Set[0]]);
      if (tag2Array.length === 1) {
        tnsNameTag2 = tag2Array[0];
      } else {
        const tag2SetString = tag2Array.sort().join('|');
        if (globalTagSets[tag2SetString]) {
          tnsNameTag2 = globalTagSets[tag2SetString];
        } else {
          tnsNameTag2 = `TNS${tagSetCounter++}`;
          globalTagSets[tag2SetString] = tnsNameTag2;
          tagSets.push({ [tnsNameTag2]: tag2Array });
        }
      }

      // Create a new row with TNSs replacing the tags
      const newRow = {};
      columns.forEach(col => {
        newRow[col] = clusterRows[0][col]; // Keep the original values for the non-tag columns
      });
      newRow[tags[0]] = tnsNameTag1; // Replace tag1 with TNS or the element itself
      newRow[tags[1]] = tnsNameTag2; // Replace tag2 with TNS or the element itself

      aggregated.push(newRow);
    });
  });

  return { aggregated, tagSets };
}

/**
 * This function cleans the `attribute2` column, removing specific values or replacing them.
 * @param {string} attr - The attribute string to be cleaned.
 * @returns {string} - The cleaned attribute string.
 */
function cleanAttributes(attr) {
  if (attr === '-') return attr;

  let attributes = attr.replace(/[\[\]']/g, '').split(',').map(s => s.trim());
  attributes = attributes.filter(a => a !== 'id=x' && a !== 'name=x');
  
  if (attributes.length === 0) return '-';
  return `['${attributes.join("','")}']`;
}


/**
 * This function generates information used by Window2DOM row in Table 1.
 * 
 * 1/ All the markups that clobber window.x lookups.
 * 2/ The aggregated of tags that are used to clobber window.x lookups.
 * 3/ Merged rules with aggregated tags from 2/.
 * 
 */
function WINDOW2DOM(){
  return readCSV(MARKUPS_PATH).then(data => {
    const clobberedSingle = ['window.x'];
    const filtered = findAll(data, clobberedSingle);

    // Also, remove the attribute2 column which has 'name=y' or 'id=y'
    // ['id=y'] or ['name=y'] => "-"
    // "['id=x', 'name=y']" => "['id=x']"
    // "['name=x', 'name=y']" => "['name=x']"
    // filtered.forEach(row => {
    //   row.attribute2 = cleanAttributes(row.attribute2);
    //   row.attribute1 = cleanAttributes(row.attribute1);
    // });

    let {aggregated, tagSets} = aggregatedRows(filtered, ['tag1', 'tag2'], ['attribute1', 'attribute2', 'relation_type']);

    console.log(globalTagSets);
    save(aggregated, '../thething-markups/window2dom.csv');

  });
}


/**
 * This function generates information used by Window2DOM row in Table 1.
 * 
 * 1/ All the markups that clobber window.x lookups.
 * 2/ The aggregated of tags that are used to clobber window.x lookups.
 * 3/ Merged rules with aggregated tags from 2/.
 * 
 */
function DOC2DOM(){
  return readCSV(MARKUPS_PATH).then(data => {
    const clobberedSingle = ['document.x'];
    const filtered = findAll(data, clobberedSingle);

    // filtered.forEach(row => {
    //   row.attribute2 = cleanAttributes(row.attribute2);
    //   row.attribute1 = cleanAttributes(row.attribute1);
    // });

    let {aggregated, tagSets} = aggregatedRows(filtered, ['tag1', 'tag2'], ['attribute1', 'attribute2', 'relation_type']);

    console.log(globalTagSets);
    save(aggregated, '../thething-markups/doc2dom.csv');
  });
}


function DOM2DOM(){
  return readCSV(MARKUPS_PATH).then(data => {
    const clobberedSingle = ['window.x.y', 'document.x.y'];
    const filtered = findAll(data, clobberedSingle);

    // Also, remove the attribute2 column which has 'name=x' or 'id=x'
    // ['id=y'] or ['name=y'] => "-"
    // "['id=x', 'name=y']" => "['id=x']"
    // "['name=x', 'name=y']" => "['name=x']"
    filtered.forEach(row => {
      row.attribute2 = cleanAttributes(row.attribute2);
      row.attribute1 = cleanAttributes(row.attribute1);
    });

    let {aggregated, tagSets} = aggregatedRows(filtered, ['tag1', 'tag2'], ['attribute1', 'attribute2', 'relation_type']);

    console.log(globalTagSets);
    save(aggregated, '../thething-markups/dom2dom.csv');

    outputTagSets();
  });
}

function outputTagSets(){
  let tagSets = {};
  Object.keys(globalTagSets).forEach(tagSet => {
    tagSets[globalTagSets[tagSet]] = tagSet.split('|').join(', ');  
  })

  fs.writeFileSync('../thething-markups/tag-sets.json', JSON.stringify(tagSets, null, 2));
};

WINDOW2DOM();
DOC2DOM();
DOM2DOM();